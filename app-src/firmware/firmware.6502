; Retro6K System Firmware
; zeropage addresses used by interactive console
CMDBUF     = $00 ; 32 bytes
INRADIX    = $20 ; 0=decimal; 1=hexadecimal
INDIRECT   = $21 ; count of @ in currently-scanning number
MEMASSIGN  = $22 ; nonzero if scanned number ends with = sign
DESTWORD   = $24 ; destination address of memcopy command
DESTIND    = $26 ; destination indirect count
SRCDWORD   = $28 ; source address/literal of memcopy command
SRCIND     = $2C ; source indirect count
DESTSIZE   = $2E ; 1=byte; 2=word; 4=dword; 32=char*32; 0=zterm
SRCSIZE    = $2F ; 1=byte; 2=word; 4=dword; 32=char*32; 0=zterm

; zeropage addresses used in subroutines
TEXTBUF   = $80 ; up to 16 bytes
DWORDBUF  = $90
WORDBUF0  = $94
WORDBUF1  = $96
TCURSORLO = $98 ; bits 0-4: text cursor column; bits 5-7: text cursor row b0-2
TCURSORHI = $99 ; bits 0-1: text cursor row bits 3-4
TCBLINK   = $9A ; bits 0-4: cursor blink cycle counter
CONSFLAGS = $9B ; bit 7: print next char literally
COLORS    = $9C ; colors (4 bytes) for new characters to print
CHSRCPTR  = $A0 ; character source row pointers (4 bytes) for scrolling
CHDESTPTR = $A4 ; character destination row pointers (4 bytes) for scrolling
COSRCPTR  = $A8 ; color source row pointers (10 bytes) for scrolling
CODESTPTR = $B2 ; color destination row pointers (10 bytes) for scrolling
WSTARGET  = $BD ; VIDEOSTATE flag to wait for
COBYTES   = $C0 ; packed color bytes (5 bytes)
BLINKBITS = $C5 ; which bits to toggle for blinking cursor (5 bytes)
COKNMASK  = $CA ; keep-nybble color mask
CORNMASK  = $CB ; replace-nybble color mask
POINTER0  = $E0
POINTER1  = $E2
POINTER2  = $E4
POINTER3  = $E6
NBTODEC   = $E8
BTODECADJ = $E9
SRSCRATCH = $F0
SAVEX     = $FE
SAVEY     = $FF
; special system addresses
KBDIN           = $0244
VIDEOSTATE      = $02FC
SOUNDVOICE0FREQ = $0380
SOUNDVOICE0VOL  = $0388
SOUNDVOICETYPES = $038C
FVMCDEST        = $03F8
FVMCSRC         = $03F9
DLSOFF          = $03FC
DLSON           = $03FD
DEBUGLOG        = $03FF

  .org $F000
; firmware version signature
  .word 20310 ; 2031-development
entry: ; system power-on or reset
  ; misc initialization
  SEI
  CLD
  LDA #$00
  STA FVMCSRC
  STA FVMCDEST
  LDX #$F0
dlsoffloop:
  STX DLSOFF ; turn off debug log suppression
  INX
  BNE dlsoffloop
  JSR waitvscana
  ; display cartridge identification in bottom of screen
  LDX #$00
cartidcolloop:
  LDA #$F0
  STA $0B2A,X
  STA $0C4A,X
  STA $0D6A,X
  LDA #$50
  STA $0E8A,X
  STA $0FAA,X
  LDA #$53
  STA $0B4A,X
  STA $0C6A,X
  STA $0D8A,X
  LDA #$A0
  STA $0EAA,X
  STA $0FCA,X
  LDA #$02
  STA $09EA,X
  STA $0A2A,X
  LDA $1FFF,X
  STA $0A0A,X
  INX
  CPX #$0C
  BCC cartidcolloop
  LDA #$20
  STA $0A0A
  STA $0A15
  ;initialize palette
  LDX #$00
initpalloop:  
  LDA datasyscolors,X ; palette colors
  STA $0FE0,X
  INX
  CPX #$20
  BCC initpalloop
  ; load system font (specific subset in specific order)
  LDA #$E0
  STA FVMCSRC
  LDA #$10
  STA FVMCDEST
  JSR waitvscana
  LDX #$20
  JSR fvmcchar
  LDX #$00
initfontloop:
  LDA initfontsrcpage,X
  STA FVMCSRC
  LDA initfontdestpage,X
  STA FVMCDEST
  BEQ initfontloopexit
  JSR fvmcpage
  INX
  BNE initfontloop ; BRA; X != 0
initfontloopexit:
  ; detect presence of valid cartridge
  ; by checking for magic bytes 47 A9 0C 1E
  LDA $200A
  CMP #$47
  BNE nocart
  LDA $200B
  CMP #$A9
  BNE nocart
  LDA $200C
  CMP #$0C
  BNE nocart
  LDA $200D
  CMP #$1E
  BNE nocart
  ; if we got this far, jump to cartridge start vector
  JMP ($200E)
nocart: ; no cartridge inserted
  ; initialize screen display
  LDA #$00
  STA POINTER0+0
  STA SRSCRATCH+3
  LDA #$08
  STA POINTER0+1
  LDA #>datatext
  STA POINTER1+1
  LDA VIDEOSTATE
  AND #$CC
  ORA #$02
  STA WSTARGET
  LDA #$FF
  STA SAVEX
initscreenrowloop:
  LDA SRSCRATCH+3 ; check if we're in the middle of a constant-row run
  BNE initscreencrcontinue
  INC SAVEX
  LDX SAVEX
  LDA datascreendef,X
  AND #$0F
  BNE initscreenconstrow
  LDA datascreendef,X
  ASL A
  STA POINTER1+0
  LDY #$00
initscreendrloop:
  LDA (POINTER1),Y
  JSR waitscanx
  STA (POINTER0),Y
  INY
  CPY #$20
  BCC initscreendrloop
  BCS initscreenrowadvance ; BRA
initscreenconstrow:
  STA SRSCRATCH+3 ; save runlen
initscreencrcontinue:
  LDX SAVEX
  LDA datascreendef,X ; get index into table of constant values
  LSR A
  LSR A
  LSR A
  LSR A
  TAY
  LDA datascreenconst,Y
  LDY #$00
  DEC SRSCRATCH+3 ; decrement runlen
initscreencrcolloop:
  JSR waitscanx
  STA (POINTER0),Y
  INY
  CPY #$20
  BCC initscreencrcolloop
initscreenrowadvance:
  CLC
  LDA POINTER0+0
  ADC #$20
  STA POINTER0+0
  BCC initscreencheckend ; if POINTER0 didn't change pages, check for exit contition below
  INC POINTER0+1
  BCS initscreenrowloop ; BRA
initscreencheckend:
  CMP #$E0
  BNE initscreenrowloop ; if POINTER0 low byte == #$E0, inspect high byte
  LDA POINTER0+1
  CMP #$0F
  BCC initscreenrowloop ; if POINTER0 >= $0FE0, exit loop now
  ; copy a few extra characters from Bank E font to video memory
  LDA #$10 ; destination page: screen font row 0
  STA FVMCDEST
  LDA #$EB ; source page: Bank E font row B
  STA FVMCSRC
  LDX #$C0 ; copy column C: copyright sign to position $0C
  JSR waitvscana
  JSR fvmcchar
  LDA #$EA ; source page: Bank E font row A
  STA FVMCSRC
  LDX #$E0 ; copy column E: diamond outline to position $0E
  JSR fvmcchar
  LDA #$EE ; source page: Bank E font row E
  STA FVMCSRC
  LDA #$16 ; destination page: screen font row 6
  STA FVMCDEST
  LDX #$00 ; copy column 0: en dash to position $60
  JSR fvmcchar
  LDA #$00 ; disable FVMC
  STA FVMCDEST
  STA FVMCSRC
  ; set up pointer to compressed graphics
  LDA #<datagfx
  STA POINTER0+0
  LDA #>datagfx
  STA POINTER0+1
  ; check aspect ratio
  LDA VIDEOSTATE
  AND #$80
  BNE widescreenlogo
  ; logo (classic)
  JSR waitvscana
  LDX #$00
logocloop:
  TXA
  ORA #$C0 ; X+C0
  STA $096C,X
  ORA #$08 ; X+C8
  STA $098C,X
  EOR #$18 ; X+D0
  STA $09AC,X
  ORA #$08 ; X+D8
  STA $09CC,X
  EOR #$38 ; X+E0
  STA $09EC,X
  ORA #$08 ; X+E8
  STA $0A0C,X
  JSR logocommonpercolumn ; sets Acc := 0
  STA $094C,X ; use blank characters on rows 10 and 17
  STA $0A2C,X
  INX
  CPX #$08
  BCC logocloop
  LDX #$00 ; offset for decompress instructions
  BEQ logodecompressloop ; BRA
widescreenlogo:  
  ; logo (wide)
  JSR waitvscana
  LDX #$00
logowloop1:
  TXA
  ORA #$80 ; X+80
  STA $094C,X
  ORA #$08 ; X+88
  STA $096C,X
  EOR #$18 ; X+90
  STA $098C,X
  ORA #$08 ; X+98
  STA $09AC,X
  EOR #$38 ; X+A0
  STA $09CC,X
  ORA #$08 ; X+A8
  STA $09EC,X
  EOR #$18 ; X+B0
  STA $0A0C,X
  ORA #$08 ; X+B8
  STA $0A2C,X
  JSR logocommonpercolumn
  INX
  CPX #$08
  BCC logowloop1
  ; blank out cells not used for logo
  LDY #$FF
logowloop2:
  INY
  LDX datalogowblankcells,Y
  STA $0940,X
  BNE logowloop2
  LDX #(datadecompressinstw-datadecompressinstc) ; offset for decompress instructions
logodecompressloop:
  LDA datadecompressinstc,X
  STX SAVEX
  BEQ logocolors
  CMP #$F1 ; flip page $07 in place
  BEQ flippage7
  CMP #$F2 ; flipcopy page $07 low half to high half
  BEQ flipcopypage7
  TAY
  AND #$F0
  CMP #$C0 ; decompress a page (Y low nybble) into page $07
  BEQ logodecompresspage
  CMP #$10 ; copy page $07 to page (Y)
  BEQ logocopypage
logodecompressloopadvance:
  LDX SAVEX
  INX
  BNE logodecompressloop ; BRA
logocolors:
  ; cell color overrides common to both aspect ratios
  LDX #$00
  JSR waitvscana
logocolorloop:
  LDA datalogocolors+$00,X
  STA $0B0E,X
  LDA datalogocolors+$04,X
  STA $0B2E,X
  LDA datalogocolors+$08,X
  STA $0C2E,X
  LDA datalogocolors+$0C,X
  STA $0C4E,X
  LDA datalogocolors+$10,X
  STA $0D4E,X
  LDA datalogocolors+$14,X
  STA $0D6E,X
  LDA datalogocolors+$18,X
  STA $0E6E,X
  LDA datalogocolors+$1C,X
  STA $0E8E,X
  LDA datalogocolors+$20,X
  STA $0F8E,X
  LDA datalogocolors+$24,X
  STA $0FAE,X
  INX
  CPX #$04
  BCC logocolorloop
  BCS startsysshell
logocommonpercolumn:
  LDA #$CC ; bits 0-2 on for "foreground" colors
  STA $0AEC,X
  STA $0B0C,X
  STA $0B2C,X
  STA $0B4C,X
  STA $0C0C,X
  STA $0C2C,X
  STA $0C4C,X
  STA $0C6C,X
  STA $0D2C,X
  STA $0D4C,X
  STA $0D6C,X
  STA $0D8C,X
  LDA #$AA ; bits 3-4 on for "secondary" colors
  STA $0E4C,X
  STA $0E6C,X
  STA $0E8C,X
  STA $0EAC,X
  STA $0F6C,X
  STA $0F8C,X
  STA $0FAC,X
  STA $0FCC,X
  LDA #$00 ; blank out character 00
  STA $1000,X
  STA $1008,X
  RTS
logocopypage:
  LDA #$07
  STA FVMCSRC
  STY FVMCDEST
  JSR fvmcpage
  JMP logodecompressloopadvance ; BRA?
logodecompresspage:
  TYA
  AND #$0F
  JSR decompresspage
  JMP logodecompressloopadvance ; BRA?
flippage7:
  JMP logodecompressloopadvance ; BRA?
flipcopypage7:
  JMP logodecompressloopadvance ; BRA?

startsysshell:
  ; initialize shell state
  LDA #$20
  STA TCURSORLO
  LDA #$0A
  STA TCURSORHI
  LDA #$00
  STA TCBLINK
  STA COLORS+0
  STA COLORS+1
  LDA #$07
  STA COLORS+2
  STA COLORS+3
  LDA #$AA ; blink "secondary" colors in bitplanes 0-2 (RGB)
  STA BLINKBITS+0
  STA BLINKBITS+1
  STA BLINKBITS+2
  LDA #$CC ; blink "foreground" colors in bitplanes 3-4 (intensity)
  STA BLINKBITS+3
  STA BLINKBITS+4
  LDA #$00
  STA BTODECADJ ; by default, set use unsigned decimal display
readcommand:
  LDA #$1E ; ">" in SCE
  JSR printch
readcommandkeyloop:
  JSR waitvscana
  JSR cursortick
  LDA KBDIN
  BEQ readcommandkeyloop
  CMP #$0D
  BEQ processcommand
processliteralchar:
  JSR printch
  JMP readcommandkeyloop
processcommand:
  ; check if escape sequence in progress
  LDA CONSFLAGS
  BPL pcsetupcopycmd
  LDA #$0D ; replace CR that got us here, then continue as if not a CR
  BNE processliteralchar ; BRA: Z flag cleared by previous LDA
pcsetupcopycmd:
  ; read and interpret command that was entered
  ; set POINTER0 to first column of current line
  LDA TCURSORLO
  AND #$E0
  STA POINTER0+0
  LDA TCURSORHI
  STA POINTER0+1
  ; copy command line from screen memory to zp buffer
  LDY #$00
  JSR waitvscana
pccopyloop:
  LDA (POINTER0),Y
  STA CMDBUF,Y
  INY
  CPY #$20
  BCC pccopyloop
  ; now send CRLF to screen
  LDA #$0D
  JSR printch
  LDA #$0A
  JSR printch
  ; initialize MEMASSIGN, for memory commands
  LDA #$00
  STA MEMASSIGN
  ; scan CMDBUF for command start indicator (">")
  TAX ; one byte shorter than LDX #$00
pcscanstartloop:
  LDA CMDBUF,X
  CMP #$20 ; leading spaces allowed
  BEQ pcscanstartnext
  CMP #$1E ; ">"
  BEQ pcscancmdnext
  BNE pcscanstarterror ; BRA else
pcscanstartnext:
  INX
  CPX #$1F ; command start indicator doesn't make sense in final column
  BCC pcscanstartloop
pcscanstarterror:
  JSR beep
  BEQ readcommand ; BRA: Z flag set by beep
pcscancmdnext:
  INX
  CPX #$20
  BCC pcscancmdloop
pcscancmderror:
  JSR beep
  BEQ readcommand ; BRA: Z flag set by beep
pcscancmdloop:  
  LDA CMDBUF,X
  CMP #$20 ; leading spaces allowed
  BEQ pcscancmdnext
  AND #$DF ; case-insensitive comparisons follow
  CMP #"C"
  BEQ clearscreen
  CMP #"R"
  BEQ entry ; TODO: test following character for rb=reboot, ri=return from int, rs = return from sub
  CMP #"X"
  BEQ pcexec
pcmemchartests:
  CMP #"B"
  BEQ pcmemb
  CMP #"D"
  BEQ pcmemd
  CMP #"W"
  BEQ pcmemw
  BNE pcscancmderror ; BRA else
pcscandec:
  LDY #$00
  STY INRADIX
  STY INDIRECT
pcscandecloop:
  LDA CMDBUF,X
  CMP #$20 ; skip copying spaces
  BEQ pcscandecskip
  CMP #$12 ; count indirect symbols
  BEQ pcscandecind
  CMP #$14 ; if "$" encountered, switch to scanning for hex (and skip $)
  BEQ pcscanhexskip
  CMP #$3D ; note trailing =
  BEQ pcscandecexiteq
  CMP #$60 ; copy if A == "-"
  BEQ pcscandeccopy
  CMP #$30 ; stop copying if A < "0"
  BCC pcscandecexit
  CMP #$3A ; stop copying if A > "9"
  BCS pcscandecexit
pcscandeccopy:
  STA TEXTBUF,Y
  INY
pcscandecskip:
  INX
  CPY #$10
  BCS pcscandecexitnonull
  CPX #$20
  BCC pcscandecloop
  BCS pcscandecexit ; BRA
pcscandecind:
  INC INDIRECT
  BNE pcscandecskip ; BRA
pcscandecexiteq:
  LDA MEMASSIGN
  BNE pcscancmderror
  INC MEMASSIGN
pcscandecexit:
  LDA #$00
  STA TEXTBUF,Y
pcscandecexitnonull:
  RTS
pcscanhex:
  LDY #$00
pcscanhexloop:
  LDA CMDBUF,X
  CMP #$20 ; skip copying spaces
  BEQ pcscanhexskip
  CMP #$14 ; skip copying "$"s
  BEQ pcscanhexskip
  CMP #$3D ; note trailing =
  BEQ pcscanhexexiteq
  CMP #$30 ; stop copying if A < "0"
  BCC pcscanhexexit
  CMP #$67 ; stop copying if A > "f"
  BCS pcscanhexexit
  CMP #$3A ; copy if A <= "9"
  BCC pcscanhexcopy
  CMP #$60 ; copy if A >= "-"
  BCS pcscanhexcopy
  CMP #$41 ; stop copying if A < "A"
  BCC pcscanhexexit
  CMP #$47 ; stop copying if A > "F"
  BCS pcscanhexexit
pcscanhexcopy:
  STA TEXTBUF,Y
  INY
pcscanhexskip:
  INX
  CPY #$10
  BCS pcscanhexexitnonull
  CPX #$20
  BCC pcscanhexloop
  BCS pcscanhexexit ; BRA
pcscanhexexiteq:
  LDA MEMASSIGN
  BNE pcscancmderror
  INC MEMASSIGN
pcscanhexexit:
  LDA #$00
  STA TEXTBUF,Y
pcscanhexexitnonull:
  LDA #$01
  STA INRADIX
  RTS
pcmemreadnextarg:
  INX
  CPX #$1F
  BCS pcscancmderror
  LDA CMDBUF,X
  CMP #$20
  BEQ pcmemreadnextarg
  AND #$DF ; case-insensitive comparisons follow
  JMP pcmemchartests ; re-use logic from above
pcmemb:
  LDA #$01
  STA SRCSIZE
  BNE pcmemreadarg ; BRA
pcmemw:
  LDA #$02
  STA SRCSIZE
  BNE pcmemreadarg ; BRA
pcmemd:
  LDA #$04
  STA SRCSIZE
  ; BRA pcmemreadarg
pcmemreadarg:
  INX
  JSR pcscandec
  LDA INRADIX
  BNE *+8 ; skip JSR and JMP
  JSR dectodword
  JMP pcmemaccept
  JSR hextodword
pcmemaccept:
  LDA MEMASSIGN
  BEQ pcmemreadout
  CMP #$02 ; MEMASSIGN == 2 -> we have now read both dest and src
  BCS pcmemassign
  INC MEMASSIGN
  LDA DWORDBUF+0
  STA DESTWORD+0
  LDA DWORDBUF+1
  STA DESTWORD+1
  LDA SRCSIZE
  STA DESTSIZE
  LDA INDIRECT
  STA DESTIND
  BCC pcmemreadnextarg ; BRA
pcmemreadout:
  LDA INDIRECT
  STA SRCIND
  BEQ pcmrfinalsrc
  JSR pcmemindirectsrc
pcmrfinalsrc:
  LDA SRCSIZE
  STA NBTODEC
  JSR bytestodec
  ; assume here cursor is at beginning of line
  TXA
  TAY
  ; oh and restore DWORDBUF if it was negated in decimal conversion
  ; (after copying X to Y because dwordnegate clobbers X and A)
  LDA SRSCRATCH+6
  BPL *+5 ; skip following JSR
  JSR dwordnegate
  TYA ; get bytestodec-set X value back into accumulator
  CLC
  ADC #$15 ; adjust this to set position of decimal output
  ORA TCURSORLO
  STA TCURSORLO
  LDA TEXTBUF+5 ; sign character of output
  JSR printch
pcmrdecprintloop:
  LDA TEXTBUF+16-256,Y
  JSR printch
  INY
  BNE pcmrdecprintloop
  JSR dwordtohex
  LDA TCURSORLO
  AND #$F0
  STA TCURSORLO
  LDA #$07
  EOR SRCSIZE
  SEC
  ROL
  TAY ; set Y to 15 - 2 * SRCSIZE
  ORA TCURSORLO
  STA TCURSORLO
  LDA #$14 ; "$"
  JSR printch
  INY
pcmemdwtohexloop:
  LDA TEXTBUF,Y
  JSR printch
  INY
  CPY #$10
  BCC pcmemdwtohexloop
  JMP readcommand
pcmemassign:
  LDA INDIRECT
  STA SRCIND
  BEQ *+5 ; skip following JSR
  JSR pcmemindirectsrc
  LDX #-4
pcmacopysrcdwordloop:
  LDA DWORDBUF+4,X
  STA SRCDWORD+4,X
  INX
  BNE pcmacopysrcdwordloop
  LDY #$00
  LDA DESTIND
  BEQ pcscancmderror
pcmadestindloop:
  DEC DESTIND
  BEQ pcmafinaldest
  JSR waithscanx
  LDA (DESTWORD),Y
  PHA
  INY
  JSR waitscanx2
  LDA (DESTWORD),Y
  STA DESTWORD+1
  DEY
  PLA
  STA DESTWORD+0
  JMP pcmadestindloop
pcmafinaldest:
  LDA SRCSIZE
  CMP DESTSIZE
  BCS pcmacopyprim
  ; sign extend if necessary
  TAX
  LDA SRCDWORD-1,X
  ORA #$7F
  BMI pcmasignextloop
  LDA #$00
pcmasignextloop:
  STA SRCDWORD,X
  INX
  CPX #$04
  BCC pcmasignextloop
pcmacopyprim:
  ; LDY #$00 ; Y should already be zero
  pcmacopyprimloop:
  JSR waithscanx
  LDA SRCDWORD,Y
  STA (DESTWORD),Y
  INY
  CPY DESTSIZE
  BCC pcmacopyprimloop
  LDA TCURSORLO
  ORA #$1E
  STA TCURSORLO
  LDA #$4F ; "O"
  JSR printch
  LDA #$4B ; "K"
  JSR printch
  JMP readcommand
pcmemindirectsrc:
  JSR waithscanx
  LDA (DWORDBUF),Y
  STA POINTER1+0
  PHA
  INY
  JSR waitscanx2
  LDA (DWORDBUF),Y
  STA POINTER1+1
  PHA
  INY
  JSR waitscanx2
  LDA (DWORDBUF),Y
  STA DWORDBUF+2
  INY
  JSR waitscanx2
  LDA (DWORDBUF),Y
  STA DWORDBUF+3
  LDY #$00
  PLA
  STA DWORDBUF+1
  PLA
  STA DWORDBUF+0
  DEC SRCIND
  BNE pcmemindirectsrc
  RTS

pcexec:
  INX
  JSR pcscandec
  LDA INRADIX
  BNE *+8 ; skip JSR and JMP
  JSR dectodword
  JMP pcxindirectcheck
  JSR hextodword
pcxindirectcheck:
  ; perform indirection if necessary
  LDA INDIRECT
  BEQ pcxgo
  STA SRCIND
  JSR pcmemindirectsrc
pcxgo:
  ; first, set return address in case we're jumping to something with an RTS
  LDA #>(readcommand-1)
  PHA
  LDA #<(readcommand-1)
  PHA
  ; now setup jump indirect
  LDA DWORDBUF+0
  STA POINTER3+0
  LDA DWORDBUF+1
  STA POINTER3+1
  ; go
  JMP (POINTER3)

calccolorbytes:
; Subroutine: Transpose color selections from COLORS[0-3] to COLORBYTES[0-4]
  PHA
  TXA
  PHA
  TYA
  PHA
  LDY #$00
calccolorloopy:
  LDA COLORS,Y
  LDX #$00
calccolorloopx:
  LSR A
  ROR COBYTES,X
  INX
  CPX #$05
  BCC calccolorloopx
  INY
  CPY #$04
  BCC calccolorloopy
  LDX #$00
calccolorloopz:
  LDA COBYTES,X
  AND #$F0
  STA COBYTES,X
  LSR A
  LSR A
  LSR A
  LSR A
  ORA COBYTES,X
  STA COBYTES,X
  INX
  CPX #$05
  BCC calccolorloopz
  PLA
  TAY
  PLA
  TAX
  PLA
  RTS

clearscreen:
  JSR calccolorbytes
  LDX #$00
clearscreenloop0:
  JSR waitvscana
clearscreenloop1:
  LDA #$20
  STA $0800,X
  STA $0900,X
  CPX #$40
  BCC *+4 ; skip next if X < $40
  LDA COBYTES+0
  STA $0A00,X
  LDA COBYTES+0
  CPX #$60
  BCC *+4 ; skip next if X < $60
  LDA COBYTES+1
  STA $0B00,X
  LDA COBYTES+1
  CPX #$80
  BCC *+4 ; skip next if X < $80
  LDA COBYTES+2
  STA $0C00,X
  LDA COBYTES+2
  CPX #$A0
  BCC *+4 ; skip next if X < $A0
  LDA COBYTES+3
  STA $0D00,X
  LDA COBYTES+3
  CPX #$C0
  BCC *+4 ; skip next if X < $C0
  LDA COBYTES+4
  STA $0E00,X
  LDA COBYTES+4
  CPX #$E0
  BCS *+5 ; skip next if X >= $E0
  STA $0F00,X
  INX
  BEQ clearscreenfinish
  TXA
  AND #$0F
  BEQ clearscreenloop0
  BNE clearscreenloop1
clearscreenfinish:
  LDA #$00
  STA TCURSORLO
  STA TCBLINK
  LDA #$08
  STA TCURSORHI
  JMP readcommand

coptradvance:
  CLC
  LDA COSRCPTR+0
  ADC #$20
  STA COSRCPTR+0
  LDA COSRCPTR+1
  ADC #$01
  STA COSRCPTR+1
  RTS

coptrcalc:
  LDA TCURSORLO
  AND #$1F
  TAY
  LDA TCURSORLO
  AND #$C0
  STA COSRCPTR+0
  LDA TCURSORHI
  LSR A ; now #$04 or #$05
  STA COSRCPTR+1
  LDA COSRCPTR+0
  ROR A ; bit shifted out is zero, so carry is now clear
  ADC #$40
  STA COSRCPTR+0
  LDA COSRCPTR+1
  ADC #$06 ; should not cause a carry
  STA COSRCPTR+1
  ;JMP calcrownybble

calcrownybble:
  LDA TCURSORLO
  AND #$20
  BEQ *+4
  LDA #$FF ; Acc now #$00 for even row or #$FF for odd row
  EOR #$0F ; Acc now #$0F for even row or #$F0 for odd row
  RTS

decompresspage:
; Subroutine: Load page number Acc from compressed data beginning at POINTER0
; and store the decompressed data in page 07
; Side effects: Acc, X, Y, POINTER1, POINTER2 clobbered
  ; get starting address of requested page
CDATASTART     = POINTER0
DECODELEN      = SRSCRATCH+0 ; not needed?
READHEADBYTE   = POINTER1
READHEADNYBBLE = SRSCRATCH+1
WRITEHEADBYTE  = POINTER2
WRITEHEADCRUMB = SRSCRATCH+2
RUNLENCRUMBS   = SRSCRATCH+3
RUNLENBYTES    = SRSCRATCH+4
RUNDIGIT       = SRSCRATCH+5
RUNVAL         = SRSCRATCH+6
NEWRUNVAL      = SRSCRATCH+7
READBYTEBUF    = SRSCRATCH+8
WRITEBYTEBUF   = SRSCRATCH+9
READNYBBLEBUF  = SRSCRATCH+10 ; not needed?
WRITECRUMBBUF  = SRSCRATCH+11 ; not needed?
  ; get starting address of requested page
  ; (CDATASTART),Y + CDATASTART
  ASL A
  TAY
  CLC
  LDA (CDATASTART),Y
  ADC CDATASTART+0
  STA READHEADBYTE+0
  INY
  LDA (CDATASTART),Y
  ADC CDATASTART+1
  STA READHEADBYTE+1
  LDA #$00
  STA READHEADNYBBLE
  STA WRITEHEADBYTE
  STA WRITEHEADCRUMB
  STA WRITEBYTEBUF
  LDA #$07
  STA WRITEHEADBYTE+1
  LDA #$FF
  STA RUNVAL
  LDA #$00
  STA RUNLENBYTES
  STA RUNLENCRUMBS
  LDY #$00 ; because there are no unindexed indirect load/store opcodes
  ; read one nybble
dcpreadnybble:
  LDA READHEADNYBBLE
  BNE dcpreadnybbleelse
  ; low nybble; fetch byte
  LDA #$01 ; next time, read saved high nybble
  STA READHEADNYBBLE
  LDA (READHEADBYTE),Y
  STA READBYTEBUF
  INC READHEADBYTE
  BNE *+4 ; skip next INC zp if nonzero
  INC READHEADBYTE+1 ; if low byte zero, increment high byte
  ; extract low nybble (Acc still holds just-read byte)
  AND #$0F
  BPL dcpreadnybbleendif ; BRA: negative flag cleared by AND
dcpreadnybbleelse:
  ; extract high nybble from stored byte value
  LDA #$00 ; next time, read low nybble from fresh byte
  STA READHEADNYBBLE
  LDA READBYTEBUF
  LSR A
  LSR A
  LSR A
  LSR A
dcpreadnybbleendif:
  ; just-read nybble in Acc
  ; separate to NEWRUNVAL and RUNDIGIT
  TAX
  AND #$03
  STA NEWRUNVAL
  TXA
  LSR A
  LSR A
  BNE *+4 ; skip next LDA if nonzero
  LDA #$04 ; replace 0 digit with 4
  STA RUNDIGIT
  ; is this a continuation of a run spec in progress?
  LDA NEWRUNVAL
  CMP RUNVAL
  BNE dcpwriterun
  ; add new digit to run length
  LDA RUNLENBYTES
  ; it's possible we read past the end of compressed data and found a
  ; matching run spec nybble by chance. a too-long last run isn't a problem,
  ; because we won't write past a page boundary, but we need a stop condition
  ; for reading garbage as a run spec. If computed run length meets or
  ; exceeds maximum (256 bytes), just stop reading and write the run.
  ASL A
  BCS dcprunlenoverflow
  ASL A
  BCS dcprunlenoverflow
  ADC RUNLENCRUMBS
  BCS dcprunlenoverflow
  STA RUNLENBYTES
  LDA RUNDIGIT
  STA RUNLENCRUMBS
  ; read another nybble
  JMP dcpreadnybble
dcprunlenoverflow:
  LDA #$04
  STA RUNLENCRUMBS
  LDA #$FF
  STA RUNLENBYTES ; 256 bytes is represented as 255 bytes and 4 crumbs
  ; fall through to write run
dcpwriterun:
  ; check if run length has reached zero
  ; this contition is evaluated at the top of the loop because reading the
  ; first nybble counts as non-matching and therefore triggers writing a
  ; zero-length run
  LDA RUNLENCRUMBS
  BNE dcpwriterunskip1
  LDA RUNLENBYTES
  BEQ dcpwriterundone
dcpwriterunskip1:
  ; output a crumb: shift RUNVAL into high bits of WRITEBYTEBUF
  ; (earlier output crumbs get shifted lower)
  LDA RUNVAL
  LSR A
  ROR WRITEBYTEBUF
  LSR A
  ROR WRITEBYTEBUF
  ; advance write head by one crumb
  LDA WRITEHEADCRUMB
  ADC #$01 ; if WRITEBYTEBUF was not already full, carry is clear
  CMP #$04
  BCC dcpwriterunskip2 ; do the following if WRITEBYTEBUF is full
  ; write byte from buffer
  LDA WRITEBYTEBUF
  STA (WRITEHEADBYTE),Y
  INC WRITEHEADBYTE
  BNE *+3 ; if nonzero, skip next RTS
  RTS ; if zero, page is full, decompression is done
  ; INC DECODELEN ; not needed?
  LDA #$00 ; reset WRITEBYTEBUF and WRITEHEADCRUMB
  STA WRITEBYTEBUF
dcpwriterunskip2:
  STA WRITEHEADCRUMB
  ; decrement run length
  DEC RUNLENCRUMBS
  BPL dcpwriterun ; if RUNLENCRUMBS wraps around to >=128, perform borrow
  ; from RUNLENBYTES below; otherwise, continue writing run above.
  DEC RUNLENBYTES
  LDA #$03
  STA RUNLENCRUMBS
  BNE dcpwriterun ; BRA: zero flag cleared by LDA above
dcpwriterundone:
  ; now we need to retrieve the nonmatching nybble that triggered the run to
  ; be written, and set it up as the runspec in progress
  LDA NEWRUNVAL
  STA RUNVAL
  LDA RUNDIGIT
  STA RUNLENCRUMBS
  ; RUNLENBYTES should still be 0 at this point
  JMP dcpreadnybble ; this could be BNE as BRA because RUNDIGIT is always
  ; nonzero, but it seems to be too far for a branch to jump

dectodword:
  STX SAVEX
  ;LDA TEXTBUF+0
  ;CMP #$60 ; check for minus sign
  ;BNE *+3 ; skip next INX
  ;INX
  ; the four lines above are completely unnecessary and ineffective because X is clobbered below
  LDA #$00
  STA DWORDBUF+0
  STA DWORDBUF+1
  STA DWORDBUF+2
  STA DWORDBUF+3
  STA SRSCRATCH+12
  TAX
dectodwloop0:
  LDA TEXTBUF,X
  BEQ dectodwexit ; stop at null byte
  ; multiply DWORDBUF by 10
  JSR dwordmul2
  LDX #-4
dectodwloop3:
  LDA DWORDBUF+4,X
  STA SRSCRATCH+8,X
  INX
  BNE dectodwloop3
  JSR dwordmul2
  JSR dwordmul2
  CLC
  LDX #-4
dectodwloop4:
  LDA SRSCRATCH+8,X
  ADC DWORDBUF+4,X
  STA DWORDBUF+4,X
  INX
  BNE dectodwloop4
  LDX SRSCRATCH+12
  ; done multiplying by 10, now add new digit
  LDA TEXTBUF,X
  AND #$0F
  CLC
  ADC DWORDBUF+0
  STA DWORDBUF+0
  LDX #-3
dectodwloop1:
  LDA DWORDBUF+4,X
  ADC #$00
  STA DWORDBUF+4,X
  INX
  BNE dectodwloop1
  INC SRSCRATCH+12
  LDX SRSCRATCH+12
  CPX #$10
  BCC dectodwloop0
dectodwexit:
  LDX SAVEX
  LDA TEXTBUF+0
  CMP #$60
  ; BNE dectodwpositive
  ; JMP dwordnegate
  BEQ dwordnegate
dectodwpositive:
  RTS

dwordmul2:
  ASL DWORDBUF+0
  ROL DWORDBUF+1
  ROL DWORDBUF+2
  ROL DWORDBUF+3
  RTS

dwordnegate:
  ; negate DWORDBUF
  SEC
  LDX #-4
dectodwloop2:
  LDA DWORDBUF+4,X
  EOR #$FF
  ADC #$00
  STA DWORDBUF+4,X
  INX
  BNE dectodwloop2
  RTS

bytetodec:
  LDA #1
  STA NBTODEC
  BNE bytestodec ; BRA
wordtodec:
  LDA #2
  STA NBTODEC
  BNE bytestodec ; BRA
dwordtodec:
  LDA #4
  STA NBTODEC
bytestodec:
; Subroutine: Convert value in DWORDBUF (low NBTODEC bytes) to decimal;
; add or subtract 256^NBTODEC according to BTODECADJ.
; Side effects: result stored in TEXTBUF[5-15];
; sign character in TEXTBUF[5]; neg digit count stored in X.
; Accumulator, Y register clobbered.
; SRSCRATCH[0-4] holds bit power decimal value
; SRSCRATCH[6] holds various flags:
;        80: number is negative
;         2: number is not minimum value
;         1: add extra high bit
  ; interpret BTODECADJ and set scratch6 flags according to relevant processor flags
  LDA BTODECADJ
  BEQ btdsetupp ; 0 -> positive
  CMP #$20
  BEQ btdsetupua ; 32 -> positive, with carry as extra high bit
  CMP #$40
  BEQ btdsetupbp ; 64 -> positive, with 1 as extra high bit
  CMP #$A0
  BEQ btdsetupn ; -96 -> negative
  CMP #$C0
  BEQ btdsetups ; -64 -> negative if N xor V
  CMP #$E0
  ;BEQ btdsetupus ; -32 -> negative if not C
btdsetupus:
  BCC btdsetupn
  ; else fall through to btdsetupp
btdsetupp:
  LDA #$00
  STA SRSCRATCH+6
  BEQ btdinitout
btdsetupua:
  BCC btdsetupp
  ; else fall through to btdsetupbp
btdsetupbp:
  LDA #$01
  STA SRSCRATCH+6
  BNE btdinitout
btdsetups:
  LDX NBTODEC
  LDA DWORDBUF-1,X ; get N from most significant byte
  BVC *+4 ; if V clear, skip following EOR imm
  EOR #$80 ; if V set, flip N
  BPL btdsetupp ; if resulting N is clear, treat number as positive
  ; else, fall through to btdsetupn
btdsetupn:
  LDA #$80
  STA SRSCRATCH+6
btdinitout:
  LDY #$06 ; Y is output digit index
  LDA #$00
  ; initialize decimal accumulator (digit pairs in odd-indexed bytes 7-15)
btdinitloop:
  INY
  STA TEXTBUF,Y
  INY
  CPY #$10
  BCC btdinitloop
  LDA #$20
  STA TEXTBUF+5 ; space for positive output
  LDA SRSCRATCH+6
  BPL btdinitp
  JSR dwordnegate
  LDA #$60
  STA TEXTBUF+5
btdinitp:
  ; initialize bit value
  LDA #$01
  STA SRSCRATCH+0
  LDA #$00
  STA SRSCRATCH+1
  STA SRSCRATCH+2
  STA SRSCRATCH+3
  STA SRSCRATCH+4
  LDX #$00 ; X is input byte index
  CLC
  SED
btdbyteloop:
  LDA DWORDBUF,X
  STA SRSCRATCH+7 ; can't just keep it in accumulator
  LDY #8 ; counter of bits to shift out
btdbitloop:
  LSR SRSCRATCH+7
  BCC btddblbitvalue
  ; add current bit power to accumulator
btdbigbit:
  CLC
  LDA TEXTBUF+15
  ADC SRSCRATCH+0
  STA TEXTBUF+15
  LDA TEXTBUF+13
  ADC SRSCRATCH+1
  STA TEXTBUF+13
  LDA TEXTBUF+11
  ADC SRSCRATCH+2
  STA TEXTBUF+11
  LDA TEXTBUF+9
  ADC SRSCRATCH+3
  STA TEXTBUF+9
  LDA TEXTBUF+7
  ADC SRSCRATCH+4
  STA TEXTBUF+7
  ; boldly assuming last ADC left carry clear
btddblbitvalue:
  ; double bit value
  LDA SRSCRATCH+0
  ADC SRSCRATCH+0
  STA SRSCRATCH+0
  LDA SRSCRATCH+1
  ADC SRSCRATCH+1
  STA SRSCRATCH+1
  LDA SRSCRATCH+2
  ADC SRSCRATCH+2
  STA SRSCRATCH+2
  LDA SRSCRATCH+3
  ADC SRSCRATCH+3
  STA SRSCRATCH+3
  LDA SRSCRATCH+4
  ADC SRSCRATCH+4
  STA SRSCRATCH+4
  DEY
  BNE btdbitloop
  INX
  CPX NBTODEC
  BCC btdbyteloop
  LDA SRSCRATCH+6
  AND #$01
  BEQ btddoneadding
  ; add one last high bit
  LDY #$01 ; otherwise it will try more than one extra bit
  DEC SRSCRATCH+6 ; clear bigbit flag so this process doesn't repeat
  JMP btdbigbit
btddoneadding:
  CLD
  ; unpack BCD
  LDX #15
  STX SAVEX ; will hold index of most significant nonzero digit
btdunpackloop:
  LDA TEXTBUF,X
  AND #$0F ; extract low digit
  BEQ *+4 ; if zero, skip following STX zp
  STX SAVEX
  ORA #$30 ; convert to SCE
  TAY ; hold value of low digit in Y for a jif
  LDA TEXTBUF,X ; load packed value again
  STY TEXTBUF,X ; store low digit
  DEX
  AND #$F0 ; extract high digit
  BEQ *+4 ; if zero, skip following STX zp
  STX SAVEX
  LSR A
  LSR A
  LSR A
  LSR A
  ORA #$30 ; convert to SCE
  STA TEXTBUF,X ; store high digit
  DEX
  CPX #$06
  BCS btdunpackloop ; move on to next pair of digits
  LDA SAVEX
  ORA #$F0 ; convert index of most significant nonzero digit from [6,15] to [-10,-1]
  TAX
  RTS

dwordtohex:
; Subroutine: Convert value in DWORDBUF to uppercase hexadecimal.
; Side effects: result stored in TEXTBUF[8-15], neg digit count stored in X
  LDX #$FF
  LDY #$07
  STY SRSCRATCH+2 ; randomly chosen scratch slot
dwtohexloop:
  TYA
  LSR A
  BCC dwtohexb1
  ; do this if Y is odd
  INX
  LDA DWORDBUF,X
  AND #$0F
  BPL dwtohexb2 ; BRA; N flag cleared by previous AND
dwtohexb1: ; do this if Y is even
  LDA DWORDBUF,X
  LSR A
  LSR A
  LSR A
  LSR A
dwtohexb2:
  BEQ *+4 ; skip next STY zp if nybble is zero
  STY SRSCRATCH+2
  ORA #$30 ; convert to numeric character
  CMP #$3A ; N := (A in $30-39); C := (A in $3A-3F)
  BMI *+4 ; if A < $3A, skip next ADC
  ADC #$06 ; if lo nybble > 9, convert to letter (C is set; effectively add 7)
  STA TEXTBUF+8,Y
  DEY
  BPL dwtohexloop
  LDA SRSCRATCH+2 ; most-significant nonzero nybble (0 msn, 7 lsn)
  ORA #$F8 ; F8 msn, FF lsn = negative count of nybbles
  TAX
  RTS

fvmcchar:
; Subroutine: Copy one character via FVMC (page registers already set;
; character specified by setting X register to address within page)
; Side effects: Accumulator, X register clobbered
; Acc := 0
; X := (X & $0F) + $10
fvmccharcopyloop:
  STA $00,X
  INX
  TXA
  AND #$0F
  BNE fvmccharcopyloop
  RTS

fvmcpage:
; Subroutine: Copy one full page via FVMC (registers already set)
; Side effects: Accumulator clobbered.
; Acc := X
  JSR waitvscana
  TXA
  LDX #$00
fvmcpagecopyloop:
  STA $00,X
  INX
  BNE fvmcpagecopyloop
  STX FVMCSRC
  STX FVMCDEST
  TAX
  RTS

hextodword:
  STX SAVEX
  LDX #$00
  LDA TEXTBUF+0
  CMP #$60 ; check for minus sign
  BNE *+3 ; skip next INX
  INX
  LDA #$00
  STA DWORDBUF+0
  STA DWORDBUF+1
  STA DWORDBUF+2
  STA DWORDBUF+3
hextodwloop0:
  LDA TEXTBUF,X
  BEQ hextodwexit ; stop at null byte
  LDY #$04
hextodwloop1:
  ASL DWORDBUF+0
  ROL DWORDBUF+1
  ROL DWORDBUF+2
  ROL DWORDBUF+3
  DEY
  BNE hextodwloop1
  CMP #$3A
  BCC *+4 ; skip next SBC
  SBC #$07 ; carry set this side of previous BCC, subtract 7
  AND #$0F ; extract nybble
  ORA DWORDBUF+0
  STA DWORDBUF+0
  INX
  CPX #$10
  BCC hextodwloop0
hextodwexit:
  LDA TEXTBUF+0
  CMP #$60
  BNE hextodwpositive
  ; negate DWORDBUF
  SEC
  LDX #-4
hextodwloop2:
  LDA DWORDBUF+4,X
  EOR #$FF
  ADC #$00
  STA DWORDBUF+4,X
  INX
  BNE hextodwloop2
hextodwpositive:
  LDX SAVEX
  RTS

actoncontrolcode:
; Subroutine: Act on control code designated by Y (index into control code
; table, not actual control code)
; Side effects: Accumulator clobbered, Y register doubled
  TYA
  ASL
  TAY
  LDA controlcodetargets,Y
  STA SRSCRATCH+12
  LDA controlcodetargets+1,Y
  STA SRSCRATCH+13
  JMP (SRSCRATCH+12)

printch:
; Subroutine: Print a character identified by Accumulator, at current cursor
; location. If control code, act accordingly. Else, assert selected colors at
; current cursor location and advance cursor.
; Side effects: X register clobbered.
NCONTROLCODES = 12
  STY SAVEY
  LDY CONSFLAGS
  BMI printliteral0
  LDY #$00
controlcodeloop:
  CMP controlcodes,Y
  BEQ actoncontrolcode
  INY
  CPY #NCONTROLCODES
  BCC controlcodeloop
printliteral1:
  JSR putch
  PHA
  JSR putcolors
  JSR cursoradvance
  PLA
  LDY SAVEY
  RTS

printliteral0:
  PHA
  LDA CONSFLAGS
  AND #$7F
  STA CONSFLAGS
  PLA
  JMP printliteral1

printsetupliteral:
  PHA
  LDA CONSFLAGS
  ORA #$80
  STA CONSFLAGS
  PLA
  RTS

putch:
; Subroutine: Print a character identified by Accumulator, at current cursor
; location. Do not treat control codes specially.
; Side effects: X, Y registers clobbered.
  LDY #$00
  JSR waithscanx
  STA (TCURSORLO),Y
  RTS

putcolors:
; Subroutine: Assert selected colors at current cursor location.
; Side effects: Accumulator, X, Y registers clobbered.
  LDA #$00
  STA TCBLINK ; cursor will be hidden by this procedure
  JSR calccolorbytes
  JSR coptrcalc
  JSR calcrownybble
  STA CORNMASK
  EOR #$FF
  STA COKNMASK
  LDX #$00
putcolorswriteloop:
  STX SAVEX
  LDA COBYTES,X
  AND CORNMASK
  STA COBYTES,X
  JSR waithscanx
  LDA (COSRCPTR),Y
  AND COKNMASK
  LDX SAVEX
  ORA COBYTES,X
  JSR waithscanx
  STA (COSRCPTR),Y
  JSR coptradvance
  LDX SAVEX
  INX
  CPX #$05
  BCC putcolorswriteloop
  RTS

scrolldown2:
  LDA #$00
  STA CHDESTPTR+0
  LDA #$08
  STA CHSRCPTR+1
  STA CHDESTPTR+1
  STA CHSRCPTR+3
  STA CHDESTPTR+3
  LDA #$20
  STA CHDESTPTR+2
  LDA #$60
  STA CHSRCPTR+2
  LDA #$40
  STA CHSRCPTR+0
  CLC
  LDX #$00 ; color bitplane counter (doubled)
  LDY #$0A ; color destination / source pointer hi
sd2ptrinitloop:
  STA CODESTPTR+0,X
  ADC #$20
  STA COSRCPTR+0,X
  STY CODESTPTR+1,X
  STY COSRCPTR+1,X
  INX
  INX
  INY
  CPX #$0A
  BCC sd2ptrinitloop
  LDX #$00
  LDA VIDEOSTATE
  AND #$CC
  ORA #$02
  STA WSTARGET
sd2rowloop:
  LDY #$00
  STX SAVEX
sd2colloop:
  JSR waitscanx
  LDA (CHSRCPTR+0),Y
  STA (CHDESTPTR+0),Y
  JSR waitscanx
  LDA (CHSRCPTR+2),Y
  STA (CHDESTPTR+2),Y
  JSR waitscanx
  LDA (COSRCPTR+0),Y
  STA (CODESTPTR+0),Y
  JSR waitscanx
  LDA (COSRCPTR+2),Y
  STA (CODESTPTR+2),Y
  JSR waitscanx
  LDA (COSRCPTR+4),Y
  STA (CODESTPTR+4),Y
  JSR waitscanx
  LDA (COSRCPTR+6),Y
  STA (CODESTPTR+6),Y
  JSR waitscanx
  LDA (COSRCPTR+8),Y
  STA (CODESTPTR+8),Y
  INY
  CPY #$20
  BCC sd2colloop
  CLC
  LDA CHSRCPTR+0
  STA CHDESTPTR+0
  ORA #$20
  STA CHDESTPTR+2
  ADC #$20
  STA CHSRCPTR+0
  ORA #$20
  STA CHSRCPTR+2
  LDA CHSRCPTR+1
  STA CHDESTPTR+1
  STA CHDESTPTR+3
  ADC #$00
  STA CHSRCPTR+1
  STA CHSRCPTR+3
  LDX #$00
sd2coptrloop:
  LDA COSRCPTR+0,X
  STA CODESTPTR+0,X
  ADC #$20
  STA COSRCPTR+0,X
  LDA COSRCPTR+1,X
  STA CODESTPTR+1,X
  ADC #$00
  STA COSRCPTR+1,X
  INX
  INX
  CPX #$0A
  BCC sd2coptrloop
  LDX SAVEX
  INX
  CPX #$08
  BCC sd2rowloop
  ; clear bottom 2 rows
  LDX #$00
  JSR calccolorbytes
sd2clearloop:
  LDA #$20
  JSR waithscany
  STA $0A00,X
  STA $0A20,X
  LDA COBYTES+0
  JSR waithscany
  STA $0B40,X
  LDA COBYTES+1
  JSR waithscany
  STA $0C60,X
  LDA COBYTES+2
  JSR waithscany
  STA $0D80,X
  LDA COBYTES+3
  JSR waithscany
  STA $0EA0,X
  LDA COBYTES+4
  JSR waithscany
  STA $0FC0,X
  INX
  CPX #$20
  BCC sd2clearloop
  ;SEC Carry should be already set
  LDA TCURSORLO
  SBC #$40
  STA TCURSORLO
  LDA TCURSORHI
  SBC #$00
  STA TCURSORHI
  JMP cursorbackcheck

textbackspace:
  ; do nothing if cursor is in leftmost column
  LDA TCURSORLO
  AND #$1F
  BNE *+3
  RTS
  JSR cursorleft
  ; fall through to textdelete

textdelete:
  PHA
  LDA TCURSORLO
  PHA
  AND #$1F
  TAY
  LDA TCURSORLO
  AND #$E0
  STA TCURSORLO
textdeleteshiftloop:
  INY
  CPY #$20
  BCS textdeleteshiftloopexit
  LDA (TCURSORLO),Y
  DEY
  JSR waithscanx
  STA (TCURSORLO),Y
  INY
  BNE textdeleteshiftloop ; BRA: Y is nonzero here
textdeleteshiftloopexit:
  DEY
  LDA #$20 ; put a space in last column
  JSR waithscanx
  STA (TCURSORLO),Y
  PLA ; restore cursor position
  STA TCURSORLO
  PLA ; restore Acc
  RTS

textinsert:
  PHA
  LDA TCURSORLO
  PHA
  AND #$1F
  TAY
  LDA TCURSORLO
  AND #$E0
  STA TCURSORLO
  LDA #$7F
textinsertshiftloop:
  PHA
  LDA (TCURSORLO),Y
  STA SRSCRATCH+11
  PLA
  JSR waithscanx
  STA (TCURSORLO),Y
  LDA SRSCRATCH+11
  INY
  CPY #$20
  BCS textinsertshiftloopexit
  BCC textinsertshiftloop ; BRA: carry clear this side of BCS branch
textinsertshiftloopexit:
  PLA ; restore cursor position
  STA TCURSORLO
  PLA ; restore Acc
  RTS

beep:
BEEPFREQ = 750
  ; start beep
  LDA #<BEEPFREQ
  STA SOUNDVOICE0FREQ
  LDA #>BEEPFREQ
  STA SOUNDVOICE0FREQ+1
  LDA #$AA
  STA SOUNDVOICE0VOL
  LDA #$00
  STA SOUNDVOICETYPES
  ; delay
  LDY #$15
beepdelayloop:
  JSR waitvscana
  AND #$CC
  CMP VIDEOSTATE
  BNE *-3
  DEY
  BNE beepdelayloop
  LDA #$00
  STA SOUNDVOICE0FREQ
  STA SOUNDVOICE0FREQ+1
  STA SOUNDVOICE0VOL
  RTS

cursoradvance:
  ; clear cursor if shown
  JSR cursorhide
  ; move cursor pointer
  CLC
  LDA TCURSORLO
  ADC #$01
  STA TCURSORLO
  LDA TCURSORHI
  ADC #$00
  STA TCURSORHI
  ; bounds check
cursoradvancecheck:
  CMP #$0A
  BCC cursoradvrts ; if TCURSORHI < $0A, return
  BNE cursorreset ; if TCURSORHI > $0A, we're way off
  LDA TCURSORLO
  CMP #$40
  BCC cursoradvrts ; if TCURSORLO < $40, return
  JMP scrolldown2
cursoradvrts:
  RTS

cursordown:
  ; clear cursor if shown
  JSR cursorhide
  ; move cursor pointer
  CLC
  LDA TCURSORLO
  ADC #$20
  STA TCURSORLO
  LDA TCURSORHI
  ADC #$00
  STA TCURSORHI
  ; bounds check
  JMP cursoradvancecheck

cursorhide:
  LDA TCBLINK
  AND #$10
  BNE *+3 ; if cursor in 'off' phase, return
  RTS
  LDA #$00 ; set cursor cycle to reflect 'off'
  STA TCBLINK
  JMP cursortoggle

cursorleft:
  ; clear cursor if shown
  JSR cursorhide
  ; move cursor pointer
  SEC
  LDA TCURSORLO
  SBC #$01
  STA TCURSORLO
  LDA TCURSORHI
  SBC #$00
  STA TCURSORHI
  ; bounds check
cursorbackcheck:
  CMP #$08
  BCS cursorbackrts ; if TCURSORHI >= $08, return
cursorreset:
  LDA #$00
  STA TCURSORLO
  LDA #$08
  STA TCURSORHI
cursorbackrts:
  RTS

cursorreturn:
  ; clear cursor if shown
  JSR cursorhide
  ; move cursor pointer
  LDA TCURSORLO
  AND #$E0
  STA TCURSORLO
  RTS

cursortab:
  ; clear cursor if shown
  JSR cursorhide
  ; move cursor pointer
  CLC
  LDA TCURSORLO
  ADC #$04
  AND #$FC
  STA TCURSORLO
  LDA TCURSORHI
  ADC #$00
  STA TCURSORHI
  ; bounds check
  JMP cursoradvancecheck

cursortick:
  CLC
  LDA TCBLINK
  ADC #$01
  STA TCBLINK
  AND #$0F
  BEQ *+3
  RTS
  ; fall through to cursortoggle

cursortoggle:
  JSR calcrownybble
  TAY
  LDX #$00
cursortogglesetuploop:
  TYA
  AND BLINKBITS,X
  STA COBYTES,X
  INX
  CPX #$05
  BCC cursortogglesetuploop
  JSR coptrcalc
  LDX #$00
cursortogglewriteloop:
  LDA COBYTES,X
  STX SAVEX
  JSR waithscanx
  EOR (COSRCPTR),Y
  JSR waithscanx
  STA (COSRCPTR),Y
  JSR coptradvance
  LDX SAVEX
  INX
  CPX #$05
  BCC cursortogglewriteloop
  RTS

cursorup:
  ; clear cursor if shown
  JSR cursorhide
  ; move cursor pointer
  SEC
  LDA TCURSORLO
  SBC #$20
  STA TCURSORLO
  LDA TCURSORHI
  SBC #$00
  STA TCURSORHI
  ; bounds check
  JMP cursorbackcheck

waithscanx:
; Subroutine: Wait for start of horizontal blanking interval after active
; scanline.
; Side effects: X register is clobbered in such a way as to set up for waitscanx2.
  PHA
  LDA VIDEOSTATE
  AND #$CC
  ORA #$02
  TAX
  PLA
  JMP waitscanx2

waithscany:
; Subroutine: Wait for start of horizontal blanking interval after active
; scanline.
; Side effects: Y register is clobbered.
  PHA
  LDA VIDEOSTATE
  AND #$CC
  ORA #$02
  TAY
  PLA
  CPY VIDEOSTATE
  BNE *-3
  RTS

waitscanx:
; Subroutine: Wait for videostate stored in WSTARGET.
; Side effects: X register is clobbered
  LDX WSTARGET
waitscanx2:
  CPX VIDEOSTATE
  BNE *-3
  RTS

waitvscana:
; Subroutine: Wait for start of vertical blanking interval.
; Side effects: Accumulator is clobbered.
  ; determine video flags to look for
  LDA VIDEOSTATE
  AND #$CC
  ORA #$20
  ; wait for start of vertical retrace
  CMP VIDEOSTATE
  BNE *-3 ; CMP again
  RTS

nmicode: ; empty, because NMI not presently used
  RTI

  .org $FC41
datadecompressinstc:
  .byte $C2,$18,$C1,$1F,$F2,$1D,$C0,$1C,$F1,$1E,$00
datadecompressinstw:
  .byte $C2,$18,$F1,$1B,$C1,$1F,$C3,$19,$F1,$1A,$00
datalogowblankcells:
  .byte $0C,$0D,$12,$13,$2C,$33,$CC,$D3,$EC,$ED,$F2,$F3,$00
datalogocolors:
  .byte $CC,$CC,$8A,$8C,$CE,$EE,$EC,$CC
  .byte $AC,$AE,$EE,$EC,$C8,$C8,$AA,$CA
  .byte $8C,$8C,$EE,$EC,$CA,$EA,$EE,$CE
  .byte $EA,$EA,$CC,$CA,$AE,$AE,$88,$A8
  .byte $8A,$88,$A8,$AA,$A8,$88,$CE,$AE
datasyscolors:
  .byte $00,$81,$84,$0D,$02,$83,$86,$0F
  .byte $D0,$59,$5C,$DD,$D2,$5B,$5E,$DF
  .byte $20,$A1,$A4,$2D,$22,$A3,$A6,$2F
  .byte $F0,$79,$7C,$FD,$F2,$7B,$7E,$FF
datascreendef:
  .byte $00,$01,$10,$20,$01,$00,$30,$40,$50
  .byte $09
  .byte $1F,$1F
  .byte $21,$35
  .byte $13,$41,$35
datascreenconst:
  .byte $20,$CC,$C0,$00,$0C ; screendef AND $0F != $00 (low nybble is run count, high nybble is index)
datagfx:
  .incbin firmwaregfx.compressed,0,574
datatext: .align 8
  .text ". \xFE\xFF \x80\x81 .  \x0E  \x0E  \x0E  \x0E  . \xFE\xFF \x80\x81 ." ; screendef $00
  .text "\x8F   Retro 6k Fantasy Computer  \x8F" ; screendef $10
  .text "\xFA     Entertainment System\x11    \xFA" ; screendef $20
  .text "   Please insert a cartridge>   " ; screendef $30
  .text "     F\xFB\xFC\xFDware version 2031@     " ; screendef $40
  .text "\0142019`20 Maggie David \x86\x87\x88 Haynes" ; screendef $50
initfontsrcpage:
  .byte $E4,$E5,$E6,$E7,$E3,$E2,$E1,$00
initfontdestpage:
  .byte $14,$15,$16,$17,$13,$12,$11,$00
controlcodes:
  ; CAUTION: Ensure NCONTROLCODES is defined earlier as the length of this list
  .byte $01,$04,$06,$07,$08,$09,$0A,$0C,$0D,$0E,$2C,$7F
controlcodetargets:
  .word printsetupliteral
  .word cursoradvance
  .word cursorleft
  .word beep
  .word textbackspace
  .word cursortab
  .word cursordown
  .word cursordown
  .word cursorreturn
  .word cursorup
  .word textinsert
  .word textdelete

; 6502 program counter initialization vectors
  .org $FFFA
  .word nmicode ; NMI vector, in firmware
  .word entry ; reset vector, in firmware
  .word $2010 ; interrupt request vector, in cartridge