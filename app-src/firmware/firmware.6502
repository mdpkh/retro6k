; Retro6K System Firmware
; zeropage addresses used by interactive console
CMDBUF     = $00 ; 32 bytes
INRADIX    = $20 ; 0=decimal; 1=hexadecimal
INDIRECT   = $21 ; count of @ in currently-scanning number
DESTSIZE   = $22 ; 0=byte; 1=word; 2=dword; 3=char*16; 4=zterm; 5=page
SRCSIZE    = $23 ; 0=byte; 1=word; 2=dword; 3=char*16; 4=zterm; 5=page
DESTWORD   = $24 ; destination address of memcopy command
DESTIND    = $26 ; destination indirect count
SRCDWORD   = $28 ; source address/literal of memcopy command
SRCIND     = $2C ; source indirect count

; zeropage addresses used in subroutines
TEXTBUF   = $80 ; up to 16 bytes
DWORDBUF  = $90
WORDBUF0  = $94
WORDBUF1  = $96
TCURSORLO = $98 ; bits 0-4: text cursor column; bits 5-7: text cursor row b0-2
TCURSORHI = $99 ; bits 0-1: text cursor row bits 3-4
TCBLINK   = $9A ; bits 0-4: cursor blink cycle counter
CONSFLAGS = $9B ; bit 7: print next char literally
COLORS    = $9C ; colors (4 bytes) for new characters to print
CHSRCPTR  = $A0 ; character source row pointers (4 bytes) for scrolling
CHDESTPTR = $A4 ; character destination row pointers (4 bytes) for scrolling
COSRCPTR  = $A8 ; color source row pointers (10 bytes) for scrolling
CODESTPTR = $B2 ; color destination row pointers (10 bytes) for scrolling
WSTARGET  = $BD ; VIDEOSTATE flag to wait for
COBYTES   = $C0 ; packed color bytes (5 bytes)
BLINKBITS = $C5 ; which bits to toggle for blinking cursor (5 bytes)
COKNMASK  = $CA ; keep-nybble color mask
CORNMASK  = $CB ; replace-nybble color mask
POINTER0  = $E0
POINTER1  = $E2
POINTER2  = $E4
POINTER3  = $E6
SRSCRATCH = $F0
SAVEX     = $FE
SAVEY     = $FF
; special system addresses
KBDIN           = $0244
VIDEOSTATE      = $02FC
SOUNDVOICE0FREQ = $0380
SOUNDVOICE0VOL  = $0388
SOUNDVOICETYPES = $038C
FVMCDEST        = $03F8
FVMCSRC         = $03F9
DLSOFF          = $03FC
DLSON           = $03FD
DEBUGLOG        = $03FF

  .org $F000
; firmware version signature
  .word 20310 ; 2031-development
entry: ; system power-on or reset
  ; misc initialization
  SEI
  CLD
  LDA #$00
  STA FVMCSRC
  STA FVMCDEST
  LDX #$F0
  STX DLSOFF ; turn off debug log suppression
  JSR waitvscana
  ; display cartridge identification in bottom of screen
  LDX #$00
cartidcolloop:
  LDA #$F0
  STA $0B2A,X
  STA $0C4A,X
  STA $0D6A,X
  LDA #$50
  STA $0E8A,X
  STA $0FAA,X
  LDA #$53
  STA $0B4A,X
  STA $0C6A,X
  STA $0D8A,X
  LDA #$A0
  STA $0EAA,X
  STA $0FCA,X
  LDA #$02
  STA $09EA,X
  STA $0A2A,X
  LDA $1FFF,X
  STA $0A0A,X
  INX
  CPX #$0C
  BCC cartidcolloop
  LDA #$20
  STA $0A0A
  STA $0A15
  ;initialize palette
  LDX #$00
initpalloop:  
  LDA datasyscolors,X ; palette colors
  STA $0FE0,X
  INX
  CPX #$20
  BCC initpalloop
  ; load system font (specific subset in specific order)
  LDA #$E0
  STA FVMCSRC
  LDA #$10
  STA FVMCDEST
  JSR waitvscana
  LDX #$20
  JSR fvmcchar
  LDX #$00
initfontloop:
  LDA initfontsrcpage,X
  STA FVMCSRC
  LDA initfontdestpage,X
  STA FVMCDEST
  BEQ initfontloopexit
  JSR fvmcpage
  INX
  JMP initfontloop
initfontloopexit:
  ; detect presence of valid cartridge
  ; by checking for magic bytes 47 A9 0C 1E
  LDA $200A
  CMP #$47
  BNE nocart
  LDA $200B
  CMP #$A9
  BNE nocart
  LDA $200C
  CMP #$0C
  BNE nocart
  LDA $200D
  CMP #$1E
  BNE nocart
  ; if we got this far, jump to cartridge start vector
  JMP ($200E)
nocart: ; no cartridge inserted
  ; initialize screen display
  LDA #$00
  STA POINTER0+0
  STA SAVEX
  LDA #$08
  STA POINTER0+1
  LDA #>datatext
  STA POINTER1+1
  LDA VIDEOSTATE
  AND #$CC
  ORA #$02
  STA WSTARGET
initscreenrowloop:
  LDX SAVEX
  LDA datascreendef,X
  BMI initscreenconstrow
  ASL A
  STA POINTER1+0
  LDY #$00
initscreendrloop:
  LDA (POINTER1),Y
  JSR waitscanx
  STA (POINTER0),Y
  INY
  CPY #$20
  BCC initscreendrloop
  BCS initscreenrowadvance ; BRA
initscreenconstrow:
  AND #$7F
  TAY
  LDA datascreenconst,Y
  LDY #$00
initscreencrcolloop:
  JSR waitscanx
  STA (POINTER0),Y
  INY
  CPY #$20
  BCC initscreencrcolloop
initscreenrowadvance:
  CLC
  LDA POINTER0+0
  ADC #$20
  STA POINTER0+0
  BCC 2 ; skip INC zp
  INC POINTER0+1
  LDX SAVEX
  INX
  STX SAVEX
  CPX #$3F
  BCC initscreenrowloop

  ; copy a few extra characters from Bank E font to video memory
  LDA #$10 ; destination page: screen font row 0
  STA FVMCDEST
  LDA #$EB ; source page: Bank E font row B
  STA FVMCSRC
  LDX #$C0 ; copy column C: copyright sign to position $0C
  JSR waitvscana
  JSR fvmcchar
  LDA #$EA ; source page: Bank E font row A
  STA FVMCSRC
  LDX #$E0 ; copy column E: diamond outline to position $0E
  JSR fvmcchar
  LDA #$EE ; source page: Bank E font row E
  STA FVMCSRC
  LDA #$16 ; destination page: screen font row 6
  STA FVMCDEST
  LDX #$00 ; copy column 0: en dash to position $60
  JSR fvmcchar
  LDA #$00 ; disable FVMC
  STA FVMCDEST
  STA FVMCSRC
  ; decompress and load graphics common to both aspect ratios
  LDA #<datagfx
  STA POINTER0+0
  LDA #>datagfx
  STA POINTER0+1
  LDA #$03 ; page 3 in compressed data
  JSR decompresspage
  LDA #$07
  STA FVMCSRC
  LDA #$18 ; page 8 in font memory
  STA FVMCDEST
  JSR fvmcpage
  LDA #$06 ; page 6 in compressed data
  JSR decompresspage
  LDA #$07
  STA FVMCSRC
  LDA #$1F ; page F in font memory
  STA FVMCDEST
  JSR fvmcpage
  ; check aspect ratio
  LDA VIDEOSTATE
  AND #$80
  BNE widescreenlogo
  ; logo (classic)
  JSR waitvscana
  LDX #$00
logocloop:
  TXA
  ORA #$A0 ; X+A0
  STA $096C,X
  ORA #$08 ; X+A8
  STA $098C,X
  EOR #$18 ; X+B0
  STA $09AC,X
  ORA #$08 ; X+B8
  STA $09CC,X
  EOR #$78 ; X+C0
  STA $09EC,X
  ORA #$08 ; X+C8
  STA $0A0C,X
  JSR logocommonpercolumn ; sets Acc := 0
  STA $094C,X ; use blank characters on rows 10 and 17
  STA $0A2C,X
  INX
  CPX #$08
  BCC logocloop
  LDA #$00 ; page 0 in compressed data
  JSR decompresspage
  LDA #$07
  STA FVMCSRC
  LDA #$1A ; page A in font memory
  STA FVMCDEST
  JSR fvmcpage
  LDA #$01 ; page 1 in compressed data
  JSR decompresspage
  LDA #$07
  STA FVMCSRC
  LDA #$1B ; page B in font memory
  STA FVMCDEST
  JSR fvmcpage
  LDA #$02 ; page 2 in compressed data
  JSR decompresspage
  LDA #$07
  STA FVMCSRC
  LDA #$1C ; page C in font memory
  STA FVMCDEST
  JSR fvmcpage
  JMP logocolors
widescreenlogo:  
  ; logo (wide)
  JSR waitvscana
  LDX #$00
logowloop:
  TXA
  ORA #$80 ; X+80
  STA $094C,X
  ORA #$08 ; X+88
  STA $096C,X
  EOR #$18 ; X+90
  STA $098C,X
  ORA #$08 ; X+98
  STA $09AC,X
  EOR #$78 ; X+E0
  STA $09CC,X
  ORA #$08 ; X+E8
  STA $09EC,X
  EOR #$18 ; X+F0
  STA $0A0C,X
  ORA #$08 ; X+F8
  STA $0A2C,X
  JSR logocommonpercolumn
  INX
  CPX #$08
  BCC logowloop
  ; blank out cells not used for logo
  STA $094C
  STA $094D
  STA $0952
  STA $0953
  STA $096C
  STA $0973
  STA $0A0C
  STA $0A13
  STA $0A2C
  STA $0A2D
  STA $0A32
  STA $0A33
  LDA #$04 ; page 4 in compressed data
  JSR decompresspage
  LDA #$07
  STA FVMCSRC
  LDA #$19 ; page 9 in font memory
  STA FVMCDEST
  JSR fvmcpage
  LDA #$05 ; page 5 in compressed data
  JSR decompresspage
  LDA #$07
  STA FVMCSRC
  LDA #$1E ; page E in font memory
  STA FVMCDEST
  JSR fvmcpage
logocolors:
  ; cell color overrides common to both aspect ratios
  LDX #$00
  JSR waitvscana
logocolorloop:
  LDA datalogocolors+$00,X
  STA $0B0E,X
  LDA datalogocolors+$04,X
  STA $0B2E,X
  LDA datalogocolors+$08,X
  STA $0C2E,X
  LDA datalogocolors+$0C,X
  STA $0C4E,X
  LDA datalogocolors+$10,X
  STA $0D4E,X
  LDA datalogocolors+$14,X
  STA $0D6E,X
  LDA datalogocolors+$18,X
  STA $0E6E,X
  LDA datalogocolors+$1C,X
  STA $0E8E,X
  LDA datalogocolors+$20,X
  STA $0F8E,X
  LDA datalogocolors+$24,X
  STA $0FAE,X
  INX
  CPX #$04
  BCC logocolorloop
  BCS startsysshell

logocommonpercolumn:
  LDA #$CC ; bits 0-2 on for "foreground" colors
  STA $0AEC,X
  STA $0B0C,X
  STA $0B2C,X
  STA $0B4C,X
  STA $0C0C,X
  STA $0C2C,X
  STA $0C4C,X
  STA $0C6C,X
  STA $0D2C,X
  STA $0D4C,X
  STA $0D6C,X
  STA $0D8C,X
  LDA #$AA ; bits 3-4 on for "secondary" colors
  STA $0E4C,X
  STA $0E6C,X
  STA $0E8C,X
  STA $0EAC,X
  STA $0F6C,X
  STA $0F8C,X
  STA $0FAC,X
  STA $0FCC,X
  LDA #$00 ; blank out character 00
  STA $1000,X
  STA $1008,X
  RTS

startsysshell:
  ; initialize shell state
  LDA #$20
  STA TCURSORLO
  LDA #$0A
  STA TCURSORHI
  LDA #$00
  STA TCBLINK
  STA COLORS+0
  STA COLORS+1
  LDA #$07
  STA COLORS+2
  STA COLORS+3
  LDA #$AA ; blink "secondary" colors in bitplanes 0-2 (RGB)
  STA BLINKBITS+0
  STA BLINKBITS+1
  STA BLINKBITS+2
  LDA #$CC ; blink "foreground" colors in bitplanes 3-4 (intensity)
  STA BLINKBITS+3
  STA BLINKBITS+4
readcommand:
  LDA #$1E ; ">" in SCE
  JSR printch
readcommandkeyloop:
  JSR waitvscana
  JSR cursortick
  LDA KBDIN
  BEQ readcommandkeyloop
  CMP #$0D
  BEQ processcommand
processliteralchar:
  JSR printch
  JMP readcommandkeyloop
processcommand:
  ; check if escape sequence in progress
  LDA CONSFLAGS
  BPL pcsetupcopycmd
  LDA #$0D ; replace CR that got us here, then continue as if not a CR
  BNE processliteralchar ; BRA: Z flag cleared by previous LDA
pcsetupcopycmd:
  ; read and interpret command that was entered
  ; set POINTER0 to first column of current line
  LDA TCURSORLO
  AND #$E0
  STA POINTER0+0
  LDA TCURSORHI
  STA POINTER0+1
  ; copy command line from screen memory to zp buffer
  LDY #$00
  JSR waitvscana
pccopyloop:
  LDA (POINTER0),Y
  STA CMDBUF,Y
  INY
  CPY #$20
  BCC pccopyloop
  ; now send CRLF to screen
  LDA #$0D
  JSR printch
  LDA #$0A
  JSR printch
  ; scan CMDBUF for command start indicator (">")
  LDX #$00
pcscanstartloop:
  LDA CMDBUF,X
  CMP #$20 ; leading spaces allowed
  BEQ pcscanstartnext
  CMP #$1E ; ">"
  BEQ pcscancmdnext
  BNE pcscanstarterror ; BRA else
pcscanstartnext:
  INX
  CPX #$1F ; command start indicator doesn't make sense in final column
  BCC pcscanstartloop
pcscanstarterror:
  JSR beep
  BEQ readcommand ; BRA: Z flag set by beep
pcscancmdloop:  
  LDA CMDBUF,X
  CMP #$20 ; leading spaces allowed
  BEQ pcscancmdnext
  AND #$DF ; case-insensitive comparisons follow
  CMP #"C"
  BEQ clearscreen
  CMP #"R"
  BEQ entry
  CMP #"T"
  BEQ test
  BNE pcscancmderror ; BRA else
  BEQ pcscancmdnext
pcscancmdnext:
  INX
  CPX #$20
  BCC pcscancmdloop
pcscancmderror:
  JSR beep
  BEQ readcommand ; BRA: Z flag set by beep
pcscandec:
  LDY #$00
  STY INRADIX
pcscandecloop:
  LDA CMDBUF,X
  CMP #$20 ; skip copying spaces
  BEQ pcscandecskip
  CMP #$14 ; if "$" encountered, switch to scanning for hex (and skip $)
  BEQ pcscanhexskip
  CMP #$60 ; copy if A == "-"
  BEQ pcscandeccopy
  CMP #$30 ; stop copying if A < "0"
  BCC pcscandecexit
  CMP #$3A ; stop copying if A > "9"
  BCS pcscandecexit
pcscandeccopy:
  STA TEXTBUF,Y
  INY
pcscandecskip:
  INX
  CPY #$10
  BCS pcscandecexitnonull
  CPX #$20
  BCC pcscandecloop
pcscandecexit:
  LDA #$00
  STA TEXTBUF,Y
pcscandecexitnonull:
  RTS
pcscanhex:
  LDY #$00
pcscanhexloop:
  LDA CMDBUF,X
  CMP #$20 ; skip copying spaces
  BEQ pcscanhexskip
  CMP #$14 ; skip copying "$"s
  BEQ pcscanhexskip
  CMP #$30 ; stop copying if A < "0"
  BCC pcscanhexexit
  CMP #$67 ; stop copying if A > "f"
  BCS pcscanhexexit
  CMP #$3A ; copy if A <= "9"
  BCC pcscanhexcopy
  CMP #$60 ; copy if A >= "-"
  BCS pcscanhexcopy
  CMP #$41 ; stop copying if A < "A"
  BCC pcscanhexexit
  CMP #$47 ; stop copying if A > "F"
  BCS pcscanhexexit
pcscanhexcopy:
  STA TEXTBUF,Y
  INY
pcscanhexskip:
  INX
  CPY #$10
  BCS pcscanhexexitnonull
  CPX #$20
  BCC pcscanhexloop
pcscanhexexit:
  LDA #$00
  STA TEXTBUF,Y
pcscanhexexitnonull:
  LDA #$01
  STA INRADIX
  RTS

test:
  INX
  JSR pcscandec
  LDA INRADIX
  BNE 6 ; skip JSR and JMP
  JSR dectodword
  JMP testaftertodw
  JSR hextodword
testaftertodw:
  JSR dwordtohex
  LDA TCURSORLO
  ORA #$08
  STA TCURSORLO
  JSR waitvscana
  TXA
  EOR #$FF
  CLC
  ADC #$31
  LDY #$00
  STA (TCURSORLO),Y
  LDA TCURSORLO
  ORA #$10
  STA TCURSORLO
testdwtohexloop:
  LDA TEXTBUF+8,Y
  STA (TCURSORLO),Y
  INY
  CPY #$08
  BCC testdwtohexloop
  LDA #$0D
  JSR printch
  LDA #$0A
  JSR printch
  JMP readcommand

calccolorbytes:
; Subroutine: Transpose color selections from COLORS[0-3] to COLORBYTES[0-4]
  PHA
  TXA
  PHA
  TYA
  PHA
  LDY #$00
calccolorloopy:
  LDA COLORS,Y
  LDX #$00
calccolorloopx:
  LSR A
  ROR COBYTES,X
  INX
  CPX #$05
  BCC calccolorloopx
  INY
  CPY #$04
  BCC calccolorloopy
  LDX #$00
calccolorloopz:
  LDA COBYTES,X
  AND #$F0
  STA COBYTES,X
  LSR A
  LSR A
  LSR A
  LSR A
  ORA COBYTES,X
  STA COBYTES,X
  INX
  CPX #$05
  BCC calccolorloopz
  PLA
  TAY
  PLA
  TAX
  PLA
  RTS

calcrownybble:
  LDA TCURSORLO
  AND #$20
  BEQ 2
  LDA #$FF ; Acc now #$00 for even row or #$FF for odd row
  EOR #$0F ; Acc now #$0F for even row or #$F0 for odd row
  RTS

clearscreen:
  JSR calccolorbytes
  LDX #$00
clearscreenloop0:
  JSR waitvscana
;  STA DEBUGLOG
clearscreenloop1:
  LDA #$20
  STA $0800,X
  STA $0900,X
  CPX #$40
  BCC 2 ; skip next if X < $40
  LDA COBYTES+0
  STA $0A00,X
  LDA COBYTES+0
  CPX #$60
  BCC 2 ; skip next if X < $60
  LDA COBYTES+1
  STA $0B00,X
  LDA COBYTES+1
  CPX #$80
  BCC 2 ; skip next if X < $80
  LDA COBYTES+2
  STA $0C00,X
  LDA COBYTES+2
  CPX #$A0
  BCC 2 ; skip next if X < $A0
  LDA COBYTES+3
  STA $0D00,X
  LDA COBYTES+3
  CPX #$C0
  BCC 2 ; skip next if X < $C0
  LDA COBYTES+4
  STA $0E00,X
  LDA COBYTES+4
  CPX #$E0
  BCS 3 ; skip next if X >= $E0
  STA $0F00,X
  INX
  BEQ clearscreenfinish
  TXA
  AND #$0F
  BEQ clearscreenloop0
  BNE clearscreenloop1
clearscreenfinish:
  LDA #$00
  STA TCURSORLO
  STA TCBLINK
  LDA #$08
  STA TCURSORHI
  JMP readcommand

coptradvance:
  CLC
  LDA COSRCPTR+0
  ADC #$20
  STA COSRCPTR+0
  LDA COSRCPTR+1
  ADC #$01
  STA COSRCPTR+1
  RTS

coptrcalc:
  LDA TCURSORLO
  AND #$1F
  TAY
  LDA TCURSORLO
  AND #$C0
  STA COSRCPTR+0
  LDA TCURSORHI
  LSR A ; now #$04 or #$05
  STA COSRCPTR+1
  LDA COSRCPTR+0
  ROR A ; bit shifted out is zero, so carry is now clear
  ADC #$40
  STA COSRCPTR+0
  LDA COSRCPTR+1
  ADC #$06 ; should not cause a carry
  STA COSRCPTR+1
  RTS

decompresspage:
; Subroutine: Load page number Acc from compressed data beginning at POINTER0
; and store the decompressed data in page 07
; Side effects: Acc, X, Y, POINTER1, POINTER2 clobbered
  ; get starting address of requested page
CDATASTART     = POINTER0
DECODELEN      = SRSCRATCH+0 ; not needed?
READHEADBYTE   = POINTER1
READHEADNYBBLE = SRSCRATCH+1
WRITEHEADBYTE  = POINTER2
WRITEHEADCRUMB = SRSCRATCH+2
RUNLENCRUMBS   = SRSCRATCH+3
RUNLENBYTES    = SRSCRATCH+4
RUNDIGIT       = SRSCRATCH+5
RUNVAL         = SRSCRATCH+6
NEWRUNVAL      = SRSCRATCH+7
READBYTEBUF    = SRSCRATCH+8
WRITEBYTEBUF   = SRSCRATCH+9
READNYBBLEBUF  = SRSCRATCH+10 ; not needed?
WRITECRUMBBUF  = SRSCRATCH+11 ; not needed?
  ; get starting address of requested page
  ; (CDATASTART),Y + CDATASTART
  ASL A
  TAY
  CLC
  LDA (CDATASTART),Y
  ADC CDATASTART+0
  STA READHEADBYTE+0
  INY
  LDA (CDATASTART),Y
  ADC CDATASTART+1
  STA READHEADBYTE+1
  LDA #$00
  STA READHEADNYBBLE
  STA WRITEHEADBYTE
  STA WRITEHEADCRUMB
  STA WRITEBYTEBUF
  LDA #$07
  STA WRITEHEADBYTE+1
  LDA #$FF
  STA RUNVAL
  LDA #$00
  STA RUNLENBYTES
  STA RUNLENCRUMBS
  LDY #$00 ; because there are no unindexed indirect load/store opcodes
  ; read one nybble
dcpreadnybble:
  LDA READHEADNYBBLE
  BNE dcpreadnybbleelse
  ; low nybble; fetch byte
  LDA #$01 ; next time, read saved high nybble
  STA READHEADNYBBLE
  LDA (READHEADBYTE),Y
  STA READBYTEBUF
  INC READHEADBYTE
  BNE 2 ; skip next INC if nonzero
  INC READHEADBYTE+1 ; if low byte zero, increment high byte
  ; extract low nybble (Acc still holds just-read byte)
  AND #$0F
  BPL dcpreadnybbleendif ; BRA: negative flag cleared by AND
dcpreadnybbleelse:
  ; extract high nybble from stored byte value
  LDA #$00 ; next time, read low nybble from fresh byte
  STA READHEADNYBBLE
  LDA READBYTEBUF
  LSR A
  LSR A
  LSR A
  LSR A
dcpreadnybbleendif:
  ; just-read nybble in Acc
  ; separate to NEWRUNVAL and RUNDIGIT
  TAX
  AND #$03
  STA NEWRUNVAL
  TXA
  LSR A
  LSR A
  BNE 2 ; skip next LDA if nonzero
  LDA #$04 ; replace 0 digit with 4
  STA RUNDIGIT
  ; is this a continuation of a run spec in progress?
  LDA NEWRUNVAL
  CMP RUNVAL
  BNE dcpwriterun
  ; add new digit to run length
  LDA RUNLENBYTES
  ; it's possible we read past the end of compressed data and found a
  ; matching run spec nybble by chance. a too-long last run isn't a problem,
  ; because we won't write past a page boundary, but we need a stop condition
  ; for reading garbage as a run spec. If computed run length meets or
  ; exceeds maximum (256 bytes), just stop reading and write the run.
  ASL A
  BCS dcprunlenoverflow
  ASL A
  BCS dcprunlenoverflow
  ADC RUNLENCRUMBS
  BCS dcprunlenoverflow
  STA RUNLENBYTES
  LDA RUNDIGIT
  STA RUNLENCRUMBS
  ; read another nybble
  JMP dcpreadnybble
dcprunlenoverflow:
  LDA #$04
  STA RUNLENCRUMBS
  LDA #$FF
  STA RUNLENBYTES ; 256 bytes is represented as 255 bytes and 4 crumbs
  ; fall through to write run
dcpwriterun:
  ; check if run length has reached zero
  ; this contition is evaluated at the top of the loop because reading the
  ; first nybble counts as non-matching and therefore triggers writing a
  ; zero-length run
  LDA RUNLENCRUMBS
  BNE dcpwriterunskip1
  LDA RUNLENBYTES
  BEQ dcpwriterundone
dcpwriterunskip1:
  ; output a crumb: shift RUNVAL into high bits of WRITEBYTEBUF
  ; (earlier output crumbs get shifted lower)
  LDA RUNVAL
  LSR A
  ROR WRITEBYTEBUF
  LSR A
  ROR WRITEBYTEBUF
  ; advance write head by one crumb
  LDA WRITEHEADCRUMB
  ADC #$01 ; if WRITEBYTEBUF was not already full, carry is clear
  CMP #$04
  BCC dcpwriterunskip2 ; do the following if WRITEBYTEBUF is full
  ; write byte from buffer
  LDA WRITEBYTEBUF
  STA (WRITEHEADBYTE),Y
  INC WRITEHEADBYTE
  BNE 1 ; if nonzero, skip next RTS
  RTS ; if zero, page is full, decompression is done
  ; INC DECODELEN ; not needed?
  LDA #$00 ; reset WRITEBYTEBUF and WRITEHEADCRUMB
  STA WRITEBYTEBUF
dcpwriterunskip2:
  STA WRITEHEADCRUMB
  ; decrement run length
  DEC RUNLENCRUMBS
  BPL dcpwriterun ; if RUNLENCRUMBS wraps around to >=128, perform borrow
  ; from RUNLENBYTES below; otherwise, continue writing run above.
  DEC RUNLENBYTES
  LDA #$03
  STA RUNLENCRUMBS
  BNE dcpwriterun ; BRA: zero flag cleared by LDA above
dcpwriterundone:
  ; now we need to retrieve the nonmatching nybble that triggered the run to
  ; be written, and set it up as the runspec in progress
  LDA NEWRUNVAL
  STA RUNVAL
  LDA RUNDIGIT
  STA RUNLENCRUMBS
  ; RUNLENBYTES should still be 0 at this point
  JMP dcpreadnybble ; this could be BNE as BRA because RUNDIGIT is always
  ; nonzero, but it seems to be too far for a branch to jump

dectodword:
  LDX #$00
  LDA TEXTBUF+0
  CMP #$60 ; check for minus sign
  BNE 1 ; skip next INX
  INX
  LDA #$00
  STA DWORDBUF+0
  STA DWORDBUF+1
  STA DWORDBUF+2
  STA DWORDBUF+3
dectodwloop0:
  LDA TEXTBUF,X
  BEQ dectodwexit ; stop at null byte
  ; multiply DWORDBUF by 10
  JSR dwordmul2
  STX SAVEX
  LDX #-4
dectodwloop3:
  LDA DWORDBUF+4,X
  STA SRSCRATCH+8,X
  INX
  BNE dectodwloop3
  JSR dwordmul2
  JSR dwordmul2
  CLC
  LDX #-4
dectodwloop4:
  LDA SRSCRATCH+8,X
  ADC DWORDBUF+4,X
  STA DWORDBUF+4,X
  INX
  BNE dectodwloop4
  LDX SAVEX
  ; add new digit
  LDA TEXTBUF,X
  AND #$0F
  CLC
  ADC DWORDBUF+0
  STA DWORDBUF+0
  STX SAVEX
  LDX #-3
dectodwloop1:
  LDA DWORDBUF+4,X
  ADC #$00
  STA DWORDBUF+4,X
  INX
  BNE dectodwloop1
  LDX SAVEX
  INX
  CPX #$10
  BCC dectodwloop0
dectodwexit:
  LDA TEXTBUF+0
  CMP #$60
  BNE dectodwpositive
  ; negate DWORDBUF
  SEC
  LDX #-4
dectodwloop2:
  LDA DWORDBUF+4,X
  EOR #$FF
  ADC #$00
  STA DWORDBUF+4,X
  INX
  BNE dectodwloop2
dectodwpositive:
  RTS

dwordmul2:
  ASL DWORDBUF+0
  ROL DWORDBUF+1
  ROL DWORDBUF+2
  ROL DWORDBUF+3
  RTS

dwordtohex:
; Subroutine: Convert value in DWORDBUF to uppercase hexadecimal.
; Side effects: result stored in TEXTBUF[8-15], neg digit count stored in X
  LDX #$FF
  LDY #$07
  STY SRSCRATCH+2 ; randomly chosen scratch slot
dwtohexloop:
  TYA
  LSR A
  BCC dwtohexb1
  ; do this if Y is odd
  INX
  LDA DWORDBUF,X
  AND #$0F
  BPL dwtohexb2 ; BRA; N flag cleared by previous AND
dwtohexb1: ; do this if Y is even
  LDA DWORDBUF,X
  LSR A
  LSR A
  LSR A
  LSR A
dwtohexb2:
  BEQ 2 ; skip next STY zp if nybble is zero
  STY SRSCRATCH+2
  ORA #$30 ; convert to numeric character
  CMP #$3A ; N := (A in $30-39); C := (A in $3A-3F)
  BMI 2 ; if A < $3A, skip next ADC
  ADC #$06 ; if lo nybble > 9, convert to letter (C is set; effectively add 7)
  STA TEXTBUF+8,Y
  DEY
  BPL dwtohexloop
  LDA SRSCRATCH+2 ; most-significant nonzero nybble (0 msn, 7 lsn)
  ORA #$F8 ; F8 msn, FF lsn = negative count of nybbles
  TAX
  RTS

fvmcchar:
; Subroutine: Copy one character via FVMC (page registers already set;
; character specified by setting X register to address within page)
; Side effects: Accumulator, X register clobbered
; Acc := 0
; X := (X & $0F) + $10
fvmccharcopyloop:
  STA $00,X
  INX
  TXA
  AND #$0F
  BNE fvmccharcopyloop
  RTS

fvmcpage:
; Subroutine: Copy one full page via FVMC (registers already set)
; Side effects: Accumulator clobbered.
; Acc := X
  JSR waitvscana
  TXA
  LDX #$00
fvmcpagecopyloop:
  STA $00,X
  INX
  BNE fvmcpagecopyloop
  STX FVMCSRC
  STX FVMCDEST
  TAX
  RTS

hextodword:
  LDX #$00
  LDA TEXTBUF+0
  CMP #$60 ; check for minus sign
  BNE 1 ; skip next INX
  INX
  LDA #$00
  STA DWORDBUF+0
  STA DWORDBUF+1
  STA DWORDBUF+2
  STA DWORDBUF+3
hextodwloop0:
  LDA TEXTBUF,X
  BEQ hextodwexit ; stop at null byte
  LDY #$04
hextodwloop1:
  ASL DWORDBUF+0
  ROL DWORDBUF+1
  ROL DWORDBUF+2
  ROL DWORDBUF+3
  DEY
  BNE hextodwloop1
  CMP #$3A
  BCC 2 ; skip next SBC
  SBC #$07 ; carry set this side of previous BCC, subtract 7
  AND #$0F ; extract nybble
  ORA DWORDBUF+0
  STA DWORDBUF+0
  INX
  CPX #$10
  BCC hextodwloop0
hextodwexit:
  LDA TEXTBUF+0
  CMP #$60
  BNE hextodwpositive
  ; negate DWORDBUF
  SEC
  LDX #-4
hextodwloop2:
  LDA DWORDBUF+4,X
  EOR #$FF
  ADC #$00
  STA DWORDBUF+4,X
  INX
  BNE hextodwloop2
hextodwpositive:
  RTS

actoncontrolcode:
; Subroutine: Act on control code designated by Y (index into control code
; table, not actual control code)
; Side effects: Accumulator clobbered, Y register doubled
  TYA
  ASL
  TAY
  LDA controlcodetargets,Y
  STA SRSCRATCH+12
  LDA controlcodetargets+1,Y
  STA SRSCRATCH+13
  JMP (SRSCRATCH+12)

printch:
; Subroutine: Print a character identified by Accumulator, at current cursor
; location. If control code, act accordingly. Else, assert selected colors at
; current cursor location and advance cursor.
; Side effects: Y register clobbered.
NCONTROLCODES = 12
  LDY CONSFLAGS
  BMI printliteral0
  LDY #$00
controlcodeloop:
  CMP controlcodes,Y
  BEQ actoncontrolcode
  INY
  CPY #NCONTROLCODES
  BCC controlcodeloop
printliteral1:
  JSR putch
  PHA
  JSR putcolors
  JSR cursoradvance
  PLA
  RTS

printliteral0:
  PHA
  LDA CONSFLAGS
  AND #$7F
  STA CONSFLAGS
  PLA
  JMP printliteral1

printsetupliteral:
  PHA
  LDA CONSFLAGS
  ORA #$80
  STA CONSFLAGS
  PLA
  RTS

putch:
; Subroutine: Print a character identified by Accumulator, at current cursor
; location. Do not treat control codes specially.
; Side effects: X, Y registers clobbered.
  LDY #$00
  JSR waithscanx
  STA (TCURSORLO),Y
  RTS

putcolors:
; Subroutine: Assert selected colors at current cursor location.
; Side effects: Accumulator, X, Y registers clobbered.
  LDA #$00
  STA TCBLINK ; cursor will be hidden by this procedure
  JSR calccolorbytes
  JSR coptrcalc
  JSR calcrownybble
  STA CORNMASK
  EOR #$FF
  STA COKNMASK
  LDX #$00
putcolorswriteloop:
  STX SAVEX
  LDA COBYTES,X
  AND CORNMASK
  STA COBYTES,X
  JSR waithscanx
  LDA (COSRCPTR),Y
  AND COKNMASK
  LDX SAVEX
  ORA COBYTES,X
  JSR waithscanx
  STA (COSRCPTR),Y
  JSR coptradvance
  LDX SAVEX
  INX
  CPX #$05
  BCC putcolorswriteloop
  RTS

scrolldown2:
  LDA #$00
  STA CHDESTPTR+0
  LDA #$08
  STA CHSRCPTR+1
  STA CHDESTPTR+1
  STA CHSRCPTR+3
  STA CHDESTPTR+3
  LDA #$20
  STA CHDESTPTR+2
  LDA #$60
  STA CHSRCPTR+2
  LDA #$40
  STA CHSRCPTR+0
  CLC
  LDX #$00 ; color bitplane counter (doubled)
  LDY #$0A ; color destination / source pointer hi
sd2ptrinitloop:
  STA CODESTPTR+0,X
  ADC #$20
  STA COSRCPTR+0,X
  STY CODESTPTR+1,X
  STY COSRCPTR+1,X
  INX
  INX
  INY
  CPX #$0A
  BCC sd2ptrinitloop
  LDX #$00
  LDA VIDEOSTATE
  AND #$CC
  ORA #$02
  STA WSTARGET
sd2rowloop:
  LDY #$00
  STX SAVEX
sd2colloop:
  JSR waitscanx
  LDA (CHSRCPTR+0),Y
  STA (CHDESTPTR+0),Y
  JSR waitscanx
  LDA (CHSRCPTR+2),Y
  STA (CHDESTPTR+2),Y
  JSR waitscanx
  LDA (COSRCPTR+0),Y
  STA (CODESTPTR+0),Y
  JSR waitscanx
  LDA (COSRCPTR+2),Y
  STA (CODESTPTR+2),Y
  JSR waitscanx
  LDA (COSRCPTR+4),Y
  STA (CODESTPTR+4),Y
  JSR waitscanx
  LDA (COSRCPTR+6),Y
  STA (CODESTPTR+6),Y
  JSR waitscanx
  LDA (COSRCPTR+8),Y
  STA (CODESTPTR+8),Y
  INY
  CPY #$20
  BCC sd2colloop
  CLC
  LDA CHSRCPTR+0
  STA CHDESTPTR+0
  ORA #$20
  STA CHDESTPTR+2
  ADC #$20
  STA CHSRCPTR+0
  ORA #$20
  STA CHSRCPTR+2
  LDA CHSRCPTR+1
  STA CHDESTPTR+1
  STA CHDESTPTR+3
  ADC #$00
  STA CHSRCPTR+1
  STA CHSRCPTR+3
  LDX #$00
sd2coptrloop:
  LDA COSRCPTR+0,X
  STA CODESTPTR+0,X
  ADC #$20
  STA COSRCPTR+0,X
  LDA COSRCPTR+1,X
  STA CODESTPTR+1,X
  ADC #$00
  STA COSRCPTR+1,X
  INX
  INX
  CPX #$0A
  BCC sd2coptrloop
  LDX SAVEX
  INX
  CPX #$08
  BCC sd2rowloop
  ; clear bottom 2 rows
  LDX #$00
  JSR calccolorbytes
sd2clearloop:
  LDA #$20
  JSR waithscany
  STA $0A00,X
  STA $0A20,X
  LDA COBYTES+0
  JSR waithscany
  STA $0B40,X
  LDA COBYTES+1
  JSR waithscany
  STA $0C60,X
  LDA COBYTES+2
  JSR waithscany
  STA $0D80,X
  LDA COBYTES+3
  JSR waithscany
  STA $0EA0,X
  LDA COBYTES+4
  JSR waithscany
  STA $0FC0,X
  INX
  CPX #$20
  BCC sd2clearloop
  ;SEC Carry should be already set
  LDA TCURSORLO
  SBC #$40
  STA TCURSORLO
  LDA TCURSORHI
  SBC #$00
  STA TCURSORHI
  JMP cursorbackcheck

textbackspace:
  ; do nothing if cursor is in leftmost column
  LDA TCURSORLO
  AND #$1F
  BNE 1
  RTS
  JSR cursorleft
  ; fall through to textdelete

textdelete:
  PHA
  LDA TCURSORLO
  PHA
  AND #$1F
  TAY
  LDA TCURSORLO
  AND #$E0
  STA TCURSORLO
textdeleteshiftloop:
  INY
  CPY #$20
  BCS textdeleteshiftloopexit
  LDA (TCURSORLO),Y
  DEY
  STA (TCURSORLO),Y
  INY
  BNE textdeleteshiftloop ; BRA: Y is nonzero here
textdeleteshiftloopexit:
  DEY
  LDA #$20 ; put a space in last column
  STA (TCURSORLO),Y
  PLA ; restore cursor position
  STA TCURSORLO
  PLA ; restore Acc
  RTS

textinsert:
  PHA
  LDA TCURSORLO
  PHA
  AND #$1F
  TAY
  LDA TCURSORLO
  AND #$E0
  STA TCURSORLO
textinsertshiftloop:
  LDA (TCURSORLO),Y
  INY
  CPY #$20
  BCS textinsertshiftloopexit
  STA (TCURSORLO),Y
  BCC textinsertshiftloop ; BRA: carry clear this side of BCS branch
textinsertshiftloopexit:
  PLA ; restore cursor position
  STA TCURSORLO
  LDY #$00
  LDA #$20 ; put a space in current column
  STA (TCURSORLO),Y
  PLA ; restore Acc
  RTS

beep:
BEEPFREQ = 750
  ; start beep
  LDA #<BEEPFREQ
  STA SOUNDVOICE0FREQ
  LDA #>BEEPFREQ
  STA SOUNDVOICE0FREQ+1
  LDA #$AA
  STA SOUNDVOICE0VOL
  LDA #$00
  STA SOUNDVOICETYPES
  ; delay
  LDY #$15
beepdelayloop:
  JSR waitvscana
  AND #$CC
  CMP VIDEOSTATE
  BNE -5
  DEY
  BNE beepdelayloop
  LDA #$00
  STA SOUNDVOICE0FREQ
  STA SOUNDVOICE0FREQ+1
  STA SOUNDVOICE0VOL
  RTS

cursoradvance:
  ; clear cursor if shown
  JSR cursorhide
  ; move cursor pointer
  CLC
  LDA TCURSORLO
  ADC #$01
  STA TCURSORLO
  LDA TCURSORHI
  ADC #$00
  STA TCURSORHI
  ; bounds check
cursoradvancecheck:
  CMP #$0A
  BCC cursoradvrts ; if TCURSORHI < $0A, return
  LDA TCURSORLO
  CMP #$40
  BCC cursoradvrts ; if TCURSORLO < $20, return
  JMP scrolldown2
cursoradvrts:
  RTS

cursordown:
  ; clear cursor if shown
  JSR cursorhide
  ; move cursor pointer
  CLC
  LDA TCURSORLO
  ADC #$20
  STA TCURSORLO
  LDA TCURSORHI
  ADC #$00
  STA TCURSORHI
  ; bounds check
  JMP cursoradvancecheck

cursorhide:
  LDA TCBLINK
  AND #$10
  BNE 1 ; if cursor in 'off' phase, return
  RTS
  LDA #$00 ; set cursor cycle to reflect 'off'
  STA TCBLINK
  JMP cursortoggle

cursorleft:
  ; clear cursor if shown
  JSR cursorhide
  ; move cursor pointer
  SEC
  LDA TCURSORLO
  SBC #$01
  STA TCURSORLO
  LDA TCURSORHI
  SBC #$00
  STA TCURSORHI
  ; bounds check
cursorbackcheck:
  CMP #$08
  BCS cursorbackrts ; if TCURSORHI >= $08, return
  LDA #$00
  STA TCURSORLO
  LDA #$08
  STA TCURSORHI
cursorbackrts:
  RTS

cursorreturn:
  ; clear cursor if shown
  JSR cursorhide
  ; move cursor pointer
  LDA TCURSORLO
  AND #$E0
  STA TCURSORLO
  RTS

cursortab:
  ; clear cursor if shown
  JSR cursorhide
  ; move cursor pointer
  CLC
  LDA TCURSORLO
  ADC #$04
  AND #$FC
  STA TCURSORLO
  LDA TCURSORHI
  ADC #$00
  STA TCURSORHI
  ; bounds check
  JMP cursoradvancecheck

cursortick:
  CLC
  LDA TCBLINK
  ADC #$01
  STA TCBLINK
  AND #$0F
  BEQ 1
  RTS
  ; fall through to cursortoggle

cursortoggle:
  JSR calcrownybble
  TAY
  LDX #$00
cursortogglesetuploop:
  TYA
  AND BLINKBITS,X
  STA COBYTES,X
  INX
  CPX #$05
  BCC cursortogglesetuploop
  JSR coptrcalc
  LDX #$00
cursortogglewriteloop:
  LDA COBYTES,X
  STX SAVEX
  JSR waithscanx
  EOR (COSRCPTR),Y
  JSR waithscanx
  STA (COSRCPTR),Y
  JSR coptradvance
  LDX SAVEX
  INX
  CPX #$05
  BCC cursortogglewriteloop
  RTS

cursorup:
  ; clear cursor if shown
  JSR cursorhide
  ; move cursor pointer
  SEC
  LDA TCURSORLO
  SBC #$20
  STA TCURSORLO
  LDA TCURSORHI
  SBC #$00
  STA TCURSORHI
  ; bounds check
  JMP cursorbackcheck

waithscanx:
; Subroutine: Wait for start of horizontal blanking interval after active
; scanline.
; Side effects: X register is clobbered.
  PHA
  LDA VIDEOSTATE
  AND #$CC
  ORA #$02
  TAX
  PLA
  CPX VIDEOSTATE
  BNE -5
  RTS

waithscany:
; Subroutine: Wait for start of horizontal blanking interval after active
; scanline.
; Side effects: Y register is clobbered.
  PHA
  LDA VIDEOSTATE
  AND #$CC
  ORA #$02
  TAY
  PLA
  CPY VIDEOSTATE
  BNE -5
  RTS

waitscanx:
; Subroutine: Wait for videostate stored in WSTARGET.
; Side effects: X register is clobbered
  LDX WSTARGET
  CPX VIDEOSTATE
  BNE -5
  RTS

waitvscana:
; Subroutine: Wait for start of vertical blanking interval.
; Side effects: Accumulator is clobbered.
  ; determine video flags to look for
  LDA VIDEOSTATE
  AND #$CC
  ORA #$20
  ; wait for start of vertical retrace
  CMP VIDEOSTATE
  BNE -5 ; CMP again
  RTS

nmicode: ; empty, because NMI not presently used
  RTI

  .org $FA40
datagfx:
  .incbin firmwaregfx.compressed
datascreenconst:
  .byte $20,$CC,$C0,$00,$0C ; screendef $80-$84
datalogocolors: .align 3
  .byte $CC,$CC,$8A,$8C,$CE,$EE,$EC,$CC
  .byte $AC,$AE,$EE,$EC,$C8,$C8,$AA,$CA
  .byte $8C,$8C,$EE,$EC,$CA,$EA,$EE,$CE
  .byte $EA,$EA,$CC,$CA,$AE,$AE,$88,$A8
  .byte $8A,$88,$A8,$AA,$A8,$88,$CE,$AE
datasyscolors: .align 5
  .byte $00,$81,$84,$0D,$02,$83,$86,$0F
  .byte $D0,$59,$5C,$DD,$D2,$5B,$5E,$DF
  .byte $20,$A1,$A4,$2D,$22,$A3,$A6,$2F
  .byte $F0,$79,$7C,$FD,$F2,$7B,$7E,$FF
datascreendef: .align 6
  .byte $00,$80,$10,$20,$80,$00,$30,$40
  .byte $50,$80,$80,$80,$80,$80,$80,$80
  .byte $80,$80,$81,$81,$81,$81,$81,$81
  .byte $81,$81,$81,$81,$81,$81,$81,$81
  .byte $81,$81,$81,$81,$81,$81,$81,$81
  .byte $81,$81,$81,$81,$81,$81,$81,$81
  .byte $82,$83,$83,$83,$83,$83,$81,$81
  .byte $81,$84,$83,$83,$83,$83,$83
datatext: .align 8
  .text ". \xFE\xFF \x80\x81 .  \x0E  \x0E  \x0E  \x0E  . \xFE\xFF \x80\x81 ." ; screendef $00
  .text "\x8F   Retro 6k Fantasy Computer  \x8F" ; screendef $10
  .text "\xF0     Entertainment System\x11    \xF0" ; screendef $20
  .text "   Please insert a cartridge>   " ; screendef $30
  .text "     F\xF7\xF8\xF9ware version 2031@     " ; screendef $40
  .text "\0142019`20 Maggie David \x86\x87\x88 Haynes" ; screendef $50
initfontsrcpage:
  .byte $E4,$E5,$E6,$E7,$E3,$E2,$E1,$00
initfontdestpage:
  .byte $14,$15,$16,$17,$13,$12,$11,$00
controlcodes:
  ; CAUTION: Ensure NCONTROLCODES is defined earlier as the length of this list
  .byte $01,$04,$06,$07,$08,$09,$0A,$0C,$0D,$0E,$2C,$7F
controlcodetargets:
  .word printsetupliteral
  .word cursoradvance
  .word cursorleft
  .word beep
  .word textbackspace
  .word cursortab
  .word cursordown
  .word cursordown
  .word cursorreturn
  .word cursorup
  .word textinsert
  .word textdelete

; 6502 program counter initialization vectors
  .org $FFFA
  .word nmicode ; NMI vector, in firmware
  .word entry ; reset vector, in firmware
  .word $2010 ; interrupt request vector, in cartridge