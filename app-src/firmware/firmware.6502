; Retro6K System Firmware
; zeropage addresses used in subroutines
POINTER0  = $E0
POINTER1  = $E2
POINTER2  = $E4
POINTER3  = $E6
SRSCRATCH = $F0
; special system addresses
VIDEOSTATE = $02FC
FVMCDEST   = $03F8
FVMCSRC    = $03F9
DLSOFF     = $03FC
DLSON      = $03FD
DEBUGLOG   = $03FF
; code starts here
  .org $F000
entry: ; system power-on or reset
  ; misc initialization
  SEI
  CLD
  LDA #$00
  STA FVMCSRC
  STA FVMCDEST
  ;LDX #$F0
  ;STX DLSOFF ; turn off debug log suppression
  ;INX
  ;BNE -6 ; STX again
  ;LDX #>waitvscana
  ;STX DLSON ; but seriously, suppress logging of waitvscana
  JSR waitvscana
  ; display cartridge identification in bottom of screen
  LDX #$00
cartidcolloop:
  LDA #$F0
  STA $0B2A,X
  STA $0C4A,X
  STA $0D6A,X
  LDA #$50
  STA $0E8A,X
  STA $0FAA,X
  LDA #$53
  STA $0B4A,X
  STA $0C6A,X
  STA $0D8A,X
  LDA #$A0
  STA $0EAA,X
  STA $0FCA,X
  LDA #$02
  STA $09EA,X
  STA $0A2A,X
  LDA $1FFF,X
  STA $0A0A,X
  INX
  CPX #$0C
  BCC cartidcolloop
  LDA #$20
  STA $0A0A
  STA $0A15
  ;initialize palette
  LDX #$00
initpalloop:  
  LDA datasyscolors,X ; palette colors
  STA $0FE0,X
  INX
  CPX #$20
  BCC initpalloop
  ; load system font (specific subset in specific order)
  LDA #$E0
  STA FVMCSRC
  LDA #$10
  STA FVMCDEST
  JSR waitvscana
  LDX #$20
  JSR fvmcchar
  LDX #$00
initfontloop:
  LDA initfontsrcpage,X
  STA FVMCSRC
  LDA initfontdestpage,X
  STA FVMCDEST
  BEQ initfontloopexit
  JSR fvmcpage
  INX
  JMP initfontloop
initfontloopexit:
  ; detect presence of valid cartridge
  ; by checking for magic bytes 47 A9 0C 1E
  LDA $200A
  CMP #$47
  BNE nocart
  LDA $200B
  CMP #$A9
  BNE nocart
  LDA $200C
  CMP #$0C
  BNE nocart
  LDA $200D
  CMP #$1E
  BNE nocart
  ; if we got this far, jump to cartridge start vector
  JMP ($200E)
nocart: ; no cartridge inserted
  ; initialize screen display
  JSR waitvscana
  LDX #$00
initscreenloop:
  LDA datasystext0,X ; screen line 0: system startup text
  STA $0800,X
  LDA #$20 ; screen line 1: blank
  STA $0820,X
  LDA datasystext2,X ; screen line 2: system startup text
  STA $0840,X
  LDA datasystext3,X ; screen line 3: system startup text
  STA $0860,X
  LDA #$20 ; screen line 4: blank
  STA $0880,X
  LDA datasystext0,X ; screen line 5: system startup text
  STA $08A0,X
  LDA datasystext6,X ; screen line 6: system startup text
  STA $08C0,X
  LDA datasystext7,X ; screen line 7: system startup text
  STA $08E0,X
  LDA datasystext8,X ; screen line 8: system startup text
  STA $0900,X
  LDA #$20 ; screen lines 9-17: blank
  STA $0920,X
  STA $0940,X
  STA $0960,X
  STA $0980,X
  STA $09A0,X
  STA $09C0,X
  STA $09E0,X
  STA $0A00,X
  STA $0A20,X
  LDA #$CC ; screen lines 0-17 attribute bit 0: 0/0 0/0 1/1 1/1
  STA $0A40,X
  STA $0A60,X
  STA $0A80,X
  STA $0AA0,X
  STA $0AC0,X
  STA $0AE0,X
  STA $0B00,X
  STA $0B20,X
  STA $0B40,X
  ; screen lines 2-17 attribute bit 1: 0/0 0/0 1/1 1/1
  STA $0B60,X
  STA $0B80,X
  STA $0BA0,X
  STA $0BC0,X
  STA $0BE0,X
  STA $0C00,X
  STA $0C20,X
  STA $0C40,X
  STA $0C60,X
  ; screen lines 0-17 attribute bit 2: 0/0 0/0 1/1 1/1
  STA $0C80,X
  STA $0CA0,X
  STA $0CC0,X
  STA $0CE0,X
  STA $0D00,X
  STA $0D20,X
  STA $0D40,X
  STA $0D60,X
  ; screen lines 0-5 attribute bit 3: 0/0 0/0 1/1 1/1
  STA $0D80,X
  STA $0DA0,X
  STA $0DC0,X
  STA $0DE0,X
  LDA #$C0 ; screen lines 6&7 attribute bit 3: 0/0 0/0 0/1 0/1
  STA $0E00,X
  LDA #$00 ; screen lines 8-17 attribute bit 3: 0/0 0/0 0/0 0/0
  STA $0E20,X
  STA $0E40,X
  STA $0E60,X
  STA $0E80,X
  STA $0EA0,X
  LDA #$CC ; screen lines 0-5 attribute bit 4: 0/0 0/0 1/1 1/1
  STA $0EC0,X
  STA $0EE0,X
  STA $0F00,X
  LDA #$0C ; screen lines 6&7 attribute bit 4: 0/0 0/0 1/0 1/0
  STA $0F20,X
  LDA #$00 ; screen lines 8-17 attribute bit 4: 0/0 0/0 0/0 0/0
  STA $0F40,X
  STA $0F60,X
  STA $0F80,X
  STA $0FA0,X
  STA $0FC0,X
  INX
  TXA
  AND #$03
  CMP #$00
  BNE initscreenloop
  JSR waitvscana
  TXA
  CMP #$20
  BNE initscreenloop
  ; copy a few extra characters from Bank E font to video memory
  LDA #$10 ; destination page: screen font row 0
  STA FVMCDEST
  LDA #$EB ; source page: Bank E font row B
  STA FVMCSRC
  LDX #$C0 ; copy column C: copyright sign to position $0C
  JSR waitvscana
  JSR fvmcchar
  LDA #$EA ; source page: Bank E font row A
  STA FVMCSRC
  LDX #$E0 ; copy column E: diamond outline to position $0E
  JSR fvmcchar
  LDA #$EE ; source page: Bank E font row E
  STA FVMCSRC
  LDA #$16 ; destination page: screen font row 6
  STA FVMCDEST
  LDX #$00 ; copy column 0: en dash to position $60
  JSR fvmcchar
  LDA #$00 ; disable FVMC
  STA FVMCDEST
  STA FVMCSRC
  ; decompress and load graphics common to both aspect ratios
  LDA #<datagfx
  STA POINTER0+0
  LDA #>datagfx
  STA POINTER0+1
  LDA #$03 ; page 3 in compressed data
  JSR decompresspage
  LDA #$07
  STA FVMCSRC
  LDA #$18 ; page 8 in font memory
  STA FVMCDEST
  JSR fvmcpage
  LDA #$06 ; page 6 in compressed data
  JSR decompresspage
  LDA #$07
  STA FVMCSRC
  LDA #$1F ; page F in font memory
  STA FVMCDEST
  JSR fvmcpage
  ; check aspect ratio
  LDA VIDEOSTATE
  AND #$80
  BNE widescreenlogo
  ; logo (classic)
  JSR waitvscana
  LDX #$00
logocloop:
  TXA
  ORA #$A0 ; X+A0
  STA $096C,X
  ORA #$08 ; X+A8
  STA $098C,X
  EOR #$18 ; X+B0
  STA $09AC,X
  ORA #$08 ; X+B8
  STA $09CC,X
  EOR #$78 ; X+C0
  STA $09EC,X
  ORA #$08 ; X+C8
  STA $0A0C,X
  JSR logocommonpercolumn ; sets Acc := 0
  STA $094C,X ; use blank characters on rows 10 and 17
  STA $0A2C,X
  INX
  CPX #$08
  BCC logocloop
  LDA #$00 ; page 0 in compressed data
  JSR decompresspage
  LDA #$07
  STA FVMCSRC
  LDA #$1A ; page A in font memory
  STA FVMCDEST
  JSR fvmcpage
  LDA #$01 ; page 1 in compressed data
  JSR decompresspage
  LDA #$07
  STA FVMCSRC
  LDA #$1B ; page B in font memory
  STA FVMCDEST
  JSR fvmcpage
  LDA #$02 ; page 2 in compressed data
  JSR decompresspage
  LDA #$07
  STA FVMCSRC
  LDA #$1C ; page C in font memory
  STA FVMCDEST
  JSR fvmcpage
  JMP logocolors
widescreenlogo:  
  ; logo (wide)
  JSR waitvscana
  LDX #$00
logowloop:
  TXA
  ORA #$80 ; X+80
  STA $094C,X
  ORA #$08 ; X+88
  STA $096C,X
  EOR #$18 ; X+90
  STA $098C,X
  ORA #$08 ; X+98
  STA $09AC,X
  EOR #$78 ; X+E0
  STA $09CC,X
  ORA #$08 ; X+E8
  STA $09EC,X
  EOR #$18 ; X+F0
  STA $0A0C,X
  ORA #$08 ; X+F8
  STA $0A2C,X
  JSR logocommonpercolumn
  INX
  CPX #$08
  BCC logowloop
  ; blank out cells not used for logo
  STA $094C
  STA $094D
  STA $0952
  STA $0953
  STA $096C
  STA $0973
  STA $0A0C
  STA $0A13
  STA $0A2C
  STA $0A2D
  STA $0A32
  STA $0A33
  LDA #$04 ; page 4 in compressed data
  JSR decompresspage
  LDA #$07
  STA FVMCSRC
  LDA #$19 ; page 9 in font memory
  STA FVMCDEST
  JSR fvmcpage
  LDA #$05 ; page 5 in compressed data
  JSR decompresspage
  LDA #$07
  STA FVMCSRC
  LDA #$1E ; page E in font memory
  STA FVMCDEST
  JSR fvmcpage
logocolors:
  ; cell color overrides common to both aspect ratios
  LDX #$00
  JSR waitvscana
logocolorloop:
  LDA datalogocolors+$00,X
  STA $0B0E,X
  LDA datalogocolors+$04,X
  STA $0B2E,X
  LDA datalogocolors+$08,X
  STA $0C2E,X
  LDA datalogocolors+$0C,X
  STA $0C4E,X
  LDA datalogocolors+$10,X
  STA $0D4E,X
  LDA datalogocolors+$14,X
  STA $0D6E,X
  LDA datalogocolors+$18,X
  STA $0E6E,X
  LDA datalogocolors+$1C,X
  STA $0E8E,X
  LDA datalogocolors+$20,X
  STA $0F8E,X
  LDA datalogocolors+$24,X
  STA $0FAE,X
  INX
  CPX #$04
  BCC logocolorloop
  
halt:
  JMP halt

logocommonpercolumn:
  LDA #$CC ; bits 0-2 on for "foreground" colors
  STA $0AEC,X
  STA $0B0C,X
  STA $0B2C,X
  STA $0B4C,X
  STA $0C0C,X
  STA $0C2C,X
  STA $0C4C,X
  STA $0C6C,X
  STA $0D2C,X
  STA $0D4C,X
  STA $0D6C,X
  STA $0D8C,X
  LDA #$AA ; bits 3-4 on for "secondary" colors
  STA $0E4C,X
  STA $0E6C,X
  STA $0E8C,X
  STA $0EAC,X
  STA $0F6C,X
  STA $0F8C,X
  STA $0FAC,X
  STA $0FCC,X
  LDA #$00 ; blank out character 00
  STA $1000,X
  STA $1008,X
  RTS

fvmcpage:
; Subroutine: Copy one full page via FVMC (registers already set)
; Side effects: Accumulator clobbered.
; Acc := X
  JSR waitvscana
  TXA
  LDX #$00
fvmcpagecopyloop:
  STA $00,X
  INX
  BNE fvmcpagecopyloop
  STX FVMCSRC
  STX FVMCDEST
  TAX
  RTS
  
fvmcchar:
; Subroutine: Copy one character via FVMC (page registers already set;
; character specified by setting X register to address within page)
; Side effects: Accumulator, X register clobbered
; Acc := 0
; X := (X & $0F) + $10
fvmccharcopyloop:
  STA $00,X
  INX
  TXA
  AND #$0F
  BNE fvmccharcopyloop
  RTS

decompresspage:
; Subroutine: Load page number Acc from compressed data beginning at POINTER0
; and store the decompressed data in page 07
; Side effects: Acc, X, Y, POINTER1, POINTER2 clobbered
  ; get starting address of requested page
CDATASTART     = POINTER0
DECODELEN      = SRSCRATCH+0 ; not needed?
READHEADBYTE   = POINTER1
READHEADNYBBLE = SRSCRATCH+1
WRITEHEADBYTE  = POINTER2
WRITEHEADCRUMB = SRSCRATCH+2
RUNLENCRUMBS   = SRSCRATCH+3
RUNLENBYTES    = SRSCRATCH+4
RUNDIGIT       = SRSCRATCH+5
RUNVAL         = SRSCRATCH+6
NEWRUNVAL      = SRSCRATCH+7
READBYTEBUF    = SRSCRATCH+8
WRITEBYTEBUF   = SRSCRATCH+9
READNYBBLEBUF  = SRSCRATCH+10 ; not needed?
WRITECRUMBBUF  = SRSCRATCH+11 ; not needed?
  ; get starting address of requested page
  ; (CDATASTART),Y + CDATASTART
  ASL A
  TAY
  CLC
  LDA (CDATASTART),Y
  ADC CDATASTART+0
  STA READHEADBYTE+0
  INY
  LDA (CDATASTART),Y
  ADC CDATASTART+1
  STA READHEADBYTE+1
  LDA #$00
  STA READHEADNYBBLE
  STA WRITEHEADBYTE
  STA WRITEHEADCRUMB
  STA WRITEBYTEBUF
  LDA #$07
  STA WRITEHEADBYTE+1
  LDA #$FF
  STA RUNVAL
  LDA #$00
  STA RUNLENBYTES
  STA RUNLENCRUMBS
  LDY #$00 ; because there are no unindexed indirect load/store opcodes
  ; read one nybble
dcpreadnybble:
  LDA READHEADNYBBLE
  BNE dcpreadnybbleelse
  ; low nybble; fetch byte
  LDA #$01 ; next time, read saved high nybble
  STA READHEADNYBBLE
  LDA (READHEADBYTE),Y
  STA READBYTEBUF
  INC READHEADBYTE
  BNE 2 ; skip next INC if nonzero
  INC READHEADBYTE+1 ; if low byte zero, increment high byte
  ; extract low nybble (Acc still holds just-read byte)
  AND #$0F
  BPL dcpreadnybbleendif ; BRA: negative flag cleared by AND
dcpreadnybbleelse:
  ; extract high nybble from stored byte value
  LDA #$00 ; next time, read low nybble from fresh byte
  STA READHEADNYBBLE
  LDA READBYTEBUF
  LSR A
  LSR A
  LSR A
  LSR A
dcpreadnybbleendif:
  ; just-read nybble in Acc
  ; separate to NEWRUNVAL and RUNDIGIT
  TAX
  AND #$03
  STA NEWRUNVAL
  TXA
  LSR A
  LSR A
  BNE 2 ; skip next LDA if nonzero
  LDA #$04 ; replace 0 digit with 4
  STA RUNDIGIT
  ; is this a continuation of a run spec in progress?
  LDA NEWRUNVAL
  CMP RUNVAL
  BNE dcpwriterun
  ; add new digit to run length
  LDA RUNLENBYTES
  ; it's possible we read past the end of compressed data and found a
  ; matching run spec nybble by chance. a too-long last run isn't a problem,
  ; because we won't write past a page boundary, but we need a stop condition
  ; for reading garbage as a run spec. If computed run length meets or
  ; exceeds maximum (256 bytes), just stop reading and write the run.
  ASL A
  BCS dcprunlenoverflow
  ASL A
  BCS dcprunlenoverflow
  ADC RUNLENCRUMBS
  BCS dcprunlenoverflow
  STA RUNLENBYTES
  LDA RUNDIGIT
  STA RUNLENCRUMBS
  ; read another nybble
  JMP dcpreadnybble
dcprunlenoverflow:
  LDA #$04
  STA RUNLENCRUMBS
  LDA #$FF
  STA RUNLENBYTES ; 256 bytes is represented as 255 bytes and 4 crumbs
  ; fall through to write run
dcpwriterun:
  ; check if run length has reached zero
  ; this contition is evaluated at the top of the loop because reading the
  ; first nybble counts as non-matching and therefore triggers writing a
  ; zero-length run
  LDA RUNLENCRUMBS
  BNE dcpwriterunskip1
  LDA RUNLENBYTES
  BEQ dcpwriterundone
dcpwriterunskip1:
  ; output a crumb: shift RUNVAL into high bits of WRITEBYTEBUF
  ; (earlier output crumbs get shifted lower)
  LDA RUNVAL
  LSR A
  ROR WRITEBYTEBUF
  LSR A
  ROR WRITEBYTEBUF
  ; advance write head by one crumb
  LDA WRITEHEADCRUMB
  ADC #$01 ; if WRITEBYTEBUF was not already full, carry is clear
  CMP #$04
  BCC dcpwriterunskip2 ; do the following if WRITEBYTEBUF is full
  ; write byte from buffer
  LDA WRITEBYTEBUF
  STA (WRITEHEADBYTE),Y
  INC WRITEHEADBYTE
  BNE 1 ; if nonzero, skip next RTS
  RTS ; if zero, page is full, decompression is done
  ; INC DECODELEN ; not needed?
  LDA #$00 ; reset WRITEBYTEBUF and WRITEHEADCRUMB
  STA WRITEBYTEBUF
dcpwriterunskip2:
  STA WRITEHEADCRUMB
  ; decrement run length
  DEC RUNLENCRUMBS
  BPL dcpwriterun ; if RUNLENCRUMBS wraps around to >=128, perform borrow
  ; from RUNLENBYTES below; otherwise, continue writing run above.
  DEC RUNLENBYTES
  LDA #$03
  STA RUNLENCRUMBS
  BNE dcpwriterun ; BRA: zero flag cleared by LDA above
dcpwriterundone:
  ; now we need to retrieve the nonmatching nybble that triggered the run to
  ; be written, and set it up as the runspec in progress
  LDA NEWRUNVAL
  STA RUNVAL
  LDA RUNDIGIT
  STA RUNLENCRUMBS
  ; RUNLENBYTES should still be 0 at this point
  JMP dcpreadnybble ; this could be BNE as BRA because RUNDIGIT is always
  ; nonzero, but it seems to be too far for a branch to jump
  

bytetohex:
; Subroutine: Convert value in Accumulator to uppercase hexadecimal.
; Side effects: result stored in zp$86,$87, neg digit count stored in X
  TAX
  AND #$0F ; extract low nybble
  ORA #$30 ; convert to numeric character
  CMP #$3A ; N := (A in 30-39); C := (A in 3A-3F)
  BMI bytetohexb1
  ADC #$06 ; if lo nybble > 9, convert to letter (C is set; effectively add 7)
bytetohexb1:
  STA $87 ; write low nybble character
  TXA
  AND #$F0 ; extract high nybble
  BEQ bytetohexb3 ; if high nybble is zero, jump
  LSR
  LSR
  LSR
  LSR ; shift nybble into place
  ADC #$30 ; convert to numeric character
  CMP #$3A ; N := (A in 30-39); C := (A in 3A-3F)
  BMI bytetohexb2
  ADC #$06 ; if hi nybble > 9, convert to letter (C is set; effectively add 7)
bytetohexb2:
  STA $86 ; write high nybble character
  TXA ; restore Accumulator
  LDX #$FE ; set X to -2 (2 digits)
  RTS
bytetohexb3:
  LDA #$30
  STA $86 ; write high zero
  TXA ; restore Accumulator
  LDX #$FF ; set X to -1 (1 digit)
  RTS

; Subroutine: Convert value in Accumulator to decimal. Several entry points.
; Side effects: result stored in zp$8C,$8D,$8E,$8F, neg digit count stored
; in X, accumulator clobbered
bytetodecn:
  ; treat value as twos-complement negative number
  EOR #$FF ; find negative number
  CLC
  ADC #$01
  BCS bytetodecb10 ; negative zero? write literal "-256" instead
  STA $8F ; store negative number in zeropage
  LDA #$60 ; load minus sign for sign column
  STA $8C ; output sign column
  SED
  LDA #$00 ; initialize units and tens digits in accumulator
  STA $8D ; initialize hundreds digit in output position
  JMP bytetodecj9
bytetodecb10:
  STA $8C ; output - (sign column)
  LDA #$32
  STA $8D ; output 2 (hundreds column)
  LDA #$35
  STA $8E ; output 5 (hundreds column)
  LDA #$36
  STA $8F ; output 6 (hundreds column)
  LDA #$00 ; restore Accumulator
  LDX #$FD ; set X to -3 (3 digits)
  RTS
bytetodecus:
  ; Treat value as result of unsigned subtraction. Branch on carry flag...
  BCC bytetodecn
  JMP bytetodecp
bytetodecs:
  ; Treat value as result of signed subtraction. Branch on overflow and negative flags...
  BVS bytetodecb8
  BMI bytetodecn
  JMP bytetodecp
bytetodecb8:
  BPL bytetodecn
  JMP bytetodecp
bytetodecua:
  ; Treat value as result of unsigned addition (or 9-bit unsigned value). Branch on carry flag...
  BCC bytetodecp
bytetodecbp:
  ; Treat value as unsigned, add 256 (range 256-511)
  STA $8F ; place input in zeropage (temporarily using units digit output byte)
  LDA #$20 ; load space for sign column
  STA $8C ; output sign column
  LDA #$02
  STA $8D ; initialize hundreds digit in output position
  LDA #$56 ; initialize units and tens digits in accumulator
  JMP bytetodecj9
bytetodecp:
  ; Treat value as unsigned in range 0-255
  STA $8F ; place input in zeropage (temporarily using units digit output byte)
  LDA #$20 ; load space for sign column
  STA $8C ; output sign column
  LDA #$00 ; initialize units and tens digits in accumulator
  STA $8D ; initialize hundreds digit in output position
bytetodecj9:
  SED ; begin adding data bits
  LSR $8F ; shift input
  BCC bytetodecb0
  CLC
  ADC #$01 ; add bit value
bytetodecb0:
  LSR $8F ; shift input
  BCC bytetodecb1
  CLC
  ADC #$02 ; add bit value
bytetodecb1:
  LSR $8F ; shift input
  BCC bytetodecb2
  CLC
  ADC #$04 ; add bit value
bytetodecb2:
  LSR $8F ; shift input
  BCC bytetodecb3
  CLC
  ADC #$08 ; add bit value
bytetodecb3:
  LSR $8F ; shift input
  BCC bytetodecb4
  CLC
  ADC #$16 ; add bit value
bytetodecb4:
  LSR $8F ; shift input
  BCC bytetodecb5
  CLC
  ADC #$32 ; add bit value
  BCC bytetodecb5
  CLC
  INC $8D ; increment hundreds digit if this bit caused a carry (possible in Big Positive number format)
bytetodecb5:
  LSR $8F ; shift input
  BCC bytetodecb6
  CLC
  ADC #$64 ; add bit value
  BCC bytetodecb6
  CLC
  INC $8D ; increment hundreds digit if this bit caused a carry
bytetodecb6:
  LSR $8F ; shift input
  BCC bytetodecb7
  CLC
  INC $8D ; increment hundreds digit
  ADC #$28 ; add 28
  BCC bytetodecb7
  CLC
  INC $8D ; increment hundreds digit if the 28 caused another carry
bytetodecb7:
  CLD
  LDX $8D ; is hundreds digit zero?
  BNE bytetodecb13
  LDX #$30
  STX $8D ; output numeral zero in hundreds column
  TAX ; move units and tens digits out of the way
  AND #$F0 ; retrieve tens digit; is it zero?
  BNE bytetodecb12
  TXA
  LDX #$30
  STX $8E ; output numeral zero in tens column
  AND #$0F ; retrieve units digit
  ADC #$30 ; convert to numeral
  STA $8F ; output units digit
  LDX #$FF ; set X to -1 (1 digit)
  RTS
bytetodecb12:
  LSR
  LSR
  LSR
  LSR ; shift digit into place
  ADC #$30 ; convert to numeral
  STA $8E ; output tens digit
  TXA
  AND #$0F ; retrieve units digit
  ADC #$30 ; convert to numeral
  STA $8F ; output units digit
  LDX #$FE ; set X to -2 (2 digits)
  RTS
bytetodecb13:
  TAX ; move units and tens digits out of the way
  LDA $8D ; retrieve hundreds digit
  ADC #$30 ; convert to numeral
  STA $8D ; output hundreds digit
  TXA
  AND #$F0 ; retrieve tens digit
  LSR
  LSR
  LSR
  LSR ; shift digit into place
  ADC #$30 ; convert to numeral
  STA $8E ; output tens digit
  TXA
  AND #$0F ; retrieve units digit
  ADC #$30 ; convert to numeral
  STA $8F ; output units digit
  LDX #$FD ; set X to -3 (3 digits)
  RTS

  .align 8
waitvscana:
; Subroutine: Wait for start of vertical blanking interval.
; Side effects: Accumulator is clobbered.
  ; determine video flags to look for
  LDA VIDEOSTATE
  AND #$CC
  ORA #$20
  ; wait for start of vertical retrace
  CMP VIDEOSTATE
  BNE -5 ; CMP again
  RTS

nmicode: ; empty, because NMI not presently used
  RTI

  .org $FA00
datagfx:
  .incbin firmwaregfx.compressed
datalogocolors: .align 3
  .byte $CC,$CC,$8A,$8C,$CE,$EE,$EC,$CC
  .byte $AC,$AE,$EE,$EC,$C8,$C8,$AA,$CA
  .byte $8C,$8C,$EE,$EC,$CA,$EA,$EE,$CE
  .byte $EA,$EA,$CC,$CA,$AE,$AE,$88,$A8
  .byte $8A,$88,$A8,$AA,$A8,$88,$CE,$AE
datasystext0: .align 5
  .text ". \xFE\xFF \x80\x81 .  \x0E  \x0E  \x0E  \x0E  . \xFE\xFF \x80\x81 ."
datasystext2:
  .text "\x8F   Retro 6k Fantasy Computer  \x8F"
datasystext3:
  .text "\xF0     Entertainment System\x11    \xF0"
datasystext6:
  .text "   Please insert a cartridge>   "
datasystext7:
  .text "     F\xF7\xF8\xF9ware version 2031@     "
datasystext8:
  .text "\0142019`20 Maggie David \x86\x87\x88 Haynes"
datasyscolors:
  .byte $00,$81,$84,$0D,$02,$83,$86,$0F
  .byte $D0,$59,$5C,$DD,$D2,$5B,$5E,$DF
  .byte $20,$A1,$A4,$2D,$22,$A3,$A6,$2F
  .byte $F0,$79,$7C,$FD,$F2,$7B,$7E,$FF
initfontsrcpage:
  .byte $E4,$E5,$E6,$E7,$E3,$E2,$E1,$00
initfontdestpage:
  .byte $14,$15,$16,$17,$13,$12,$11,$00

; 6502 program counter initialization vectors
  .org $FFFA
  .word nmicode ; NMI vector, in firmware
  .word entry ; reset vector, in firmware
  .word $2010 ; interrupt request vector, in cartridge