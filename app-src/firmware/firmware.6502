; Retro6K System Firmware
; zeropage addresses used in subroutines
TEXTBUF   = $80 ; up to 8 bytes
TCURSORLO = $88 ; bits 0-4: text cursor column; bits 5-7: text cursor row b0-2
TCURSORHI = $89 ; bits 0-1: text cursor row bits 3-4
TCBLINK   = $8A ; bits 0-4: cursor blink cycle counter
CONSFLAGS = $8B ; bit 7: print next char literally
COLORS    = $8C ; colors (4 bytes) for new characters to print
CHSRCPTR  = $90 ; character source row pointers (4 bytes) for scrolling
CHDESTPTR = $94 ; character destination row pointers (4 bytes) for scrolling
COSRCPTR  = $98 ; color source row pointers (10 bytes) for scrolling
CODESTPTR = $A2 ; color destination row pointers (10 bytes) for scrolling
WSTARGET  = $AD ; VIDEOSTATE flag to wait for
COBYTES   = $B0 ; packed color bytes (5 bytes)
BLINKBITS = $B5 ; which bits to toggle for blinking cursor (5 bytes)
COKNMASK  = $BA ; keep-nybble color mask
CORNMASK  = $BB ; replace-nybble color mask
POINTER0  = $E0
POINTER1  = $E2
POINTER2  = $E4
POINTER3  = $E6
SRSCRATCH = $F0
SAVEX     = $FE
SAVEY     = $FF
; special system addresses
KBDIN           = $0244
VIDEOSTATE      = $02FC
SOUNDVOICE0FREQ = $0380
SOUNDVOICE0VOL  = $0388
SOUNDVOICETYPES = $038C
FVMCDEST        = $03F8
FVMCSRC         = $03F9
DLSOFF          = $03FC
DLSON           = $03FD
DEBUGLOG        = $03FF
; code starts here
  .org $F000
entry: ; system power-on or reset
  ; misc initialization
  SEI
  CLD
  LDA #$00
  STA FVMCSRC
  STA FVMCDEST
  LDX #$F0
  STX DLSOFF ; turn off debug log suppression
  INX
  BNE -6 ; STX again
  LDX #>waitsubs
  STX DLSON ; but seriously, suppress logging of waiting subroutines
  JSR waitvscana
  ; display cartridge identification in bottom of screen
  LDX #$00
cartidcolloop:
  LDA #$F0
  STA $0B2A,X
  STA $0C4A,X
  STA $0D6A,X
  LDA #$50
  STA $0E8A,X
  STA $0FAA,X
  LDA #$53
  STA $0B4A,X
  STA $0C6A,X
  STA $0D8A,X
  LDA #$A0
  STA $0EAA,X
  STA $0FCA,X
  LDA #$02
  STA $09EA,X
  STA $0A2A,X
  LDA $1FFF,X
  STA $0A0A,X
  INX
  CPX #$0C
  BCC cartidcolloop
  LDA #$20
  STA $0A0A
  STA $0A15
  ;initialize palette
  LDX #$00
initpalloop:  
  LDA datasyscolors,X ; palette colors
  STA $0FE0,X
  INX
  CPX #$20
  BCC initpalloop
  ; load system font (specific subset in specific order)
  LDA #$E0
  STA FVMCSRC
  LDA #$10
  STA FVMCDEST
  JSR waitvscana
  LDX #$20
  JSR fvmcchar
  LDX #$00
initfontloop:
  LDA initfontsrcpage,X
  STA FVMCSRC
  LDA initfontdestpage,X
  STA FVMCDEST
  BEQ initfontloopexit
  JSR fvmcpage
  INX
  JMP initfontloop
initfontloopexit:
  ; detect presence of valid cartridge
  ; by checking for magic bytes 47 A9 0C 1E
  LDA $200A
  CMP #$47
  BNE nocart
  LDA $200B
  CMP #$A9
  BNE nocart
  LDA $200C
  CMP #$0C
  BNE nocart
  LDA $200D
  CMP #$1E
  BNE nocart
  ; if we got this far, jump to cartridge start vector
  JMP ($200E)
nocart: ; no cartridge inserted
  ; initialize screen display
  JSR waitvscana
  LDX #$00
initscreenloop:
  LDA datasystext0,X ; screen line 0: system startup text
  STA $0800,X
  LDA #$20 ; screen line 1: blank
  STA $0820,X
  LDA datasystext2,X ; screen line 2: system startup text
  STA $0840,X
  LDA datasystext3,X ; screen line 3: system startup text
  STA $0860,X
  LDA #$20 ; screen line 4: blank
  STA $0880,X
  LDA datasystext0,X ; screen line 5: system startup text
  STA $08A0,X
  LDA datasystext6,X ; screen line 6: system startup text
  STA $08C0,X
  LDA datasystext7,X ; screen line 7: system startup text
  STA $08E0,X
  LDA datasystext8,X ; screen line 8: system startup text
  STA $0900,X
  LDA #$20 ; screen lines 9-17: blank
  STA $0920,X
  STA $0940,X
  STA $0960,X
  STA $0980,X
  STA $09A0,X
  STA $09C0,X
  STA $09E0,X
  STA $0A00,X
  STA $0A20,X
  LDA #$CC ; screen lines 0-17 attribute bit 0: 0/0 0/0 1/1 1/1
  STA $0A40,X
  STA $0A60,X
  STA $0A80,X
  STA $0AA0,X
  STA $0AC0,X
  STA $0AE0,X
  STA $0B00,X
  STA $0B20,X
  STA $0B40,X
  ; screen lines 2-17 attribute bit 1: 0/0 0/0 1/1 1/1
  STA $0B60,X
  STA $0B80,X
  STA $0BA0,X
  STA $0BC0,X
  STA $0BE0,X
  STA $0C00,X
  STA $0C20,X
  STA $0C40,X
  STA $0C60,X
  ; screen lines 0-17 attribute bit 2: 0/0 0/0 1/1 1/1
  STA $0C80,X
  STA $0CA0,X
  STA $0CC0,X
  STA $0CE0,X
  STA $0D00,X
  STA $0D20,X
  STA $0D40,X
  STA $0D60,X
  ; screen lines 0-5 attribute bit 3: 0/0 0/0 1/1 1/1
  STA $0D80,X
  STA $0DA0,X
  STA $0DC0,X
  STA $0DE0,X
  LDA #$C0 ; screen lines 6&7 attribute bit 3: 0/0 0/0 0/1 0/1
  STA $0E00,X
  LDA #$00 ; screen lines 8-17 attribute bit 3: 0/0 0/0 0/0 0/0
  STA $0E20,X
  STA $0E40,X
  STA $0E60,X
  STA $0E80,X
  STA $0EA0,X
  LDA #$CC ; screen lines 0-5 attribute bit 4: 0/0 0/0 1/1 1/1
  STA $0EC0,X
  STA $0EE0,X
  STA $0F00,X
  LDA #$0C ; screen lines 6&7 attribute bit 4: 0/0 0/0 1/0 1/0
  STA $0F20,X
  LDA #$00 ; screen lines 8-17 attribute bit 4: 0/0 0/0 0/0 0/0
  STA $0F40,X
  STA $0F60,X
  STA $0F80,X
  STA $0FA0,X
  STA $0FC0,X
  INX
  TXA
  AND #$03
  CMP #$00
  BNE initscreenloop
  JSR waitvscana
  TXA
  CMP #$20
  BNE initscreenloop
  ; copy a few extra characters from Bank E font to video memory
  LDA #$10 ; destination page: screen font row 0
  STA FVMCDEST
  LDA #$EB ; source page: Bank E font row B
  STA FVMCSRC
  LDX #$C0 ; copy column C: copyright sign to position $0C
  JSR waitvscana
  JSR fvmcchar
  LDA #$EA ; source page: Bank E font row A
  STA FVMCSRC
  LDX #$E0 ; copy column E: diamond outline to position $0E
  JSR fvmcchar
  LDA #$EE ; source page: Bank E font row E
  STA FVMCSRC
  LDA #$16 ; destination page: screen font row 6
  STA FVMCDEST
  LDX #$00 ; copy column 0: en dash to position $60
  JSR fvmcchar
  LDA #$00 ; disable FVMC
  STA FVMCDEST
  STA FVMCSRC
  ; decompress and load graphics common to both aspect ratios
  LDA #<datagfx
  STA POINTER0+0
  LDA #>datagfx
  STA POINTER0+1
  LDA #$03 ; page 3 in compressed data
  JSR decompresspage
  LDA #$07
  STA FVMCSRC
  LDA #$18 ; page 8 in font memory
  STA FVMCDEST
  JSR fvmcpage
  LDA #$06 ; page 6 in compressed data
  JSR decompresspage
  LDA #$07
  STA FVMCSRC
  LDA #$1F ; page F in font memory
  STA FVMCDEST
  JSR fvmcpage
  ; check aspect ratio
  LDA VIDEOSTATE
  AND #$80
  BNE widescreenlogo
  ; logo (classic)
  JSR waitvscana
  LDX #$00
logocloop:
  TXA
  ORA #$A0 ; X+A0
  STA $096C,X
  ORA #$08 ; X+A8
  STA $098C,X
  EOR #$18 ; X+B0
  STA $09AC,X
  ORA #$08 ; X+B8
  STA $09CC,X
  EOR #$78 ; X+C0
  STA $09EC,X
  ORA #$08 ; X+C8
  STA $0A0C,X
  JSR logocommonpercolumn ; sets Acc := 0
  STA $094C,X ; use blank characters on rows 10 and 17
  STA $0A2C,X
  INX
  CPX #$08
  BCC logocloop
  LDA #$00 ; page 0 in compressed data
  JSR decompresspage
  LDA #$07
  STA FVMCSRC
  LDA #$1A ; page A in font memory
  STA FVMCDEST
  JSR fvmcpage
  LDA #$01 ; page 1 in compressed data
  JSR decompresspage
  LDA #$07
  STA FVMCSRC
  LDA #$1B ; page B in font memory
  STA FVMCDEST
  JSR fvmcpage
  LDA #$02 ; page 2 in compressed data
  JSR decompresspage
  LDA #$07
  STA FVMCSRC
  LDA #$1C ; page C in font memory
  STA FVMCDEST
  JSR fvmcpage
  JMP logocolors
widescreenlogo:  
  ; logo (wide)
  JSR waitvscana
  LDX #$00
logowloop:
  TXA
  ORA #$80 ; X+80
  STA $094C,X
  ORA #$08 ; X+88
  STA $096C,X
  EOR #$18 ; X+90
  STA $098C,X
  ORA #$08 ; X+98
  STA $09AC,X
  EOR #$78 ; X+E0
  STA $09CC,X
  ORA #$08 ; X+E8
  STA $09EC,X
  EOR #$18 ; X+F0
  STA $0A0C,X
  ORA #$08 ; X+F8
  STA $0A2C,X
  JSR logocommonpercolumn
  INX
  CPX #$08
  BCC logowloop
  ; blank out cells not used for logo
  STA $094C
  STA $094D
  STA $0952
  STA $0953
  STA $096C
  STA $0973
  STA $0A0C
  STA $0A13
  STA $0A2C
  STA $0A2D
  STA $0A32
  STA $0A33
  LDA #$04 ; page 4 in compressed data
  JSR decompresspage
  LDA #$07
  STA FVMCSRC
  LDA #$19 ; page 9 in font memory
  STA FVMCDEST
  JSR fvmcpage
  LDA #$05 ; page 5 in compressed data
  JSR decompresspage
  LDA #$07
  STA FVMCSRC
  LDA #$1E ; page E in font memory
  STA FVMCDEST
  JSR fvmcpage
logocolors:
  ; cell color overrides common to both aspect ratios
  LDX #$00
  JSR waitvscana
logocolorloop:
  LDA datalogocolors+$00,X
  STA $0B0E,X
  LDA datalogocolors+$04,X
  STA $0B2E,X
  LDA datalogocolors+$08,X
  STA $0C2E,X
  LDA datalogocolors+$0C,X
  STA $0C4E,X
  LDA datalogocolors+$10,X
  STA $0D4E,X
  LDA datalogocolors+$14,X
  STA $0D6E,X
  LDA datalogocolors+$18,X
  STA $0E6E,X
  LDA datalogocolors+$1C,X
  STA $0E8E,X
  LDA datalogocolors+$20,X
  STA $0F8E,X
  LDA datalogocolors+$24,X
  STA $0FAE,X
  INX
  CPX #$04
  BCC logocolorloop
  BCS startsysshell

logocommonpercolumn:
  LDA #$CC ; bits 0-2 on for "foreground" colors
  STA $0AEC,X
  STA $0B0C,X
  STA $0B2C,X
  STA $0B4C,X
  STA $0C0C,X
  STA $0C2C,X
  STA $0C4C,X
  STA $0C6C,X
  STA $0D2C,X
  STA $0D4C,X
  STA $0D6C,X
  STA $0D8C,X
  LDA #$AA ; bits 3-4 on for "secondary" colors
  STA $0E4C,X
  STA $0E6C,X
  STA $0E8C,X
  STA $0EAC,X
  STA $0F6C,X
  STA $0F8C,X
  STA $0FAC,X
  STA $0FCC,X
  LDA #$00 ; blank out character 00
  STA $1000,X
  STA $1008,X
  RTS

startsysshell:
  ; initialize shell state
  LDA #$20
  STA TCURSORLO
  LDA #$0A
  STA TCURSORHI
  LDA #$00
  STA TCBLINK
  STA COLORS+0
  STA COLORS+1
  LDA #$07
  STA COLORS+2
  STA COLORS+3
  LDA #$AA ; blink "secondary" colors in bitplanes 0-2 (RGB)
  STA BLINKBITS+0
  STA BLINKBITS+1
  STA BLINKBITS+2
  LDA #$CC ; blink "foreground" colors in bitplanes 3-4 (intensity)
  STA BLINKBITS+3
  STA BLINKBITS+4
readcommand:
  LDA #$1E ; ">" in SCE
  JSR printch
readcommandkeyloop:
  JSR waitvscana
  JSR cursortick
  LDA KBDIN
  BEQ readcommandkeyloop
  CMP #$0D
  BEQ processcommand
  JSR printch
  JMP readcommandkeyloop
processcommand:
  JSR printch
  LDA #$0A
  JSR printch
  ; TODO: read and interpret command that was entered
  JMP readcommand

beep:
BEEPFREQ = 750
  ; start beep
  LDA <BEEPFREQ
  STA SOUNDVOICE0FREQ
  LDA >BEEPFREQ
  STA SOUNDVOICE0FREQ+1
  LDA #$AA
  STA SOUNDVOICE0VOL
  LDA #$00
  STA SOUNDVOICETYPES
  ; delay
  LDY #$15
beepdelayloop:
  JSR waitvscana
  AND #$CC
  CMP VIDEOSTATE
  BNE -5
  DEY
  BNE beepdelayloop
  LDA #$00
  STA SOUNDVOICE0FREQ
  STA SOUNDVOICE0FREQ+1
  STA SOUNDVOICE0VOL
  RTS

; Subroutine: Convert value in Accumulator to decimal. Several entry points.
; Side effects: result stored in zp$8C,$8D,$8E,$8F, neg digit count stored
; in X, accumulator clobbered
bytetodecn:
  ; treat value as twos-complement negative number
  EOR #$FF ; find negative number
  CLC
  ADC #$01
  BCS bytetodecb10 ; negative zero? write literal "-256" instead
  STA $8F ; store negative number in zeropage
  LDA #$60 ; load minus sign for sign column
  STA $8C ; output sign column
  SED
  LDA #$00 ; initialize units and tens digits in accumulator
  STA $8D ; initialize hundreds digit in output position
  JMP bytetodecj9
bytetodecb10:
  STA $8C ; output - (sign column)
  LDA #$32
  STA $8D ; output 2 (hundreds column)
  LDA #$35
  STA $8E ; output 5 (hundreds column)
  LDA #$36
  STA $8F ; output 6 (hundreds column)
  LDA #$00 ; restore Accumulator
  LDX #$FD ; set X to -3 (3 digits)
  RTS
bytetodecus:
  ; Treat value as result of unsigned subtraction. Branch on carry flag...
  BCC bytetodecn
  JMP bytetodecp
bytetodecs:
  ; Treat value as result of signed subtraction. Branch on overflow and negative flags...
  BVS bytetodecb8
  BMI bytetodecn
  JMP bytetodecp
bytetodecb8:
  BPL bytetodecn
  JMP bytetodecp
bytetodecua:
  ; Treat value as result of unsigned addition (or 9-bit unsigned value). Branch on carry flag...
  BCC bytetodecp
bytetodecbp:
  ; Treat value as unsigned, add 256 (range 256-511)
  STA $8F ; place input in zeropage (temporarily using units digit output byte)
  LDA #$20 ; load space for sign column
  STA $8C ; output sign column
  LDA #$02
  STA $8D ; initialize hundreds digit in output position
  LDA #$56 ; initialize units and tens digits in accumulator
  JMP bytetodecj9
bytetodecp:
  ; Treat value as unsigned in range 0-255
  STA $8F ; place input in zeropage (temporarily using units digit output byte)
  LDA #$20 ; load space for sign column
  STA $8C ; output sign column
  LDA #$00 ; initialize units and tens digits in accumulator
  STA $8D ; initialize hundreds digit in output position
bytetodecj9:
  SED ; begin adding data bits
  LSR $8F ; shift input
  BCC bytetodecb0
  CLC
  ADC #$01 ; add bit value
bytetodecb0:
  LSR $8F ; shift input
  BCC bytetodecb1
  CLC
  ADC #$02 ; add bit value
bytetodecb1:
  LSR $8F ; shift input
  BCC bytetodecb2
  CLC
  ADC #$04 ; add bit value
bytetodecb2:
  LSR $8F ; shift input
  BCC bytetodecb3
  CLC
  ADC #$08 ; add bit value
bytetodecb3:
  LSR $8F ; shift input
  BCC bytetodecb4
  CLC
  ADC #$16 ; add bit value
bytetodecb4:
  LSR $8F ; shift input
  BCC bytetodecb5
  CLC
  ADC #$32 ; add bit value
  BCC bytetodecb5
  CLC
  INC $8D ; increment hundreds digit if this bit caused a carry (possible in Big Positive number format)
bytetodecb5:
  LSR $8F ; shift input
  BCC bytetodecb6
  CLC
  ADC #$64 ; add bit value
  BCC bytetodecb6
  CLC
  INC $8D ; increment hundreds digit if this bit caused a carry
bytetodecb6:
  LSR $8F ; shift input
  BCC bytetodecb7
  CLC
  INC $8D ; increment hundreds digit
  ADC #$28 ; add 28
  BCC bytetodecb7
  CLC
  INC $8D ; increment hundreds digit if the 28 caused another carry
bytetodecb7:
  CLD
  LDX $8D ; is hundreds digit zero?
  BNE bytetodecb13
  LDX #$30
  STX $8D ; output numeral zero in hundreds column
  TAX ; move units and tens digits out of the way
  AND #$F0 ; retrieve tens digit; is it zero?
  BNE bytetodecb12
  TXA
  LDX #$30
  STX $8E ; output numeral zero in tens column
  AND #$0F ; retrieve units digit
  ADC #$30 ; convert to numeral
  STA $8F ; output units digit
  LDX #$FF ; set X to -1 (1 digit)
  RTS
bytetodecb12:
  LSR
  LSR
  LSR
  LSR ; shift digit into place
  ADC #$30 ; convert to numeral
  STA $8E ; output tens digit
  TXA
  AND #$0F ; retrieve units digit
  ADC #$30 ; convert to numeral
  STA $8F ; output units digit
  LDX #$FE ; set X to -2 (2 digits)
  RTS
bytetodecb13:
  TAX ; move units and tens digits out of the way
  LDA $8D ; retrieve hundreds digit
  ADC #$30 ; convert to numeral
  STA $8D ; output hundreds digit
  TXA
  AND #$F0 ; retrieve tens digit
  LSR
  LSR
  LSR
  LSR ; shift digit into place
  ADC #$30 ; convert to numeral
  STA $8E ; output tens digit
  TXA
  AND #$0F ; retrieve units digit
  ADC #$30 ; convert to numeral
  STA $8F ; output units digit
  LDX #$FD ; set X to -3 (3 digits)
  RTS

bytetohex:
; Subroutine: Convert value in Accumulator to uppercase hexadecimal.
; Side effects: result stored in zp$86,$87, neg digit count stored in X
  TAX
  AND #$0F ; extract low nybble
  ORA #$30 ; convert to numeric character
  CMP #$3A ; N := (A in 30-39); C := (A in 3A-3F)
  BMI bytetohexb1
  ADC #$06 ; if lo nybble > 9, convert to letter (C is set; effectively add 7)
bytetohexb1:
  STA $87 ; write low nybble character
  TXA
  AND #$F0 ; extract high nybble
  BEQ bytetohexb3 ; if high nybble is zero, jump
  LSR
  LSR
  LSR
  LSR ; shift nybble into place
  ADC #$30 ; convert to numeric character
  CMP #$3A ; N := (A in 30-39); C := (A in 3A-3F)
  BMI bytetohexb2
  ADC #$06 ; if hi nybble > 9, convert to letter (C is set; effectively add 7)
bytetohexb2:
  STA $86 ; write high nybble character
  TXA ; restore Accumulator
  LDX #$FE ; set X to -2 (2 digits)
  RTS
bytetohexb3:
  LDA #$30
  STA $86 ; write high zero
  TXA ; restore Accumulator
  LDX #$FF ; set X to -1 (1 digit)
  RTS

calccolorbytes:
; Subroutine: Transpose color selections from COLORS[0-3] to COLORBYTES[0-4]
  PHA
  TXA
  PHA
  TYA
  PHA
  LDY #$00
calccolorloopy:
  LDA COLORS,Y
  LDX #$00
calccolorloopx:
  LSR A
  ROR COBYTES,X
  INX
  CPX #$05
  BCC calccolorloopx
  INY
  CPY #$04
  BCC calccolorloopy
  LDX #$00
calccolorloopz:
  LDA COBYTES,X
  AND #$F0
  STA COBYTES,X
  LSR A
  LSR A
  LSR A
  LSR A
  ORA COBYTES,X
  STA COBYTES,X
  INX
  CPX #$05
  BCC calccolorloopz
  PLA
  TAY
  PLA
  TAX
  PLA
  RTS

calcrownybble:
  LDA TCURSORLO
  AND #$20
  BEQ 2
  LDA #$FF ; Acc now #$00 for even row or #$FF for odd row
  EOR #$0F ; Acc now #$0F for even row or #$F0 for odd row
  RTS

coptradvance:
  CLC
  LDA COSRCPTR+0
  ADC #$20
  STA COSRCPTR+0
  LDA COSRCPTR+1
  ADC #$01
  STA COSRCPTR+1
  RTS

coptrcalc:
  LDA TCURSORLO
  AND #$1F
  TAY
  LDA TCURSORLO
  AND #$C0
  STA COSRCPTR+0
  LDA TCURSORHI
  LSR A ; now #$04 or #$05
  STA COSRCPTR+1
  LDA COSRCPTR+0
  ROR A ; bit shifted out is zero, so carry is now clear
  ADC #$40
  STA COSRCPTR+0
  LDA COSRCPTR+1
  ADC #$06 ; should not cause a carry
  STA COSRCPTR+1
  RTS

cursoradvance:
  ; clear cursor if shown
  JSR cursorhide
  ; move cursor pointer
  CLC
  LDA TCURSORLO
  ADC #$01
  STA TCURSORLO
  LDA TCURSORHI
  ADC #$00
  STA TCURSORHI
  ; bounds check
cursoradvancecheck:
  CMP #$0A
  BCC cursoradvrts ; if TCURSORHI < $0A, return
  LDA TCURSORLO
  CMP #$40
  BCC cursoradvrts ; if TCURSORLO < $20, return
  JMP scrolldown2
cursoradvrts:
  RTS

cursordown:
  ; clear cursor if shown
  JSR cursorhide
  ; move cursor pointer
  CLC
  LDA TCURSORLO
  ADC #$20
  STA TCURSORLO
  LDA TCURSORHI
  ADC #$00
  STA TCURSORHI
  ; bounds check
  JMP cursoradvancecheck

cursorhide:
  LDA TCBLINK
  AND #$10
  BNE 1 ; if cursor in 'off' phase, return
  RTS
  LDA #$00 ; set cursor cycle to reflect 'off'
  STA TCBLINK
  JMP cursortoggle

cursorleft:
  ; clear cursor if shown
  JSR cursorhide
  ; move cursor pointer
  SEC
  LDA TCURSORLO
  SBC #$01
  STA TCURSORLO
  LDA TCURSORHI
  SBC #$00
  STA TCURSORHI
  ; bounds check
cursorbackcheck:
  CMP #$08
  BCC 1 ; if TCURSORHI >= $08, return
  RTS
  LDA #$00
  STA TCURSORLO
  LDA #$08
  STA TCURSORHI

cursorreturn:
  ; clear cursor if shown
  JSR cursorhide
  ; move cursor pointer
  LDA TCURSORLO
  AND #$E0
  STA TCURSORLO
  RTS

cursortab:
  ; clear cursor if shown
  JSR cursorhide
  ; move cursor pointer
  CLC
  LDA TCURSORLO
  ADC #$04
  AND #$FC
  STA TCURSORLO
  LDA TCURSORHI
  ADC #$00
  STA TCURSORHI
  ; bounds check
  JMP cursoradvancecheck

cursortick:
  CLC
  LDA TCBLINK
  ADC #$01
  STA TCBLINK
  AND #$0F
  BEQ 1
  RTS
  ; fall through to cursortoggle

cursortoggle:
  JSR calcrownybble
  TAY
  LDX #$00
cursortogglesetuploop:
  TYA
  AND BLINKBITS,X
  STA COBYTES,X
  INX
  CPX #$05
  BCC cursortogglesetuploop
  JSR coptrcalc
  LDX #$00
cursortogglewriteloop:
  LDA COBYTES,X
  STX SAVEX
  JSR waithscanx
  EOR (COSRCPTR),Y
  JSR waithscanx
  STA (COSRCPTR),Y
  JSR coptradvance
  LDX SAVEX
  INX
  CPX #$05
  BCC cursortogglewriteloop
  RTS

cursorup:
  ; clear cursor if shown
  JSR cursorhide
  ; move cursor pointer
  SEC
  LDA TCURSORLO
  SBC #$20
  STA TCURSORLO
  LDA TCURSORHI
  SBC #$00
  STA TCURSORHI
  ; bounds check
  JMP cursorbackcheck

decompresspage:
; Subroutine: Load page number Acc from compressed data beginning at POINTER0
; and store the decompressed data in page 07
; Side effects: Acc, X, Y, POINTER1, POINTER2 clobbered
  ; get starting address of requested page
CDATASTART     = POINTER0
DECODELEN      = SRSCRATCH+0 ; not needed?
READHEADBYTE   = POINTER1
READHEADNYBBLE = SRSCRATCH+1
WRITEHEADBYTE  = POINTER2
WRITEHEADCRUMB = SRSCRATCH+2
RUNLENCRUMBS   = SRSCRATCH+3
RUNLENBYTES    = SRSCRATCH+4
RUNDIGIT       = SRSCRATCH+5
RUNVAL         = SRSCRATCH+6
NEWRUNVAL      = SRSCRATCH+7
READBYTEBUF    = SRSCRATCH+8
WRITEBYTEBUF   = SRSCRATCH+9
READNYBBLEBUF  = SRSCRATCH+10 ; not needed?
WRITECRUMBBUF  = SRSCRATCH+11 ; not needed?
  ; get starting address of requested page
  ; (CDATASTART),Y + CDATASTART
  ASL A
  TAY
  CLC
  LDA (CDATASTART),Y
  ADC CDATASTART+0
  STA READHEADBYTE+0
  INY
  LDA (CDATASTART),Y
  ADC CDATASTART+1
  STA READHEADBYTE+1
  LDA #$00
  STA READHEADNYBBLE
  STA WRITEHEADBYTE
  STA WRITEHEADCRUMB
  STA WRITEBYTEBUF
  LDA #$07
  STA WRITEHEADBYTE+1
  LDA #$FF
  STA RUNVAL
  LDA #$00
  STA RUNLENBYTES
  STA RUNLENCRUMBS
  LDY #$00 ; because there are no unindexed indirect load/store opcodes
  ; read one nybble
dcpreadnybble:
  LDA READHEADNYBBLE
  BNE dcpreadnybbleelse
  ; low nybble; fetch byte
  LDA #$01 ; next time, read saved high nybble
  STA READHEADNYBBLE
  LDA (READHEADBYTE),Y
  STA READBYTEBUF
  INC READHEADBYTE
  BNE 2 ; skip next INC if nonzero
  INC READHEADBYTE+1 ; if low byte zero, increment high byte
  ; extract low nybble (Acc still holds just-read byte)
  AND #$0F
  BPL dcpreadnybbleendif ; BRA: negative flag cleared by AND
dcpreadnybbleelse:
  ; extract high nybble from stored byte value
  LDA #$00 ; next time, read low nybble from fresh byte
  STA READHEADNYBBLE
  LDA READBYTEBUF
  LSR A
  LSR A
  LSR A
  LSR A
dcpreadnybbleendif:
  ; just-read nybble in Acc
  ; separate to NEWRUNVAL and RUNDIGIT
  TAX
  AND #$03
  STA NEWRUNVAL
  TXA
  LSR A
  LSR A
  BNE 2 ; skip next LDA if nonzero
  LDA #$04 ; replace 0 digit with 4
  STA RUNDIGIT
  ; is this a continuation of a run spec in progress?
  LDA NEWRUNVAL
  CMP RUNVAL
  BNE dcpwriterun
  ; add new digit to run length
  LDA RUNLENBYTES
  ; it's possible we read past the end of compressed data and found a
  ; matching run spec nybble by chance. a too-long last run isn't a problem,
  ; because we won't write past a page boundary, but we need a stop condition
  ; for reading garbage as a run spec. If computed run length meets or
  ; exceeds maximum (256 bytes), just stop reading and write the run.
  ASL A
  BCS dcprunlenoverflow
  ASL A
  BCS dcprunlenoverflow
  ADC RUNLENCRUMBS
  BCS dcprunlenoverflow
  STA RUNLENBYTES
  LDA RUNDIGIT
  STA RUNLENCRUMBS
  ; read another nybble
  JMP dcpreadnybble
dcprunlenoverflow:
  LDA #$04
  STA RUNLENCRUMBS
  LDA #$FF
  STA RUNLENBYTES ; 256 bytes is represented as 255 bytes and 4 crumbs
  ; fall through to write run
dcpwriterun:
  ; check if run length has reached zero
  ; this contition is evaluated at the top of the loop because reading the
  ; first nybble counts as non-matching and therefore triggers writing a
  ; zero-length run
  LDA RUNLENCRUMBS
  BNE dcpwriterunskip1
  LDA RUNLENBYTES
  BEQ dcpwriterundone
dcpwriterunskip1:
  ; output a crumb: shift RUNVAL into high bits of WRITEBYTEBUF
  ; (earlier output crumbs get shifted lower)
  LDA RUNVAL
  LSR A
  ROR WRITEBYTEBUF
  LSR A
  ROR WRITEBYTEBUF
  ; advance write head by one crumb
  LDA WRITEHEADCRUMB
  ADC #$01 ; if WRITEBYTEBUF was not already full, carry is clear
  CMP #$04
  BCC dcpwriterunskip2 ; do the following if WRITEBYTEBUF is full
  ; write byte from buffer
  LDA WRITEBYTEBUF
  STA (WRITEHEADBYTE),Y
  INC WRITEHEADBYTE
  BNE 1 ; if nonzero, skip next RTS
  RTS ; if zero, page is full, decompression is done
  ; INC DECODELEN ; not needed?
  LDA #$00 ; reset WRITEBYTEBUF and WRITEHEADCRUMB
  STA WRITEBYTEBUF
dcpwriterunskip2:
  STA WRITEHEADCRUMB
  ; decrement run length
  DEC RUNLENCRUMBS
  BPL dcpwriterun ; if RUNLENCRUMBS wraps around to >=128, perform borrow
  ; from RUNLENBYTES below; otherwise, continue writing run above.
  DEC RUNLENBYTES
  LDA #$03
  STA RUNLENCRUMBS
  BNE dcpwriterun ; BRA: zero flag cleared by LDA above
dcpwriterundone:
  ; now we need to retrieve the nonmatching nybble that triggered the run to
  ; be written, and set it up as the runspec in progress
  LDA NEWRUNVAL
  STA RUNVAL
  LDA RUNDIGIT
  STA RUNLENCRUMBS
  ; RUNLENBYTES should still be 0 at this point
  JMP dcpreadnybble ; this could be BNE as BRA because RUNDIGIT is always
  ; nonzero, but it seems to be too far for a branch to jump

fvmcchar:
; Subroutine: Copy one character via FVMC (page registers already set;
; character specified by setting X register to address within page)
; Side effects: Accumulator, X register clobbered
; Acc := 0
; X := (X & $0F) + $10
fvmccharcopyloop:
  STA $00,X
  INX
  TXA
  AND #$0F
  BNE fvmccharcopyloop
  RTS

fvmcpage:
; Subroutine: Copy one full page via FVMC (registers already set)
; Side effects: Accumulator clobbered.
; Acc := X
  JSR waitvscana
  TXA
  LDX #$00
fvmcpagecopyloop:
  STA $00,X
  INX
  BNE fvmcpagecopyloop
  STX FVMCSRC
  STX FVMCDEST
  TAX
  RTS

actoncontrolcode:
; Subroutine: Act on control code designated by Y (index into control code
; table, not actual control code)
; Side effects: Accumulator clobbered, Y register doubled
  TYA
  ASL
  TAY
  LDA controlcodetargets,Y
  STA SRSCRATCH+12
  LDA controlcodetargets+1,Y
  STA SRSCRATCH+13
  JMP (SRSCRATCH+12)

printch:
; Subroutine: Print a character identified by Accumulator, at current cursor
; location. If control code, act accordingly. Else, assert selected colors at
; current cursor location and advance cursor.
; Side effects: Y register clobbered.
NCONTROLCODES = 12
  LDY CONSFLAGS
  BMI printliteral0
  LDY #$00
controlcodeloop:
  CMP controlcodes,Y
  BEQ actoncontrolcode
  INY
  CPY #NCONTROLCODES
  BCC controlcodeloop
printliteral1:
  JSR putch
  PHA
  JSR putcolors
  JSR cursoradvance
  PLA
  RTS

printliteral0:
  PHA
  LDA CONSFLAGS
  AND #$7F
  STA CONSFLAGS
  PLA
  JMP printliteral1

printsetupliteral:
  PHA
  LDA CONSFLAGS
  ORA #$80
  STA CONSFLAGS
  PLA
  RTS

putch:
; Subroutine: Print a character identified by Accumulator, at current cursor
; location. Do not treat control codes specially.
; Side effects: X, Y registers clobbered.
  LDY #$00
  JSR waithscanx
  STA (TCURSORLO),Y
  RTS

putcolors:
; Subroutine: Assert selected colors at current cursor location.
; Side effects: Accumulator, X, Y registers clobbered.
  LDA #$00
  STA TCBLINK ; cursor will be hidden by this procedure
  JSR calccolorbytes
  JSR coptrcalc
  JSR calcrownybble
  STA CORNMASK
  EOR #$FF
  STA COKNMASK
  LDX #$00
putcolorswriteloop:
  STX SAVEX
  LDA COBYTES,X
  AND CORNMASK
  STA COBYTES,X
  JSR waithscanx
  LDA (COSRCPTR),Y
  AND COKNMASK
  LDX SAVEX
  ORA COBYTES,X
  JSR waithscanx
  STA (COSRCPTR),Y
  JSR coptradvance
  LDX SAVEX
  INX
  CPX #$05
  BCC putcolorswriteloop
  RTS

scrolldown2:
  LDA #$00
  STA CHDESTPTR+0
  LDA #$08
  STA CHSRCPTR+1
  STA CHDESTPTR+1
  STA CHSRCPTR+3
  STA CHDESTPTR+3
  LDA #$20
  STA CHDESTPTR+2
  LDA #$60
  STA CHSRCPTR+2
  LDA #$40
  STA CHSRCPTR+0
  CLC
  LDX #$00 ; color bitplane counter (doubled)
  LDY #$0A ; color destination / source pointer hi
sd2ptrinitloop:
  STA CODESTPTR+0,X
  ADC #$20
  STA COSRCPTR+0,X
  STY CODESTPTR+1,X
  STY COSRCPTR+1,X
  INX
  INX
  INY
  CPX #$0A
  BCC sd2ptrinitloop
  LDX #$00
  LDA VIDEOSTATE
  AND #$CC
  ORA #$02
  STA WSTARGET
sd2rowloop:
  LDY #$00
  STX SAVEX
sd2colloop:
  JSR waitscanx
  LDA (CHSRCPTR+0),Y
  STA (CHDESTPTR+0),Y
  JSR waitscanx
  LDA (CHSRCPTR+2),Y
  STA (CHDESTPTR+2),Y
  JSR waitscanx
  LDA (COSRCPTR+0),Y
  STA (CODESTPTR+0),Y
  JSR waitscanx
  LDA (COSRCPTR+2),Y
  STA (CODESTPTR+2),Y
  JSR waitscanx
  LDA (COSRCPTR+4),Y
  STA (CODESTPTR+4),Y
  JSR waitscanx
  LDA (COSRCPTR+6),Y
  STA (CODESTPTR+6),Y
  JSR waitscanx
  LDA (COSRCPTR+8),Y
  STA (CODESTPTR+8),Y
  INY
  CPY #$20
  BCC sd2colloop
  CLC
  LDA CHSRCPTR+0
  STA CHDESTPTR+0
  ORA #$20
  STA CHDESTPTR+2
  ADC #$20
  STA CHSRCPTR+0
  ORA #$20
  STA CHSRCPTR+2
  LDA CHSRCPTR+1
  STA CHDESTPTR+1
  STA CHDESTPTR+3
  ADC #$00
  STA CHSRCPTR+1
  STA CHSRCPTR+3
  LDX #$00
sd2coptrloop:
  LDA COSRCPTR+0,X
  STA CODESTPTR+0,X
  ADC #$20
  STA COSRCPTR+0,X
  LDA COSRCPTR+1,X
  STA CODESTPTR+1,X
  ADC #$00
  STA COSRCPTR+1,X
  INX
  INX
  CPX #$0A
  BCC sd2coptrloop
  LDX SAVEX
  INX
  CPX #$08
  BCC sd2rowloop
  ; clear bottom 2 rows
  LDX #$00
  JSR calccolorbytes
sd2clearloop:
  LDA #$20
  JSR waithscany
  STA $0A00,X
  STA $0A20,X
  LDA COBYTES+0
  JSR waithscany
  STA $0B40,X
  LDA COBYTES+1
  JSR waithscany
  STA $0C60,X
  LDA COBYTES+2
  JSR waithscany
  STA $0D80,X
  LDA COBYTES+3
  JSR waithscany
  STA $0EA0,X
  LDA COBYTES+4
  JSR waithscany
  STA $0FC0,X
  INX
  CPX #$20
  BCC sd2clearloop
  ;SEC Carry should be already set
  LDA TCURSORLO
  SBC #$40
  STA TCURSORLO
  LDA TCURSORHI
  SBC #$00
  STA TCURSORHI
  JMP cursorbackcheck

textbackspace:
  ; do nothing if cursor is in leftmost column
  LDA TCURSORLO
  AND #$1F
  BNE 1
  RTS
  JSR cursorleft
  ; fall through to textdelete

textdelete:
  PHA
  LDA TCURSORLO
  PHA
  AND #$1F
  TAY
  LDA TCURSORLO
  AND #$E0
  STA TCURSORLO
textdeleteshiftloop:
  INY
  CPY #$20
  BCS textdeleteshiftloopexit
  LDA (TCURSORLO),Y
  DEY
  STA (TCURSORLO),Y
  INY
  BNE textdeleteshiftloop ; BRA: Y is nonzero here
textdeleteshiftloopexit:
  DEY
  LDA #$20 ; put a space in last column
  STA (TCURSORLO),Y
  PLA ; restore cursor position
  STA TCURSORLO
  PLA ; restore Acc
  RTS

textinsert:
  PHA
  LDA TCURSORLO
  PHA
  AND #$1F
  TAY
  LDA TCURSORLO
  AND #$E0
  STA TCURSORLO
textinsertshiftloop:
  LDA (TCURSORLO),Y
  INY
  CPY #$20
  BCS textinsertshiftloopexit
  STA (TCURSORLO),Y
  BCC textinsertshiftloop ; BRA: carry clear this side of BCS branch
textinsertshiftloopexit:
  PLA ; restore cursor position
  STA TCURSORLO
  LDY #$00
  LDA #$20 ; put a space in current column
  STA (TCURSORLO),Y
  PLA ; restore Acc
  RTS


waitsubs:  .align 8
waithscanx:
; Subroutine: Wait for start of horizontal blanking interval after active
; scanline.
; Side effects: X register is clobbered.
  PHA
  LDA VIDEOSTATE
  AND #$CC
  ORA #$02
  TAX
  PLA
  CPX VIDEOSTATE
  BNE -5
  RTS

waithscany:
; Subroutine: Wait for start of horizontal blanking interval after active
; scanline.
; Side effects: Y register is clobbered.
  PHA
  LDA VIDEOSTATE
  AND #$CC
  ORA #$02
  TAY
  PLA
  CPY VIDEOSTATE
  BNE -5
  RTS

waitscanx:
; Subroutine: Wait for videostate stored in WSTARGET.
; Side effects: X register is clobbered
  LDX WSTARGET
  CPX VIDEOSTATE
  BNE -5
  RTS

waitvscana:
; Subroutine: Wait for start of vertical blanking interval.
; Side effects: Accumulator is clobbered.
  ; determine video flags to look for
  LDA VIDEOSTATE
  AND #$CC
  ORA #$20
  ; wait for start of vertical retrace
  CMP VIDEOSTATE
  BNE -5 ; CMP again
  RTS

nmicode: ; empty, because NMI not presently used
  RTI

  .org $FA40
datagfx:
  .incbin firmwaregfx.compressed
datalogocolors: .align 3
  .byte $CC,$CC,$8A,$8C,$CE,$EE,$EC,$CC
  .byte $AC,$AE,$EE,$EC,$C8,$C8,$AA,$CA
  .byte $8C,$8C,$EE,$EC,$CA,$EA,$EE,$CE
  .byte $EA,$EA,$CC,$CA,$AE,$AE,$88,$A8
  .byte $8A,$88,$A8,$AA,$A8,$88,$CE,$AE
datasystext0: .align 5
  .text ". \xFE\xFF \x80\x81 .  \x0E  \x0E  \x0E  \x0E  . \xFE\xFF \x80\x81 ."
datasystext2:
  .text "\x8F   Retro 6k Fantasy Computer  \x8F"
datasystext3:
  .text "\xF0     Entertainment System\x11    \xF0"
datasystext6:
  .text "   Please insert a cartridge>   "
datasystext7:
  .text "     F\xF7\xF8\xF9ware version 2031@     "
datasystext8:
  .text "\0142019`20 Maggie David \x86\x87\x88 Haynes"
datasyscolors:
  .byte $00,$81,$84,$0D,$02,$83,$86,$0F
  .byte $D0,$59,$5C,$DD,$D2,$5B,$5E,$DF
  .byte $20,$A1,$A4,$2D,$22,$A3,$A6,$2F
  .byte $F0,$79,$7C,$FD,$F2,$7B,$7E,$FF
initfontsrcpage:
  .byte $E4,$E5,$E6,$E7,$E3,$E2,$E1,$00
initfontdestpage:
  .byte $14,$15,$16,$17,$13,$12,$11,$00
controlcodes:
  ; CAUTION: Ensure NCONTROLCODES is defined earlier as the length of this list
  .byte $01,$04,$06,$07,$08,$09,$0A,$0C,$0D,$0E,$2C,$7F
controlcodetargets:
  .word printsetupliteral
  .word cursoradvance
  .word cursorleft
  .word beep
  .word textbackspace
  .word cursortab
  .word cursordown
  .word cursordown
  .word cursorreturn
  .word cursorup
  .word textinsert
  .word textdelete

; 6502 program counter initialization vectors
  .org $FFFA
  .word nmicode ; NMI vector, in firmware
  .word entry ; reset vector, in firmware
  .word $2010 ; interrupt request vector, in cartridge