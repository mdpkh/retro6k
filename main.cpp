#include <vector>
#include <cstring>
#include <filesystem>
#include <fstream>
#include <random>
#include <string>

#include <SDL.h>

#include "fake6502.h"
#include "main.h"

/*** SYSTEM GENERAL MEMORY: ***
8-bit RAM:  0x0000-0x00FF (can be accessed faster than memory locations with higher addresses)
Stack:      0x0100-0x01FF (location fixed by 6502 design)
User Input: 0x0200-0x027F (see below)
Sys Status: 0x0280-0x02FF (see below)
Device Out: 0x0300-0x037F (see below)
Sound Out:  0x0380-0x03BF (see below)
Misc Ctrl:  0x03C0-0x03FF (see below)
General:    0x0400-0x07FF (application specific)
 *** VIDEO MEMORY: ***
Characters: 0x0800-0x0A3F (32 bytes per row, 1 byte per cell: 0x800 + 0x20 * R + C)
Attributes: 0x0A40-0x0FDF (5 nonconsecutive nybbles (transpose; represents 4 5-bit attributes) per cell: 
                           0x0A40 + 0x120 * B + 0x10 * (R & 0x1E) + C + 1/2 * (R & 1))
Palette:    0x0FE0-0x0FFF (1 byte per attribute: 0x0FE0 + A)
Font:       0x1000-0x1FFF (16 bytes per glyph, 2 bytes per row, 2 bits per pixel:
                           0x1000 + 0x10 * G + 2 * Y + 1/4 * X)
 *** CARTRIDGE MEMORY: ***
RAM or ROM: 0x2000-0xBFFF (application-specific)
 *** SYSTEM ROM: ***
Bank C:     0xC000-0xCFFF (user expansion)
Bank D:     0xD000-0xDFFF (user expansion)
Bank E:     0xE000-0xEFFF (system font, user replaceable)
Bank F:     0xF000-0xFFFF (system firmware)

 *** INPUT DEVICES ***
User Input: 0x0200-0x027F
  Game Pads: 40, 41, 42, 43
  Keyboard (primary): 44
  Keyboard (low-level): 45
  Pointer X: 46
  Pointer Y: 47
Sys Status: 0x0280-0x02FF 
  Video Flags: FC
    03: Horizontal state: 00 active; 01 margin; 02 horz flyback start; 03 horz flyback in progress
	0C: Timing mode: 00 VGA; 04 PAL; 08 NTSC (set by user switch)
    30: Vertical state: 00 active scanline; 10 skipped scanline; 20 vert flyback start; 30 vert flyback in progress
	40: Scanline skip: 00 off; 40 on (set by cartridge jumper)
	80: Aspect ratio: 00 4:3; 80 16:9 (set by user switch)

  *** OUTPUT DEVICES ***
Device Out: 0x0300-0x037F 
Sound Out:  0x0380-0x03BF 
Misc Ctrl:  0x03C0-0x03FF 
  Fast Video Memory Copy Mode / Dest Page: F8
  Fast Video Memory Src Page: F9
  Video Interrupt Condition Flags: FC
*/
unsigned char* sysram;
unsigned char* syspflags;
constexpr unsigned char PF_TMASK = 0x03;
constexpr unsigned char PF_TFLOATING = 0x00;
constexpr unsigned char PF_TROM = 0x01;
constexpr unsigned char PF_TRAM = 0x02;
constexpr unsigned char PF_TNONVOL = 0x03;
constexpr unsigned char PF_BANKSWITCHED = 0x04;
bool cartridgeinserted = false;
bool scanlinedirty[576];
bool videobusy;
unsigned char videostate;
unsigned char keypressregister;
unsigned short soundfreqregister[4];
unsigned char soundvolregister[4];
unsigned short menubeepdur;
unsigned short menubeepfreq;
bool menuhassound = false;
constexpr int dlogbits = 18;
constexpr int dlogidxmask = (2 << dlogbits) - 1;
dlogentry debuglog[2 << dlogbits];
int debuglogstart = 0;
int debuglogend = 1;
int debuglogexpectargs = 0;
dlogentry* partialinst = nullptr;
std::random_device seedgen;
std::mt19937 floatgen;
char* cartpath;
char* savepath;
char* screencappath;

int pixwidth;
int pixheight;
SDL_Window* mainwindow;
SDL_Surface* cellcanvas;
SDL_Surface* framebuffer;
SDL_AudioSpec soundspec;
SDL_AudioDeviceID sounddev;
unsigned int UE_RESETCPU;

inline void DisplayHexByte(char* dest, char val)
{
	const char nybbles[16] = {
		0x30, 0x31, 0x32, 0x33,
		0x34, 0x35, 0x36, 0x37,
		0x38, 0x39, 0x41, 0x42,
		0x43, 0x44, 0x45, 0x46,
	};
	*dest = nybbles[(val >> 4) & 0xf];
	*++dest = nybbles[val & 0xf];
}

inline void DisplayArgs(char* dest, unsigned char opc, char* args, char** end)
{
	const enum amode : char {
		AM_IMP,
		AM_ACC,
		AM_IMM,
		AM_REL,
		AM_ZP,
		AM_ZPX,
		AM_ZPY,
		AM_INDX,
		AM_INDY,
		AM_ABS,
		AM_ABSX,
		AM_ABSY,
		AM_IND
	} amodes[256] = {
		AM_IMP, AM_INDX, AM_IMP, AM_INDX,  AM_ZP,  AM_ZP,  AM_ZP,  AM_ZP, AM_IMP,  AM_IMM, AM_ACC,  AM_IMM,  AM_ABS,  AM_ABS,  AM_ABS,  AM_ABS,
		AM_REL, AM_INDY, AM_IMP, AM_INDY, AM_ZPX, AM_ZPX, AM_ZPX, AM_ZPX, AM_IMP, AM_ABSY, AM_IMP, AM_ABSY, AM_ABSX, AM_ABSX, AM_ABSX, AM_ABSX,
		AM_ABS, AM_INDX, AM_IMP, AM_INDX,  AM_ZP,  AM_ZP,  AM_ZP,  AM_ZP, AM_IMP,  AM_IMM, AM_ACC,  AM_IMM,  AM_ABS,  AM_ABS,  AM_ABS,  AM_ABS,
		AM_REL, AM_INDY, AM_IMP, AM_INDY, AM_ZPX, AM_ZPX, AM_ZPX, AM_ZPX, AM_IMP, AM_ABSY, AM_IMP, AM_ABSY, AM_ABSX, AM_ABSX, AM_ABSX, AM_ABSX,
		AM_IMP, AM_INDX, AM_IMP, AM_INDX,  AM_ZP,  AM_ZP,  AM_ZP,  AM_ZP, AM_IMP,  AM_IMM, AM_ACC,  AM_IMM,  AM_ABS,  AM_ABS,  AM_ABS,  AM_ABS,
		AM_REL, AM_INDY, AM_IMP, AM_INDY, AM_ZPX, AM_ZPX, AM_ZPX, AM_ZPX, AM_IMP, AM_ABSY, AM_IMP, AM_ABSY, AM_ABSX, AM_ABSX, AM_ABSX, AM_ABSX,
		AM_IMP, AM_INDX, AM_IMP, AM_INDX,  AM_ZP,  AM_ZP,  AM_ZP,  AM_ZP, AM_IMP,  AM_IMM, AM_ACC,  AM_IMM,  AM_IND,  AM_ABS,  AM_ABS,  AM_ABS,
		AM_REL, AM_INDY, AM_IMP, AM_INDY, AM_ZPX, AM_ZPX, AM_ZPX, AM_ZPX, AM_IMP, AM_ABSY, AM_IMP, AM_ABSY, AM_ABSX, AM_ABSX, AM_ABSX, AM_ABSX,
		AM_IMM, AM_INDX, AM_IMM, AM_INDX,  AM_ZP,  AM_ZP,  AM_ZP,  AM_ZP, AM_IMP,  AM_IMM, AM_IMP,  AM_IMM,  AM_ABS,  AM_ABS,  AM_ABS,  AM_ABS,
		AM_REL, AM_INDY, AM_IMP, AM_INDY, AM_ZPX, AM_ZPX, AM_ZPY, AM_ZPY, AM_IMP, AM_ABSY, AM_IMP, AM_ABSY, AM_ABSX, AM_ABSX, AM_ABSY, AM_ABSY,
		AM_IMM, AM_INDX, AM_IMM, AM_INDX,  AM_ZP,  AM_ZP,  AM_ZP,  AM_ZP, AM_IMP,  AM_IMM, AM_IMP,  AM_IMM,  AM_ABS,  AM_ABS,  AM_ABS,  AM_ABS,
		AM_REL, AM_INDY, AM_IMP, AM_INDY, AM_ZPX, AM_ZPX, AM_ZPY, AM_ZPY, AM_IMP, AM_ABSY, AM_IMP, AM_ABSY, AM_ABSX, AM_ABSX, AM_ABSY, AM_ABSY,
		AM_IMM, AM_INDX, AM_IMM, AM_INDX,  AM_ZP,  AM_ZP,  AM_ZP,  AM_ZP, AM_IMP,  AM_IMM, AM_IMP,  AM_IMM,  AM_ABS,  AM_ABS,  AM_ABS,  AM_ABS,
		AM_REL, AM_INDY, AM_IMP, AM_INDY, AM_ZPX, AM_ZPX, AM_ZPX, AM_ZPX, AM_IMP, AM_ABSY, AM_IMP, AM_ABSY, AM_ABSX, AM_ABSX, AM_ABSX, AM_ABSX,
		AM_IMM, AM_INDX, AM_IMM, AM_INDX,  AM_ZP,  AM_ZP,  AM_ZP,  AM_ZP, AM_IMP,  AM_IMM, AM_IMP,  AM_IMM,  AM_ABS,  AM_ABS,  AM_ABS,  AM_ABS,
		AM_REL, AM_INDY, AM_IMP, AM_INDY, AM_ZPX, AM_ZPX, AM_ZPX, AM_ZPX, AM_IMP, AM_ABSY, AM_IMP, AM_ABSY, AM_ABSX, AM_ABSX, AM_ABSX, AM_ABSX 
	};
	switch (amodes[opc])
	{
	case AM_IMP:
		*end = dest;
		break;
	case AM_ACC:
		*dest = 0x41;
		*++dest = 0x20;
		*end = dest + 1;
		break;
	case AM_IMM:
		*dest = 0x23;
		*++dest = 0x24;
		DisplayHexByte(++dest, args[0]);
		dest += 2;
		*dest = 0x20;
		*end = dest + 1;
		break;
	case AM_REL:
	case AM_ZP:
		*dest = 0x24;
		DisplayHexByte(++dest, args[0]);
		dest += 2;
		*dest = 0x20;
		*end = dest + 1;
		break;
	case AM_ZPX:
		*dest = 0x24;
		DisplayHexByte(++dest, args[0]);
		dest += 2;
		*dest = 0x2c;
		*++dest = 0x58;
		*++dest = 0x20;
		*end = dest + 1;
		break;
	case AM_ZPY:
		*dest = 0x24;
		DisplayHexByte(++dest, args[0]);
		dest += 2;
		*dest = 0x2c;
		*++dest = 0x59;
		*++dest = 0x20;
		*end = dest + 1;
		break;
	case AM_INDX:
		*dest = 0x28;
		*++dest = 0x24;
		DisplayHexByte(++dest, args[0]);
		dest += 2;
		*dest = 0x2c;
		*++dest = 0x58;
		*++dest = 0x29;
		*++dest = 0x20;
		*end = dest + 1;
		break;
	case AM_INDY:
		*dest = 0x28;
		*++dest = 0x24;
		DisplayHexByte(++dest, args[0]);
		dest += 2;
		*dest = 0x29;
		*++dest = 0x2c;
		*++dest = 0x59;
		*++dest = 0x20;
		*end = dest + 1;
		break;
	case AM_ABS:
		*dest = 0x24;
		DisplayHexByte(++dest, args[1]);
		dest += 2;
		DisplayHexByte(dest, args[0]);
		dest += 2;
		*dest = 0x20;
		*end = dest + 1;
		break;
	case AM_ABSX:
		*dest = 0x24;
		DisplayHexByte(++dest, args[1]);
		dest += 2;
		DisplayHexByte(dest, args[0]);
		dest += 2;
		*dest = 0x2c;
		*++dest = 0x58;
		*++dest = 0x20;
		*end = dest + 1;
		break;
	case AM_ABSY:
		*dest = 0x24;
		DisplayHexByte(++dest, args[1]);
		dest += 2;
		DisplayHexByte(dest, args[0]);
		dest += 2;
		*dest = 0x2c;
		*++dest = 0x59;
		*++dest = 0x20;
		*end = dest + 1;
		break;
	case AM_IND:
		*dest = 0x28;
		*++dest = 0x24;
		DisplayHexByte(++dest, args[1]);
		dest += 2;
		DisplayHexByte(dest, args[0]);
		dest += 2;
		*dest = 0x29;
		*++dest = 0x20;
		*end = dest + 1;
		break;
	}
}

inline void DisplayHexWord(char* dest, short val)
{
	const char nybbles[16] = {
		0x30, 0x31, 0x32, 0x33,
		0x34, 0x35, 0x36, 0x37,
		0x38, 0x39, 0x41, 0x42,
		0x43, 0x44, 0x45, 0x46,
	};
	*dest = nybbles[(val >> 12) & 0xf];
	*++dest = nybbles[(val >> 8) & 0xf];
	*++dest = nybbles[(val >> 4) & 0xf];
	*++dest = nybbles[val & 0xf];
}

inline void DisplayMemType(char* dest, unsigned char pf)
{
	const char typewords[12] = {
		'N',0x7f, 'C',
		'R', 'O', 'M',
		'R', 'A', 'M',
		'N', 'V', 'M',
	};
	char* src = (char*)typewords + 3 * (pf & PF_TMASK);
	*dest = *src;
	*++dest = *++src;
	*++dest = *++src;
}

inline void DisplayOpcode(char* dest, unsigned char opc)
{
	const char mnemonics[768] = {
		0x42, 0x52, 0x4B, 0x4F, 0x52, 0x41, 0x3F, 0x3F, 0x3F, 0x53, 0x4C, 0x4F,
		0x3F, 0x3F, 0x3F, 0x4F, 0x52, 0x41, 0x41, 0x53, 0x4C, 0x53, 0x4C, 0x4F,
		0x50, 0x48, 0x50, 0x4F, 0x52, 0x41, 0x41, 0x53, 0x4C, 0x3F, 0x3F, 0x3F,
		0x3F, 0x3F, 0x3F, 0x4F, 0x52, 0x41, 0x41, 0x53, 0x4C, 0x53, 0x4C, 0x4F,
		0x42, 0x50, 0x4C, 0x4F, 0x52, 0x41, 0x3F, 0x3F, 0x3F, 0x53, 0x4C, 0x4F,
		0x3F, 0x3F, 0x3F, 0x4F, 0x52, 0x41, 0x41, 0x53, 0x4C, 0x53, 0x4C, 0x4F,
		0x43, 0x4C, 0x43, 0x4F, 0x52, 0x41, 0x3F, 0x3F, 0x3F, 0x53, 0x4C, 0x4F,
		0x3F, 0x3F, 0x3F, 0x4F, 0x52, 0x41, 0x41, 0x53, 0x4C, 0x53, 0x4C, 0x4F,
		0x4A, 0x53, 0x52, 0x41, 0x4E, 0x44, 0x3F, 0x3F, 0x3F, 0x52, 0x4C, 0x41,
		0x42, 0x49, 0x54, 0x41, 0x4E, 0x44, 0x52, 0x4F, 0x4C, 0x52, 0x4C, 0x41,
		0x50, 0x4C, 0x50, 0x41, 0x4E, 0x44, 0x52, 0x4F, 0x4C, 0x3F, 0x3F, 0x3F,
		0x42, 0x49, 0x54, 0x41, 0x4E, 0x44, 0x52, 0x4F, 0x4C, 0x52, 0x4C, 0x41,
		0x42, 0x4D, 0x49, 0x41, 0x4E, 0x44, 0x3F, 0x3F, 0x3F, 0x52, 0x4C, 0x41,
		0x3F, 0x3F, 0x3F, 0x41, 0x4E, 0x44, 0x52, 0x4F, 0x4C, 0x52, 0x4C, 0x41,
		0x53, 0x45, 0x43, 0x41, 0x4E, 0x44, 0x3F, 0x3F, 0x3F, 0x52, 0x4C, 0x41,
		0x3F, 0x3F, 0x3F, 0x41, 0x4E, 0x44, 0x52, 0x4F, 0x4C, 0x52, 0x4C, 0x41,
		0x52, 0x54, 0x49, 0x45, 0x4F, 0x52, 0x3F, 0x3F, 0x3F, 0x53, 0x52, 0x45,
		0x3F, 0x3F, 0x3F, 0x45, 0x4F, 0x52, 0x4C, 0x53, 0x52, 0x53, 0x52, 0x45,
		0x50, 0x48, 0x41, 0x45, 0x4F, 0x52, 0x4C, 0x53, 0x52, 0x3F, 0x3F, 0x3F,
		0x4A, 0x4D, 0x50, 0x45, 0x4F, 0x52, 0x4C, 0x53, 0x52, 0x53, 0x52, 0x45,
		0x42, 0x56, 0x43, 0x45, 0x4F, 0x52, 0x3F, 0x3F, 0x3F, 0x53, 0x52, 0x45,
		0x3F, 0x3F, 0x3F, 0x45, 0x4F, 0x52, 0x4C, 0x53, 0x52, 0x53, 0x52, 0x45,
		0x43, 0x4C, 0x49, 0x45, 0x4F, 0x52, 0x3F, 0x3F, 0x3F, 0x53, 0x52, 0x45,
		0x3F, 0x3F, 0x3F, 0x45, 0x4F, 0x52, 0x4C, 0x53, 0x52, 0x53, 0x52, 0x45,
		0x52, 0x54, 0x53, 0x41, 0x44, 0x43, 0x3F, 0x3F, 0x3F, 0x52, 0x52, 0x41,
		0x3F, 0x3F, 0x3F, 0x41, 0x44, 0x43, 0x52, 0x4F, 0x52, 0x52, 0x52, 0x41,
		0x50, 0x4C, 0x41, 0x41, 0x44, 0x43, 0x52, 0x4F, 0x52, 0x3F, 0x3F, 0x3F,
		0x4A, 0x4D, 0x50, 0x41, 0x44, 0x43, 0x52, 0x4F, 0x52, 0x52, 0x52, 0x41,
		0x42, 0x56, 0x53, 0x41, 0x44, 0x43, 0x3F, 0x3F, 0x3F, 0x52, 0x52, 0x41,
		0x3F, 0x3F, 0x3F, 0x41, 0x44, 0x43, 0x52, 0x4F, 0x52, 0x52, 0x52, 0x41,
		0x53, 0x45, 0x49, 0x41, 0x44, 0x43, 0x3F, 0x3F, 0x3F, 0x52, 0x52, 0x41,
		0x3F, 0x3F, 0x3F, 0x41, 0x44, 0x43, 0x52, 0x4F, 0x52, 0x52, 0x52, 0x41,
		0x3F, 0x3F, 0x3F, 0x53, 0x54, 0x41, 0x3F, 0x3F, 0x3F, 0x53, 0x41, 0x58,
		0x53, 0x54, 0x59, 0x53, 0x54, 0x41, 0x53, 0x54, 0x58, 0x53, 0x41, 0x58,
		0x44, 0x45, 0x59, 0x3F, 0x3F, 0x3F, 0x54, 0x58, 0x41, 0x3F, 0x3F, 0x3F,
		0x53, 0x54, 0x59, 0x53, 0x54, 0x41, 0x53, 0x54, 0x58, 0x53, 0x41, 0x58,
		0x42, 0x43, 0x43, 0x53, 0x54, 0x41, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
		0x53, 0x54, 0x59, 0x53, 0x54, 0x41, 0x53, 0x54, 0x58, 0x53, 0x41, 0x58,
		0x54, 0x59, 0x41, 0x53, 0x54, 0x41, 0x54, 0x58, 0x53, 0x3F, 0x3F, 0x3F,
		0x3F, 0x3F, 0x3F, 0x53, 0x54, 0x41, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
		0x4C, 0x44, 0x59, 0x4C, 0x44, 0x41, 0x4C, 0x44, 0x58, 0x4C, 0x41, 0x58,
		0x4C, 0x44, 0x59, 0x4C, 0x44, 0x41, 0x4C, 0x44, 0x58, 0x4C, 0x41, 0x58,
		0x54, 0x41, 0x59, 0x4C, 0x44, 0x41, 0x54, 0x41, 0x58, 0x3F, 0x3F, 0x3F,
		0x4C, 0x44, 0x59, 0x4C, 0x44, 0x41, 0x4C, 0x44, 0x58, 0x4C, 0x41, 0x58,
		0x42, 0x43, 0x53, 0x4C, 0x44, 0x41, 0x3F, 0x3F, 0x3F, 0x4C, 0x41, 0x58,
		0x4C, 0x44, 0x59, 0x4C, 0x44, 0x41, 0x4C, 0x44, 0x58, 0x4C, 0x41, 0x58,
		0x43, 0x4C, 0x56, 0x4C, 0x44, 0x41, 0x54, 0x53, 0x58, 0x4C, 0x41, 0x58,
		0x4C, 0x44, 0x59, 0x4C, 0x44, 0x41, 0x4C, 0x44, 0x58, 0x4C, 0x41, 0x58,
		0x43, 0x50, 0x59, 0x43, 0x4D, 0x50, 0x3F, 0x3F, 0x3F, 0x44, 0x43, 0x50,
		0x43, 0x50, 0x59, 0x43, 0x4D, 0x50, 0x44, 0x45, 0x43, 0x44, 0x43, 0x50,
		0x49, 0x4E, 0x59, 0x43, 0x4D, 0x50, 0x44, 0x45, 0x58, 0x3F, 0x3F, 0x3F,
		0x43, 0x50, 0x59, 0x43, 0x4D, 0x50, 0x44, 0x45, 0x43, 0x44, 0x43, 0x50,
		0x42, 0x4E, 0x45, 0x43, 0x4D, 0x50, 0x3F, 0x3F, 0x3F, 0x44, 0x43, 0x50,
		0x3F, 0x3F, 0x3F, 0x43, 0x4D, 0x50, 0x44, 0x45, 0x43, 0x44, 0x43, 0x50,
		0x43, 0x4C, 0x44, 0x43, 0x4D, 0x50, 0x3F, 0x3F, 0x3F, 0x44, 0x43, 0x50,
		0x3F, 0x3F, 0x3F, 0x43, 0x4D, 0x50, 0x44, 0x45, 0x43, 0x44, 0x43, 0x50,
		0x43, 0x50, 0x58, 0x53, 0x42, 0x43, 0x3F, 0x3F, 0x3F, 0x49, 0x53, 0x42,
		0x43, 0x50, 0x58, 0x53, 0x42, 0x43, 0x49, 0x4E, 0x43, 0x49, 0x53, 0x42,
		0x49, 0x4E, 0x58, 0x53, 0x42, 0x43, 0x4E, 0x4F, 0x50, 0x53, 0x42, 0x43,
		0x43, 0x50, 0x58, 0x53, 0x42, 0x43, 0x49, 0x4E, 0x43, 0x49, 0x53, 0x42,
		0x42, 0x45, 0x51, 0x53, 0x42, 0x43, 0x3F, 0x3F, 0x3F, 0x49, 0x53, 0x42,
		0x3F, 0x3F, 0x3F, 0x53, 0x42, 0x43, 0x49, 0x4E, 0x43, 0x49, 0x53, 0x42,
		0x53, 0x45, 0x44, 0x53, 0x42, 0x43, 0x3F, 0x3F, 0x3F, 0x49, 0x53, 0x42,
		0x3F, 0x3F, 0x3F, 0x53, 0x42, 0x43, 0x49, 0x4E, 0x43, 0x49, 0x53, 0x42
	};
	char* src = (char*)mnemonics + 3 * opc;
	*dest = *src;
	*++dest = *++src;
	*++dest = *++src;
}

void DrawText(const char* text, int &x, const int y0, unsigned char fg, unsigned char bg, SDL_Surface* destsurf)
{
	unsigned char c[2] = { bg, fg };
	while (*text)
	{
		int gw = hifont[(unsigned char)*text].w;
		unsigned short gbits[16];
		for (unsigned short* src = (unsigned short*)hifont[(unsigned char)*text].bmp, * dst = gbits; src < hifont[(unsigned char)*text].bmp + 16; ++src, ++dst)
			*dst = *src;
		unsigned char* rowstart = (unsigned char*)destsurf->pixels + destsurf->pitch * y0 + x;
		for (int gy = 0; gy < 16; ++gy)
		{
			for (int gx = 0; gx < gw; ++gx)
			{
				rowstart[gx] = c[gbits[gy] & 1];
				gbits[gy] >>= 1;
			}
			rowstart += destsurf->pitch;
		}
		x += gw;
		++text;
	}
}

inline void DrawTextC(const char* text, const int x0, const int y0, unsigned char fg, unsigned char bg, SDL_Surface* destsurf)
{
	int tx0 = x0;
	DrawText(text, tx0, y0, fg, bg, destsurf);
}

int TextWidth(const char* text)
{
	int w = 0;
	while (*text)
	{
		w += hifont[(unsigned char)*text].w;
		++text;
	}
	return w;
}

int SetHWPalette(SDL_Palette* dstpal)
{
	SDL_Color d[256];
	for (int j = 0; j < 256; ++j)
	{
		d[j].a = 255;
		int i = ((j & 0x8) >> 2 | (j & 0x80) >> 7) * 0x11;
		d[j].r = ((j & 0x4) >> 1 | (j & 0x40) >> 6) * 0x44 | i;
		d[j].g = ((j & 0x2) | (j & 0x20) >> 5) * 0x44 | i;
		d[j].b = ((j & 0x1) << 1 | (j & 0x10) >> 4) * 0x44 | i;
	}
	return SDL_SetPaletteColors(dstpal, d, 0, 256);
}

void EjectCartridge()
{
	for (int p = 0x20; p < 0xc0; ++p)
		syspflags[p] = PF_TFLOATING;
	cartridgeinserted = false;
}

dlogentry* ExtendLog(dlogentry::dletype etype)
{
	if (debuglogend == debuglogstart)
	{
		++debuglogstart;
		debuglogstart &= dlogidxmask;
	}
	debuglog[debuglogstart].entrytype = dlogentry::dletype::LT_START;
	debuglog[debuglogend].entrytype = etype;
	dlogentry* newentry = debuglog + debuglogend;
	++debuglogend;
	debuglogend &= dlogidxmask;
	return newentry;
}

void GenerateAudio(void* userdata, Uint8* stream, int len) //callback to fill audio buffer
{
	if (!menuhassound)
	{
		static unsigned short phase[4];
		for (; len > 0; len -= soundspec.channels)
		{
			phase[0] += soundfreqregister[0];
			phase[1] += soundfreqregister[1];
			phase[2] += soundfreqregister[2];
			phase[3] += soundfreqregister[3];
			if (phase[0] > soundspec.freq)
				phase[0] -= soundspec.freq;
			if (phase[1] > soundspec.freq)
				phase[1] -= soundspec.freq;
			if (phase[2] > soundspec.freq)
				phase[2] -= soundspec.freq;
			if (phase[3] > soundspec.freq)
				phase[3] -= soundspec.freq;
			*stream = soundspec.silence
				+ (phase[0] < (soundspec.freq >> 1)) * ((soundvolregister[0] & 0xf0) >> 2)
				- (phase[1] < (soundspec.freq >> 1)) * ((soundvolregister[1] & 0xf0) >> 2)
				+ (phase[2] < (soundspec.freq >> 1)) * ((soundvolregister[2] & 0xf0) >> 2)
				- (phase[3] < (soundspec.freq >> 1)) * ((soundvolregister[3] & 0xf0) >> 2);
			++stream;
			*stream = soundspec.silence
				+ (phase[0] < (soundspec.freq >> 1)) * ((soundvolregister[0] & 0x0f) << 2)
				- (phase[1] < (soundspec.freq >> 1)) * ((soundvolregister[1] & 0x0f) << 2)
				+ (phase[2] < (soundspec.freq >> 1)) * ((soundvolregister[2] & 0x0f) << 2)
				- (phase[3] < (soundspec.freq >> 1)) * ((soundvolregister[3] & 0x0f) << 2);
			++stream;
		}
	}
	else
	{
		static unsigned short phase;
		for (; len > 0; len -= soundspec.channels)
		{
			if (menubeepdur)
			{
				phase += menubeepfreq;
				--menubeepdur;
			}
			if (phase > soundspec.freq)
				phase -= soundspec.freq;
			*stream = soundspec.silence + ((phase < (soundspec.freq >> 1)) << 4);
			++stream;
			*stream = soundspec.silence + ((phase < (soundspec.freq >> 1)) << 4);
			++stream;
		}
	}
}

void RoundWinCorners(SDL_Surface* destsurf, unsigned int key, unsigned int bg, unsigned int fg)
{
#define r0 wincornercliprect[i]
	for (int i = 0; i < NWINCORNERCLIPRECTS; ++i)
	{
		SDL_Rect r1 = wincornercliprect[i];
		SDL_Rect r2 = wincornercliprect[i];
		SDL_Rect r3 = wincornercliprect[i];
		r1.x = r3.x = destsurf->w - r0.x - r0.w;
		r2.y = r3.y = destsurf->h - r0.y - r0.h;
		SDL_FillRect(destsurf, &r0, key);
		SDL_FillRect(destsurf, &r1, key);
		SDL_FillRect(destsurf, &r2, key);
		SDL_FillRect(destsurf, &r3, key);
	}
#undef r0
#define r0 wincornerborder0rect[i]
	for (int i = 0; i < NWINCORNERBORDER0RECTS; ++i)
	{
		SDL_Rect r1 = wincornerborder0rect[i];
		SDL_Rect r2 = wincornerborder0rect[i];
		SDL_Rect r3 = wincornerborder0rect[i];
		r1.x = r3.x = destsurf->w - r0.x - r0.w;
		r2.y = r3.y = destsurf->h - r0.y - r0.h;
		SDL_FillRect(destsurf, &r0, bg);
		SDL_FillRect(destsurf, &r1, bg);
		SDL_FillRect(destsurf, &r2, bg);
		SDL_FillRect(destsurf, &r3, bg);
	}
#undef r0
#define r0 wincornerborder1rect[i]
	for (int i = 0; i < NWINCORNERBORDER1RECTS; ++i)
	{
		SDL_Rect r2 = wincornerborder1rect[i];
		SDL_Rect r3 = wincornerborder1rect[i];
		r3.x        = destsurf->w - r0.x - r0.w;
		r2.y = r3.y = destsurf->h - r0.y - r0.h;
		SDL_FillRect(destsurf, &r2, fg);
		SDL_FillRect(destsurf, &r3, fg);
	}
#undef r0
}

void PaintWindow(SDL_Surface* win, unsigned int bg, unsigned int acc, const char* title, unsigned int tc)
{
	SDL_Rect boxrect;
	boxrect = { 0, 0, win->w, 1 };
	SDL_FillRect(win, &boxrect, bg);
	boxrect.y = win->h - 1;
	SDL_FillRect(win, &boxrect, bg);
	boxrect = { 0, 0, 1, win->h };
	SDL_FillRect(win, &boxrect, bg);
	boxrect.x = win->w - 1;
	SDL_FillRect(win, &boxrect, bg);
	boxrect = { 2, 19, win->w - 4, win->h - 21 };
	SDL_FillRect(win, &boxrect, bg);
	boxrect = { 1, 19, 1, win->h - 20 };
	SDL_FillRect(win, &boxrect, acc);
	boxrect.x = win->w - 2;
	SDL_FillRect(win, &boxrect, acc);
	boxrect = { 1, win->h - 2, win->w - 2, 1 };
	SDL_FillRect(win, &boxrect, acc);
	int tx0 = (win->w - TextWidth(title)) >> 1;
	boxrect = { 1, 1, win->w - 2, 18 };
	SDL_FillRect(win, &boxrect, acc);
	boxrect.h = 1;
	boxrect.y = 5;
	SDL_FillRect(win, &boxrect, darkercolor[acc]);
	boxrect.y = 6;
	SDL_FillRect(win, &boxrect, lightercolor[acc]);
	boxrect.y = 12;
	SDL_FillRect(win, &boxrect, darkercolor[acc]);
	boxrect.y = 13;
	SDL_FillRect(win, &boxrect, lightercolor[acc]);
	DrawText(title, tx0, 2, tc, acc, win);
	uint32_t k;
	SDL_GetColorKey(win, &k);
	if (k != 0xffffffff)
		RoundWinCorners(win, k, bg, acc);
}

inline void UIBeepMoveSel()
{
	menubeepdur = 2205;
	menubeepfreq = 440;
}

inline void UIBeepTakeAction()
{
	menubeepdur = 2205;
	menubeepfreq = 880;
}

inline void UIBeepUnavailable()
{
	menubeepdur = 8820;
	menubeepfreq = 55;
}

void DrawLogo(int x0, int y0, SDL_Surface* destsurf) {
	char* sptr = (char*)aboutlogopixels;
	char* rptr = (char*)(destsurf->pixels) + y0 * destsurf->pitch + x0;
	for (int y = 0; y < 27; ++y)
	{
		char* dptr = rptr;
		for (int x = 0; x < 29; ++x)
		{
			*dptr++ = *sptr++;
		}
		rptr += destsurf->pitch;
	}
}

void DoAbout() {
	SDL_Surface* winbuffer = SDL_CreateRGBSurfaceWithFormat(
		0,
		377,
		144,
		8,
		SDL_PIXELFORMAT_INDEX8);
	SDL_SetSurfaceBlendMode(winbuffer, SDL_BLENDMODE_BLEND);
	SDL_SetColorKey(winbuffer, true, 0xf9);
	SDL_Surface* mwsurface = SDL_GetWindowSurface(mainwindow);
	SDL_SetSurfaceBlendMode(mwsurface, SDL_BLENDMODE_NONE);
	SDL_Surface* restorescreen = SDL_CreateRGBSurfaceWithFormat(
		0,
		winbuffer->w,
		winbuffer->h,
		mwsurface->format->BitsPerPixel,
		SDL_MasksToPixelFormatEnum(
			mwsurface->format->BitsPerPixel,
			mwsurface->format->Rmask,
			mwsurface->format->Gmask,
			mwsurface->format->Bmask,
			mwsurface->format->Amask));
	if (!winbuffer || !restorescreen)
	{
		SDL_Log("Could not create menu display buffers: %s", SDL_GetError());
		return;
	}
	SDL_SetSurfaceBlendMode(restorescreen, SDL_BLENDMODE_NONE);
	SDL_Rect winpos;
	winpos.w = winbuffer->w;
	winpos.h = winbuffer->h;
	SDL_GetWindowSize(mainwindow, &winpos.x, &winpos.y);
	winpos.x -= winpos.w;
	winpos.y -= winpos.h;
	winpos.x >>= 1;
	winpos.y *= 3;
	winpos.y >>= 2;
	SetHWPalette(winbuffer->format->palette);
	SDL_UpdateWindowSurface(mainwindow);
	SDL_BlitSurface(mwsurface, &winpos, restorescreen, NULL);
	PaintWindow(winbuffer, 0xff, 0x4d, "About Retro 6k", 0xff);
	const char* abouttext[6] = {
		"Retro 6k designed by Maggie\220David",
		"P.\220K. Haynes in 2019\22620.",
		"",
		"Emulator v1.1990 \2512019\22620 Maggie\220David P.\220K.",
		"Haynes. Includes public domain 6502 emulator",
		"core written by Mike Chambers in 2011."
	};
	int tx0 = 0;
	for (int i = 0; i < 6; ++i)
	{
		int lw = TextWidth(abouttext[i]);
		if (lw > tx0)
			tx0 = lw;
	}
	tx0 = (winpos.w - tx0) >> 1;
	int y0 = (winpos.h + 20 - 18 * 6) >> 1;
	for (int i = 0, x = tx0, y = y0; i < 6; ++i, x = tx0, y += 18)
	{
		DrawText(abouttext[i], x, y, 0x00, 0xff, winbuffer);
	}
	DrawLogo(winpos.w - tx0 - 30, y0 + 3, winbuffer);
	SDL_Rect animrect = winpos;
	SDL_Rect menurect = { 0, 0, winpos.w, winpos.h };
	for (int t = 1; t <= 8; ++t)
	{
		SDL_SetSurfaceAlphaMod(winbuffer, t * 31);
		animrect.w = winpos.w * t / 8;
		menurect.w = animrect.w;
		animrect.x = (mwsurface->w - animrect.w) >> 1;
		SDL_BlitSurface(restorescreen, NULL, mwsurface, &winpos);
		SDL_BlitSurface(winbuffer, &menurect, mwsurface, &animrect);
		SDL_UpdateWindowSurface(mainwindow);
		SDL_Delay(16);
	}
	while (true)
	{
		SDL_Event event;
		while (SDL_PollEvent(&event))
		{
			SDL_Event newevent;
			switch (event.type)
			{
			case SDL_KEYDOWN:
				goto exitabout;
				break;
			case SDL_QUIT:
				newevent.type = SDL_QUIT;
				SDL_PushEvent(&newevent);
				goto exitabout;
			}
		}
		SDL_Delay(16);
	}
exitabout:
	for (int t = 7; t > 0; --t)
	{
		SDL_SetSurfaceAlphaMod(winbuffer, t * 31);
		animrect.h = winpos.h * t / 8;
		menurect.h = animrect.h;
		menurect.y = winpos.h - animrect.h;
		animrect.y = ((mwsurface->h - animrect.h) * 3) >> 2;
		SDL_BlitSurface(restorescreen, NULL, mwsurface, &winpos);
		SDL_BlitSurface(winbuffer, &menurect, mwsurface, &animrect);
		SDL_UpdateWindowSurface(mainwindow);
		SDL_Delay(16);
	}
	SDL_BlitSurface(restorescreen, NULL, mwsurface, &winpos);
	SDL_FreeSurface(restorescreen);
	SDL_FreeSurface(winbuffer);
}

void DoDebugger() {
	SDL_Surface* winbuffer = SDL_CreateRGBSurfaceWithFormat(
		0,
		480,
		pixheight * 144 - 16,
		8,
		SDL_PIXELFORMAT_INDEX8);
	SDL_SetSurfaceBlendMode(winbuffer, SDL_BLENDMODE_BLEND);
	SDL_SetColorKey(winbuffer, true, 0xc5);
	SDL_Surface* mwsurface = SDL_GetWindowSurface(mainwindow);
	SDL_SetSurfaceBlendMode(mwsurface, SDL_BLENDMODE_NONE);
	SDL_Surface* restorescreen = SDL_CreateRGBSurfaceWithFormat(
		0,
		winbuffer->w,
		winbuffer->h,
		mwsurface->format->BitsPerPixel,
		SDL_MasksToPixelFormatEnum(
			mwsurface->format->BitsPerPixel,
			mwsurface->format->Rmask,
			mwsurface->format->Gmask,
			mwsurface->format->Bmask,
			mwsurface->format->Amask));
	if (!winbuffer || !restorescreen)
	{
		SDL_Log("Could not create menu display buffers: %s", SDL_GetError());
		return;
	}
	SDL_SetSurfaceBlendMode(restorescreen, SDL_BLENDMODE_NONE);
	SDL_Rect winpos;
	winpos.w = winbuffer->w;
	winpos.h = winbuffer->h;
	SDL_GetWindowSize(mainwindow, &winpos.x, &winpos.y);
	int uwinpos = 2;
	winpos.x -= winpos.w;
	winpos.y -= winpos.h;
	winpos.x >>= 1;
	winpos.y >>= 1;
	SetHWPalette(winbuffer->format->palette);
	SDL_UpdateWindowSurface(mainwindow);
	SDL_BlitSurface(mwsurface, &winpos, restorescreen, NULL);
	PaintWindow(winbuffer, 0xff, 0x0b, "Debug Log", 0xff);
	const char* keyshint = "F: Find  \x97  Left/Right: Move Window  \x97  0/Esc: Close Log";
	int tx0 = (winpos.w - TextWidth(keyshint)) >> 1;
	DrawText(keyshint, tx0, winpos.h - 20, 0x03, 0xff, winbuffer);
	int displaylines = (winpos.h - 40) / 16;
	int dy0 = (winpos.h - displaylines * 16) >> 1;
	int displaystart = debuglogend - displaylines - 1;
	SDL_Rect animrect = winpos;
	SDL_Rect menurect = { 0, 0, winpos.w, winpos.h };
	for (int t = 1; t <= 8; ++t)
	{
		SDL_SetSurfaceAlphaMod(winbuffer, t * 31);
		animrect.w = winpos.w * t / 8;
		menurect.w = animrect.w;
		animrect.x = (mwsurface->w - animrect.w) >> 1;
		SDL_BlitSurface(restorescreen, NULL, mwsurface, &winpos);
		SDL_BlitSurface(winbuffer, &menurect, mwsurface, &animrect);
		SDL_UpdateWindowSurface(mainwindow);
		SDL_Delay(16);
	}
	bool repaintlog = true;
	while (true)
	{
		SDL_Event event;
		int newuwinpos = uwinpos;
		bool repaintscreen = true;
		while (SDL_PollEvent(&event))
		{
			SDL_Event newevent;
			switch (event.type)
			{
			case SDL_KEYDOWN:
				switch (event.key.keysym.sym)
				{
				case SDLK_0:
				case SDLK_KP_0:
				case SDLK_ESCAPE:
					goto exitdebugger;
				case SDLK_HOME:
					displaystart = debuglogstart;
					repaintlog = true;
					break;
				case SDLK_END:
					displaystart = debuglogend - displaylines - 1;
					repaintlog = true;
					break;
				case SDLK_PAGEUP:
					if (((displaystart - debuglogstart) & dlogidxmask) < displaylines)
					{
						UIBeepUnavailable();
					}
					else
					{
						displaystart -= displaylines;
						repaintlog = true;
					}
					break;
				case SDLK_PAGEDOWN:
					if (((debuglogend - displaystart - displaylines) & dlogidxmask) < displaylines)
					{
						UIBeepUnavailable();
					}
					else
					{
						displaystart += displaylines;
						repaintlog = true;
					}
					break;
				case SDLK_UP:
					if (((displaystart - debuglogstart) & dlogidxmask) == 0)
					{
						UIBeepUnavailable();
					}
					else
					{
						--displaystart;
						repaintlog = true;
					}
					break;
				case SDLK_DOWN:
					if (((debuglogend - displaystart - displaylines) & dlogidxmask) == 0)
					{
						UIBeepUnavailable();
					}
					else
					{
						++displaystart;
						repaintlog = true;
					}
					break;
				case SDLK_LEFT:
					if (uwinpos <= 0)
					{
						UIBeepUnavailable();
					}
					else
					{
						--newuwinpos;
					}
					break;
				case SDLK_RIGHT:
					if (uwinpos >= 4)
					{
						UIBeepUnavailable();
					}
					else
					{
						++newuwinpos;
					}
					break;
				case SDLK_TAB:
					if (event.key.keysym.mod & KMOD_SHIFT)
					{
						UIBeepUnavailable();
					}
					else
					{
						UIBeepUnavailable();
					}
					break;
				case SDLK_RETURN:
				case SDLK_KP_ENTER:
					UIBeepUnavailable();
					break;
				}
				break;
			case SDL_QUIT:
				newevent.type = SDL_QUIT;
				SDL_PushEvent(&newevent);
				goto exitdebugger;
			}
		}
		if (repaintlog)
		{
			SDL_Rect boxrect = { 2, 19, winpos.w - 4, winpos.h - 39 };
			SDL_FillRect(winbuffer, &boxrect, 0xff);
			div_t dr;
			for (int i = displaystart, j = 0, y = dy0; j < displaylines; ++i, ++j, y += 16)
			{
				dlogentry* entry = debuglog + (i & dlogidxmask);
				constexpr unsigned char CPUFLAG_CARRY     = 0x01;
				constexpr unsigned char CPUFLAG_ZERO      = 0x02;
				constexpr unsigned char CPUFLAG_INTERRUPT = 0x04;
				constexpr unsigned char CPUFLAG_DECIMAL   = 0x08;
				constexpr unsigned char CPUFLAG_BREAK     = 0x10;
				constexpr unsigned char CPUFLAG_OVERFLOW  = 0x40;
				constexpr unsigned char CPUFLAG_NEGATIVE  = 0x80;
				switch (entry->entrytype)
				{
					char line[37];
				case dlogentry::dletype::LT_START:
					strcpy_s(line, 12, "<log start>");
					tx0 = (winpos.w - TextWidth(line)) >> 1;
					DrawText(line, tx0, y, 0x72, 0xff, winbuffer);
					break;
				case dlogentry::dletype::LT_READ:
					strcpy_s(line, 21, "Read --- $---- = $--");
					DisplayMemType(line + 5, entry->mementry.memtype);
					DisplayHexWord(line + 10, entry->mementry.address);
					DisplayHexByte(line + 18, entry->mementry.value);
					tx0 = (winpos.w - TextWidth(line)) >> 1;
					DrawText(line, tx0, y, 0x20, 0xff, winbuffer);
					break;
				case dlogentry::dletype::LT_WRITE:
					strcpy_s(line, 22, "Write --- $---- = $--");
					DisplayMemType(line + 6, entry->mementry.memtype);
					DisplayHexWord(line + 11, entry->mementry.address);
					DisplayHexByte(line + 19, entry->mementry.value);
					tx0 = (winpos.w - TextWidth(line)) >> 1;
					DrawText(line, tx0, y, 0x24, 0xff, winbuffer);
					break;
				case dlogentry::dletype::LT_FVMC:
					strcpy_s(line, 34, "(FVMC: --- $---- -> $-- -> $----)");
					DisplayMemType(line + 7, entry->fvmcentry.memtype);
					DisplayHexWord(line + 12, entry->fvmcentry.src);
					DisplayHexWord(line + 28, entry->fvmcentry.dest);
					DisplayHexByte(line + 21, entry->fvmcentry.value);
					tx0 = (winpos.w - TextWidth(line)) >> 1;
					DrawText(line, tx0, y, 0x68, 0xff, winbuffer);
					break;
				case dlogentry::dletype::LT_STATE:
					strcpy_s(line, 35, "PC=$---- ------- A=$-- X=$-- Y=$--");
					DisplayHexWord(line + 4, entry->stateentry.pc);
					if (entry->stateentry.status & CPUFLAG_NEGATIVE)
						line[9] = 'N';
					if (entry->stateentry.status & CPUFLAG_OVERFLOW)
						line[10] = 'V';
					if (entry->stateentry.status & CPUFLAG_BREAK)
						line[11] = 'B';
					if (entry->stateentry.status & CPUFLAG_DECIMAL)
						line[12] = 'D';
					if (entry->stateentry.status & CPUFLAG_INTERRUPT)
						line[13] = 'I';
					if (entry->stateentry.status & CPUFLAG_ZERO)
						line[14] = 'Z';
					if (entry->stateentry.status & CPUFLAG_CARRY)
						line[15] = 'C';
					DisplayHexByte(line + 20, entry->stateentry.a);
					DisplayHexByte(line + 26, entry->stateentry.x);
					DisplayHexByte(line + 32, entry->stateentry.y);
					tx0 = (winpos.w - TextWidth(line)) >> 1;
					DrawText(line, tx0, y, 0x03, 0xff, winbuffer);
					break;
				case dlogentry::dletype::LT_STACK:
					strcpy_s(line, 37, "Stack: $-- $-- $-- $-- $-- $-- $-- \205");
					DisplayHexByte(line + 8, entry->stackentry.stack[0]);
					DisplayHexByte(line + 12, entry->stackentry.stack[1]);
					DisplayHexByte(line + 16, entry->stackentry.stack[2]);
					DisplayHexByte(line + 20, entry->stackentry.stack[3]);
					DisplayHexByte(line + 24, entry->stackentry.stack[4]);
					DisplayHexByte(line + 28, entry->stackentry.stack[5]);
					DisplayHexByte(line + 32, entry->stackentry.stack[6]);
					if (entry->stackentry.nstack <= 7)
						line[6 + entry->stackentry.nstack * 4] = 0;
					tx0 = (winpos.w - TextWidth(line)) >> 1;
					DrawText(line, tx0, y, 0x21, 0xff, winbuffer);
					break;
				case dlogentry::dletype::LT_INST:
					strcpy_s(line, 23, "--- -------\0\0\0\0\0\0\0\0\0\0\0");
					DisplayOpcode(line, entry->instentry.opc);
					char* tpos;
					DisplayArgs(line + 4, entry->instentry.opc, (char*)&entry->instentry.arg, &tpos);
					*tpos = '(';
					*++tpos = '0' + entry->instentry.cycles;
					*++tpos = ' ';
					*++tpos = 'c';
					*++tpos = 'y';
					*++tpos = 'c';
					*++tpos = 'l';
					*++tpos = 'e';
					*++tpos = 's';
					*++tpos = ')';
					*++tpos = 0;
					tx0 = (winpos.w - TextWidth(line)) >> 1;
					DrawText(line, tx0, y, 0x11, 0xff, winbuffer);
					break;
				case dlogentry::dletype::LT_PARTIALINST:
					strcpy_s(line, 26, "<ready to read next inst>");
					tx0 = (winpos.w - TextWidth(line)) >> 1;
					DrawText(line, tx0, y, 0x79, 0xff, winbuffer);
					break;
				case dlogentry::dletype::LT_RESET:
					strcpy_s(line, 12, "<CPU reset>");
					tx0 = (winpos.w - TextWidth(line)) >> 1;
					DrawText(line, tx0, y, 0x41, 0xff, winbuffer);
					break;
				case dlogentry::dletype::LT_SCANLINE:
					strcpy_s(line, 21, "<begin scanline --->");
					dr = div(entry->scanline, 10);
					line[18] = '0' + dr.rem;
					dr = div(dr.quot, 10);
					line[17] = '0' + dr.rem;
					line[16] = '0' + dr.quot;
					tx0 = (winpos.w - TextWidth(line)) >> 1;
					DrawText(line, tx0, y, 0xd5, 0xff, winbuffer);
					break;
				default:
					strcpy_s(line, 28, "<unknown log entry type -->");
					DisplayHexByte(line + 24, entry->entrytype);
					tx0 = (winpos.w - TextWidth(line)) >> 1;
					DrawText(line, tx0, y, 0x07, 0xff, winbuffer);
					break;
				}
			}
			repaintscreen = true;
			repaintlog = false;
		}
		if (newuwinpos != uwinpos)
		{
			uwinpos = newuwinpos;
			SDL_BlitSurface(restorescreen, NULL, mwsurface, &winpos);
			SDL_GetWindowSize(mainwindow, &winpos.x, NULL);
			winpos.x -= winpos.w;
			winpos.x *= uwinpos;
			winpos.x >>= 2;
			SDL_BlitSurface(mwsurface, &winpos, restorescreen, NULL);
			repaintscreen = true;
		}
		if (repaintscreen)
		{
			SDL_BlitSurface(restorescreen, NULL, mwsurface, &winpos);
			SDL_BlitSurface(winbuffer, NULL, mwsurface, &winpos);
			SDL_UpdateWindowSurface(mainwindow);
		}
		SDL_Delay(16);
	}
exitdebugger:
	animrect.x = winpos.x;
	for (int t = 7; t > 0; --t)
	{
		SDL_SetSurfaceAlphaMod(winbuffer, t * 31);
		animrect.h = winpos.h * t / 8;
		menurect.h = animrect.h;
		menurect.y = winpos.h - animrect.h;
		animrect.y = (mwsurface->h - animrect.h) >> 1;
		SDL_BlitSurface(restorescreen, NULL, mwsurface, &winpos);
		SDL_BlitSurface(winbuffer, &menurect, mwsurface, &animrect);
		SDL_UpdateWindowSurface(mainwindow);
		SDL_Delay(16);
	}
	SDL_BlitSurface(restorescreen, NULL, mwsurface, &winpos);
	SDL_FreeSurface(restorescreen);
	SDL_FreeSurface(winbuffer);
}

void DoMenu(int quickoption)
{
	SDL_Surface* menubuffer = SDL_CreateRGBSurfaceWithFormat(
		0,
		240,
		224,
		8,
		SDL_PIXELFORMAT_INDEX8);
	SDL_SetSurfaceBlendMode(menubuffer, SDL_BLENDMODE_BLEND);
	SDL_SetColorKey(menubuffer, true, 0xc5);
	SDL_Surface* mwsurface = SDL_GetWindowSurface(mainwindow);
	SDL_SetSurfaceBlendMode(mwsurface, SDL_BLENDMODE_NONE);
	SDL_Surface* restorescreen = SDL_CreateRGBSurfaceWithFormat(
		0,
		menubuffer->w,
		menubuffer->h,
		mwsurface->format->BitsPerPixel,
		SDL_MasksToPixelFormatEnum(
			mwsurface->format->BitsPerPixel,
			mwsurface->format->Rmask,
			mwsurface->format->Gmask,
			mwsurface->format->Bmask,
			mwsurface->format->Amask));
	if (!menubuffer || !restorescreen)
	{
		SDL_Log("Could not create menu display buffers: %s", SDL_GetError());
		return;
	}
	SDL_SetSurfaceBlendMode(restorescreen, SDL_BLENDMODE_NONE);
	SDL_Rect winpos;
	winpos.w = menubuffer->w;
	winpos.h = menubuffer->h;
	SDL_GetWindowSize(mainwindow, &winpos.x, &winpos.y);
	winpos.x -= winpos.w;
	winpos.y -= winpos.h;
	winpos.x >>= 1;
	winpos.y >>= 2;
	SetHWPalette(menubuffer->format->palette);
	SDL_UpdateWindowSurface(mainwindow);
	SDL_BlitSurface(mwsurface, &winpos, restorescreen, NULL);
	PaintWindow(menubuffer, 0xff, 0x3d, "Emulator Menu", 0xff);
	const char* itemtext[9] = {
		"1: Options",
		"2: Screen Capture",
		"3: Debugging Tools",
		"4: Insert Cartridge",
		"6: Documentation",
		"7: Reset Computer",
		"8: About Retro 6k",
		"9: Exit Emulator",
		"0: Close Menu",
	};
	if (cartridgeinserted)
		itemtext[3] = "5: Remove Cartridge";
	unsigned char itemcolor[9] = {
		0x06,
		0x02,
		0x03,
		0x31,
		0x11,
		0x15,
		0x45,
		0x44,
		0x64,
	};
	int itemy0[9];
	int selecteditem = 8;
	if (quickoption) {
		if (quickoption < 4)
		{
			selecteditem = quickoption - 1;
		}
		else if (quickoption == 4)
		{
			if (cartridgeinserted)
			{
				selecteditem = 8;
				quickoption = 0;
			}
			else
			{
				selecteditem = 3;
			}
		}
		else if (quickoption == 5)
		{
			if (cartridgeinserted)
			{
				selecteditem = 3;
			}
			else
			{
				selecteditem = 8;
				quickoption = 0;
			}
		}
		else
		{
			selecteditem = quickoption - 2;
		}
	}
	int maxitemwidth = 0;
	for (int i = 0; i < 9; ++i)
	{
		int itemwidth = TextWidth(itemtext[i]);
		if (itemwidth > maxitemwidth)
			maxitemwidth = itemwidth;
	}
	const int semicircw[18] = { 3, 5, 6, 7, 8, 8, 9, 9, 9, 9, 9, 9, 8, 8, 7, 6, 5, 3 };
	int ix0 = (menubuffer->w - maxitemwidth) >> 1;
	for (int i = 0, y0 = 32; i < 9; ++i, y0 += 20)
	{
		int x0 = ix0;
		itemy0[i] = y0;
		if (selecteditem == i)
		{
			SDL_Rect selrect = { ix0, y0 - 1, maxitemwidth, 18 };
			SDL_FillRect(menubuffer, &selrect, itemcolor[i]);
			DrawText(itemtext[i], x0, y0, 0xff, itemcolor[i], menubuffer);
			selrect.h = 1;
			for (int y = 0; y < 18; ++y)
			{
				selrect.y = y0 + y - 1;
				selrect.w = semicircw[y];
				selrect.x = ix0 - selrect.w;
				SDL_FillRect(menubuffer, &selrect, itemcolor[i]);
				selrect.x = ix0 + maxitemwidth;
				SDL_FillRect(menubuffer, &selrect, itemcolor[i]);
			}
		}
		else
		{
			SDL_Rect selrect = { ix0 - 9, y0 - 1, maxitemwidth + 18, 18 };
			SDL_FillRect(menubuffer, &selrect, 0xff);
			DrawText(itemtext[i], x0, y0, itemcolor[i], 0xff, menubuffer);
		}
	}
	unsigned short restorefreq[4];
	restorefreq[0] = soundfreqregister[0];
	restorefreq[1] = soundfreqregister[1];
	restorefreq[2] = soundfreqregister[2];
	restorefreq[3] = soundfreqregister[3];
	SDL_Rect animrect = winpos;
	SDL_Rect menurect = { 0, 0, winpos.w, winpos.h };
	for (int t = 1; t <= 8; ++t)
	{
		SDL_SetSurfaceAlphaMod(menubuffer, t * 31);
		animrect.w = winpos.w * t / 8;
		menurect.w = animrect.w;
		animrect.x = (mwsurface->w - animrect.w) >> 1;
		SDL_BlitSurface(restorescreen, NULL, mwsurface, &winpos);
		SDL_BlitSurface(menubuffer, &menurect, mwsurface, &animrect);
		SDL_UpdateWindowSurface(mainwindow);
		soundfreqregister[0] = restorefreq[0] * (8 - t) / 8;
		soundfreqregister[1] = restorefreq[1] * (8 - t) / 8;
		soundfreqregister[2] = restorefreq[2] * (8 - t) / 8;
		soundfreqregister[3] = restorefreq[3] * (8 - t) / 8;
		SDL_Delay(16);
	}
	menuhassound = true;
	//SDL_UpdateWindowSurface(mainwindow);
	while (true)
	{
		int newselection = selecteditem;
		SDL_Event event;
		bool activateselection = quickoption;
		quickoption = 0;
		while (SDL_PollEvent(&event))
		{
			SDL_Event newevent;
			switch (event.type)
			{
			case SDL_KEYDOWN:
				switch (event.key.keysym.sym)
				{
				case SDLK_1:
				case SDLK_KP_1:
					newselection = 0;
					activateselection = true;
					break;
				case SDLK_2:
				case SDLK_KP_2:
					newselection = 1;
					activateselection = true;
					break;
				case SDLK_3:
				case SDLK_KP_3:
					newselection = 2;
					activateselection = true;
					break;
				case SDLK_4:
				case SDLK_KP_4:
					if (!cartridgeinserted)
					{
						newselection = 3;
						activateselection = true;
					}
					else
					{
						UIBeepUnavailable();
					}
					break;
				case SDLK_5:
				case SDLK_KP_5:
					if (cartridgeinserted)
					{
						newselection = 3;
						activateselection = true;
					}
					else
					{
						UIBeepUnavailable();
					}
					break;
				case SDLK_6:
				case SDLK_KP_6:
					newselection = 4;
					activateselection = true;
					break;
				case SDLK_7:
				case SDLK_KP_7:
					newselection = 5;
					activateselection = true;
					break;
				case SDLK_8:
				case SDLK_KP_8:
					newselection = 6;
					activateselection = true;
					break;
				case SDLK_9:
				case SDLK_KP_9:
					newselection = 7;
					activateselection = true;
					break;
				case SDLK_0:
				case SDLK_KP_0:
					newselection = 8;
					activateselection = true;
					break;
				case SDLK_ESCAPE:
					goto exitmenu;
				case SDLK_UP:
				case SDLK_LEFT:
					--newselection;
					if (newselection < 0)
						newselection = 8;
					break;
				case SDLK_DOWN:
				case SDLK_RIGHT:
					++newselection;
					if (newselection > 8)
						newselection = 0;
					break;
				case SDLK_TAB:
					if (event.key.keysym.mod & KMOD_SHIFT)
					{
					--newselection;
					if (newselection < 0)
						newselection = 8;
					}
					else
					{
					++newselection;
					if (newselection > 8)
						newselection = 0;
					}
					break;
				case SDLK_RETURN:
				case SDLK_KP_ENTER:
					activateselection = true;
					break;
				}
				break;
			case SDL_QUIT:
				newevent.type = SDL_QUIT;
				SDL_PushEvent(&newevent);
				goto exitmenu;
			}
		}
		if (newselection != selecteditem)
		{
			UIBeepMoveSel();
			int i = newselection;
			int y0 = itemy0[i];
			int x0 = ix0;
			SDL_Rect selrect = { ix0, y0 - 1, maxitemwidth, 18 };
			SDL_FillRect(menubuffer, &selrect, itemcolor[i]);
			DrawText(itemtext[i], x0, y0, 0xff, itemcolor[i], menubuffer);
			selrect.h = 1;
			for (int y = 0; y < 18; ++y)
			{
				selrect.y = y0 + y - 1;
				selrect.w = semicircw[y];
				selrect.x = ix0 - selrect.w;
				SDL_FillRect(menubuffer, &selrect, itemcolor[i]);
				selrect.x = ix0 + maxitemwidth;
				SDL_FillRect(menubuffer, &selrect, itemcolor[i]);
			}
			i = selecteditem;
			y0 = itemy0[i];
			selrect = { ix0 - 9, y0 - 1, maxitemwidth + 18, 18 };
			SDL_FillRect(menubuffer, &selrect, 0xff);
			x0 = ix0;
			DrawText(itemtext[i], x0, y0, itemcolor[i], 0xff, menubuffer);
			selecteditem = newselection;
		}
		SDL_BlitSurface(restorescreen, NULL, mwsurface, &winpos);
		SDL_BlitSurface(menubuffer, &menurect, mwsurface, &animrect);
		SDL_UpdateWindowSurface(mainwindow);
		if (activateselection)
		{
			switch (selecteditem)
			{
				SDL_Event newevent;
			case 0:
				// Options
				UIBeepUnavailable();
				break;
			case 1:
				// Screen Capture
				UIBeepUnavailable();
				break;
			case 2:
				// Debugging Tools
				UIBeepTakeAction();
				SDL_SetSurfaceAlphaMod(menubuffer, 0xaa);
				SDL_BlitSurface(restorescreen, NULL, mwsurface, &winpos);
				SDL_BlitSurface(menubuffer, &menurect, mwsurface, &animrect);
				DoDebugger();
				SDL_SetSurfaceAlphaMod(menubuffer, 0xf8);
				SDL_BlitSurface(restorescreen, NULL, mwsurface, &winpos);
				SDL_BlitSurface(menubuffer, &menurect, mwsurface, &animrect);
				SDL_UpdateWindowSurface(mainwindow);
				break;
			case 3:
				if (cartridgeinserted)
				{
					// Remove Cartridge
					UIBeepTakeAction();
					EjectCartridge();
					goto exitmenu;
				}
				else
				{
					// Insert Cartridge
					UIBeepUnavailable();
				}
				break;
			case 4:
				// Documentation
				UIBeepUnavailable();
				break;
			case 5:
				// Reset
				UIBeepTakeAction();
				newevent.type = UE_RESETCPU;
				SDL_PushEvent(&newevent);
				goto exitmenu;
			case 6:
				// About
				UIBeepTakeAction();
				SDL_SetSurfaceAlphaMod(menubuffer, 0xaa);
				SDL_BlitSurface(restorescreen, NULL, mwsurface, &winpos);
				SDL_BlitSurface(menubuffer, &menurect, mwsurface, &animrect);
				DoAbout();
				SDL_SetSurfaceAlphaMod(menubuffer, 0xf8);
				SDL_BlitSurface(restorescreen, NULL, mwsurface, &winpos);
				SDL_BlitSurface(menubuffer, &menurect, mwsurface, &animrect);
				SDL_UpdateWindowSurface(mainwindow);
				break;
			case 7:
				// Exit
				newevent.type = SDL_QUIT;
				SDL_PushEvent(&newevent);
				UIBeepTakeAction();
				restorefreq[0] = 0;
				restorefreq[1] = 0;
				restorefreq[2] = 0;
				restorefreq[3] = 0;
				goto exitmenu;
			case 8:
				// Close Menu
				goto exitmenu;
			}
		}
		SDL_Delay(16);
	}
exitmenu:
	while (menubeepdur)
		SDL_Delay(1);
	menuhassound = false;
	for (int t = 7; t > 0; --t)
	{
		SDL_SetSurfaceAlphaMod(menubuffer, t * 31);
		animrect.h = winpos.h * t / 8;
		menurect.h = animrect.h;
		menurect.y = winpos.h - animrect.h;
		animrect.y = (mwsurface->h - animrect.h) >> 2;
		SDL_BlitSurface(restorescreen, NULL, mwsurface, &winpos);
		SDL_BlitSurface(menubuffer, &menurect, mwsurface, &animrect);
		SDL_UpdateWindowSurface(mainwindow);
		soundfreqregister[0] = restorefreq[0] * (8 - t) / 8;
		soundfreqregister[1] = restorefreq[1] * (8 - t) / 8;
		soundfreqregister[2] = restorefreq[2] * (8 - t) / 8;
		soundfreqregister[3] = restorefreq[3] * (8 - t) / 8;
		SDL_Delay(16);
	}
	SDL_BlitSurface(restorescreen, NULL, mwsurface, &winpos);
	SDL_FreeSurface(restorescreen);
	SDL_FreeSurface(menubuffer);
	soundfreqregister[0] = restorefreq[0];
	soundfreqregister[1] = restorefreq[1];
	soundfreqregister[2] = restorefreq[2];
	soundfreqregister[3] = restorefreq[3];
}

void DoPickFile(filetype ft)
{
	SDL_Surface* winbuffer = SDL_CreateRGBSurfaceWithFormat(
		0,
		480,
		400,
		8,
		SDL_PIXELFORMAT_INDEX8);
	SDL_SetSurfaceBlendMode(winbuffer, SDL_BLENDMODE_BLEND);
	SDL_SetColorKey(winbuffer, true, 0xf9);
	SDL_Surface* mwsurface = SDL_GetWindowSurface(mainwindow);
	SDL_SetSurfaceBlendMode(mwsurface, SDL_BLENDMODE_NONE);
	SDL_Surface* restorescreen = SDL_CreateRGBSurfaceWithFormat(
		0,
		winbuffer->w,
		winbuffer->h,
		mwsurface->format->BitsPerPixel,
		SDL_MasksToPixelFormatEnum(
			mwsurface->format->BitsPerPixel,
			mwsurface->format->Rmask,
			mwsurface->format->Gmask,
			mwsurface->format->Bmask,
			mwsurface->format->Amask));
	if (!winbuffer || !restorescreen)
	{
		SDL_Log("Could not create menu display buffers: %s", SDL_GetError());
		return;
	}
	SDL_SetSurfaceBlendMode(restorescreen, SDL_BLENDMODE_NONE);
	SDL_Rect winpos;
	winpos.w = winbuffer->w;
	winpos.h = winbuffer->h;
	SDL_GetWindowSize(mainwindow, &winpos.x, &winpos.y);
	winpos.x -= winpos.w;
	winpos.y -= winpos.h;
	winpos.x >>= 1;
	winpos.y >>= 1;
	SetHWPalette(winbuffer->format->palette);
	SDL_UpdateWindowSurface(mainwindow);
	SDL_BlitSurface(mwsurface, &winpos, restorescreen, NULL);
	const char* titles[4] = {
		"Choose a File\x85",
		"Choose a ROM File\x85",
		"Choose a Cartridge File\x85",
		"Choose a Cartridge Save File\x85",
	};
	char* wintitle;
	switch (ft)
	{
	case FT_CART:
		wintitle = (char*)titles[2];
		break;
	default:
		wintitle = (char*)titles[0];
	}
	PaintWindow(winbuffer, 0xff, 0x39, wintitle, 0xff);
	const char* keyshint = "Esc: Cancel";
	int tx0 = (winpos.w - TextWidth(keyshint)) >> 1;
	DrawText(keyshint, tx0, winpos.h - 20, 0x31, 0xff, winbuffer);
	int displaylines = (winpos.h - 40) / 16;
	std::vector<int> itemy0(displaylines);
	itemy0[0] = (winpos.h - displaylines * 16) >> 1;
	for (int i = 1, py0 = itemy0[0]; i < displaylines; ++i)
		itemy0[i] = (py0 += 18);
	const int itemx0 = 16;
	DrawTextC("Loading directory listing\x85", itemx0, itemy0[0], 0x07, 0xff, winbuffer);
	SDL_Rect animrect = winpos;
	SDL_Rect menurect = { 0, 0, winpos.w, winpos.h };
	for (int t = 1; t <= 8; ++t)
	{
		SDL_SetSurfaceAlphaMod(winbuffer, t * 31);
		animrect.w = winpos.w * t / 8;
		menurect.w = animrect.w;
		animrect.x = (mwsurface->w - animrect.w) >> 1;
		SDL_BlitSurface(restorescreen, NULL, mwsurface, &winpos);
		SDL_BlitSurface(winbuffer, &menurect, mwsurface, &animrect);
		SDL_UpdateWindowSurface(mainwindow);
		SDL_Delay(16);
	}
	while (true)
	{
		SDL_Event event;
		while (SDL_PollEvent(&event))
		{
			SDL_Event newevent;
			switch (event.type)
			{
			case SDL_KEYDOWN:
				goto exitpickfile;
				break;
			case SDL_QUIT:
				newevent.type = SDL_QUIT;
				SDL_PushEvent(&newevent);
				goto exitpickfile;
			}
		}
		SDL_Delay(16);
	}
exitpickfile:
	for (int t = 7; t > 0; --t)
	{
		SDL_SetSurfaceAlphaMod(winbuffer, t * 31);
		animrect.h = winpos.h * t / 8;
		menurect.h = animrect.h;
		menurect.y = winpos.h - animrect.h;
		animrect.y = (mwsurface->h - animrect.h) >> 1;
		SDL_BlitSurface(restorescreen, NULL, mwsurface, &winpos);
		SDL_BlitSurface(winbuffer, &menurect, mwsurface, &animrect);
		SDL_UpdateWindowSurface(mainwindow);
		SDL_Delay(16);
	}
	SDL_BlitSurface(restorescreen, NULL, mwsurface, &winpos);
	SDL_FreeSurface(restorescreen);
	SDL_FreeSurface(winbuffer);
}

int InitEmulator()
{
	for (int y = 0; y < 18; ++y)
		for (int x = 0; x < 32; ++x)
		{
			PaintCell(x, y);
		}
	debuglog[debuglogstart].entrytype = dlogentry::dletype::LT_START;
	hookexternal(LogStep);
	keypressregister = 0;
	{
		unsigned int uebase = SDL_RegisterEvents(1);
		UE_RESETCPU = uebase;
	}
	{
		SDL_Event newevent;
		newevent.type = UE_RESETCPU;
		SDL_PushEvent(&newevent);
	}
	soundfreqregister[0] = 0;
	soundfreqregister[1] = 0;
	soundfreqregister[2] = 0;
	soundfreqregister[3] = 0;
	soundvolregister[0] = 0x00;
	soundvolregister[1] = 0x00;
	soundvolregister[2] = 0x00;
	soundvolregister[3] = 0x00;
	return 0;
}

int InitMainWindow()
{
	SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER);
	SDL_DisplayMode desktopmode;
	SDL_GetDesktopDisplayMode(0, &desktopmode);
	pixwidth = (desktopmode.w - 64) / 256;
	pixheight = (desktopmode.h - 36) / 144;
	if (pixwidth > pixheight)
	{
		pixwidth = pixheight;
	}
	else if (pixheight * 3 > pixwidth * 4)
	{
		pixheight = pixwidth * 4 / 3;
	}
	mainwindow = SDL_CreateWindow("Retro 6k Emulator",
		SDL_WINDOWPOS_UNDEFINED,
		SDL_WINDOWPOS_UNDEFINED,
		pixwidth * 256,
		pixheight * 144,
		0);
	if (!mainwindow)
	{
		SDL_Log("Could not create a window: %s", SDL_GetError());
		return -1;
	}
	SDL_Surface* mwsurface = SDL_GetWindowSurface(mainwindow);
	framebuffer = SDL_CreateRGBSurfaceWithFormat(
		0,
		pixwidth * 256,
		pixheight * 144,
		mwsurface->format->BitsPerPixel,
		SDL_MasksToPixelFormatEnum(
			mwsurface->format->BitsPerPixel,
			mwsurface->format->Rmask,
			mwsurface->format->Gmask,
			mwsurface->format->Bmask,
			mwsurface->format->Amask));
	if (!framebuffer)
	{
		SDL_Log("Could not create frame buffer: %s", SDL_GetError());
		return -1;
	}
	cellcanvas = SDL_CreateRGBSurface(0, pixwidth * 8, pixheight * 8, 8, 0, 0, 0, 0);
	if (!cellcanvas)
	{
		SDL_Log("Could not create cell canvas: %s", SDL_GetError());
		return -1;
	}
	SetHWPalette(cellcanvas->format->palette);
	return 0;
}

int InitMemory()
{
	sysram = new unsigned char[0x10000];
	syspflags = new unsigned char[0x100];
	if (!sysram || !syspflags)
	{
		SDL_Log("Could not allocate system address space");
		return -1;
	}
	for (int p = 0x00; p < 0x20; ++p)
		syspflags[p] = PF_TRAM;
	{ // Initialize the builtin RAM with deterministic random data
		std::mt19937 gen(1); //TODO: seed with a hash of machine identifying info
		std::uniform_int_distribution<> dis(0x00, 0xFF);
		for (int a = 0x0000; a < 0x2000; ++a)
			sysram[a] = dis(gen);
	}
	for (int p = 0x20; p < 0x100; ++p)
		syspflags[p] = PF_TFLOATING;
	floatgen.seed(seedgen());
	//InitVideoMem(); // no cheating!
	InstallROM();
	return 0;
}

int InitPaths()
{
	std::error_code ec;
	std::string path;
	int pathlen = path.length();
	path = std::filesystem::canonical("."); // TODO: read from config
	cartpath = (char*)malloc(pathlen + 1);
	if (!cartpath)
		return -1;
	path.copy(cartpath, pathlen);
	cartpath[pathlen] = 0;
	return 0;
}

int InitSound()
{
	SDL_AudioSpec desiredsoundspec;
	SDL_memset(&desiredsoundspec, 0, sizeof(desiredsoundspec));
	desiredsoundspec.freq = 44100;
	desiredsoundspec.format = AUDIO_U8;
	desiredsoundspec.channels = 2;
	desiredsoundspec.samples = 512;
	desiredsoundspec.callback = GenerateAudio;
	sounddev = SDL_OpenAudioDevice(NULL, false, &desiredsoundspec, &soundspec, 0);
	if (!sounddev)
	{
		SDL_Log("Could not open sound device");
	}
	SDL_PauseAudioDevice(sounddev, 0);
	return 0;
}

void InitVideoMem() // this function is a cheat. don't call it.
{
	const unsigned char videodata[0x1800] = {
		// Characters
		/*0x0800*/ 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35,
		/*0x0810*/ 0x36, 0x37, 0x38, 0x39, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x30, 0x31,
		/*0x0820*/ 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50,
		/*0x0830*/ 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F, 0x60,
		/*0x0840*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x0850*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x0860*/ 0x20, 0x1D, 0x20, 0x52, 0x65, 0x74, 0x72, 0x6f, 0x20, 0x36, 0x4b, 0x20, 0x46, 0x61, 0x6e, 0x74, 
		/*0x0870*/ 0x61, 0x73, 0x79, 0x20, 0x43, 0x6f, 0x6d, 0x70, 0x75, 0x74, 0x65, 0x72, 0x21, 0x20, 0x1D, 0x20,
		/*0x0880*/ 0x20, 0xA9, 0x32, 0x30, 0x31, 0x39, 0x20, 0x4d, 0x61, 0x67, 0x67, 0x69, 0x65, 0x20, 0x44, 0x61, 
		/*0x0890*/ 0x76, 0x69, 0x64, 0x20, 0x50, 0x2e, 0x4b, 0x2e, 0x20, 0x48, 0x61, 0x79, 0x6e, 0x65, 0x73, 0x20,
		/*0x08A0*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x08B0*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xE1, 0xE2, 0xE3, 0x00, 0x00, 0x00,
		/*0x08C0*/ 0x20, 0x20, 0x20, 0x53, 0x69, 0x6d, 0x70, 0x6c, 0x65, 0x20, 0x67, 0x72, 0x61, 0x70, 0x68, 0x69, 
		/*0x08D0*/ 0x63, 0x73, 0x2a, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0xE4, 0xE5, 0xE6, 0xE7, 0x20, 0x20, 0x20,
		/*0x08E0*/ 0x20, 0x20, 0x20, 0x20, 0x75, 0x70, 0x20, 0x74, 0x6f, 0x20, 0x34, 0x20, 0x63, 0x6f, 0x6c, 0x6f,
		/*0x08F0*/ 0x72, 0x73, 0x2f, 0x63, 0x65, 0x6c, 0x6c, 0x20, 0x20, 0xE8, 0xE9, 0xEA, 0xEB, 0x20, 0x20, 0x20,
		/*0x0900*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x0910*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xEC, 0xED, 0xEE, 0xEF, 0x00, 0x00, 0x00,
		/*0x0920*/ 0x55, 0x73, 0x65, 0x20, 0x33, 0x32, 0x20, 0x6f, 0x75, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x32, 0x35,
		/*0x0930*/ 0x36, 0x20, 0x63, 0x6f, 0x6c, 0x6f, 0x72, 0x73, 0x20, 0x61, 0x74, 0x20, 0x6f, 0x6e, 0x63, 0x65,
		/*0x0940*/ 0x20, 0x42, 0x6c, 0x61, 0x63, 0x6b, 0x20, 0x20, 0x20, 0x50, 0x75, 0x72, 0x70, 0x6c, 0x65, 0x20,
		/*0x0950*/ 0x20, 0x44, 0x72, 0x6b, 0x47, 0x72, 0x6e, 0x20, 0x20, 0x44, 0x72, 0x6b, 0x47, 0x72, 0x79, 0x20,
		/*0x0960*/ 0x20, 0x44, 0x72, 0x6b, 0x42, 0x6c, 0x75, 0x20, 0x20, 0x49, 0x6e, 0x64, 0x69, 0x67, 0x6f, 0x20,
		/*0x0970*/ 0x20, 0x54, 0x75, 0x72, 0x71, 0x6f, 0x73, 0x20, 0x20, 0x4c, 0x74, 0x42, 0x6c, 0x75, 0x65, 0x20,
		/*0x0980*/ 0x20, 0x52, 0x65, 0x64, 0x20, 0x20, 0x20, 0x20, 0x20, 0x46, 0x63, 0x68, 0x73, 0x69, 0x61, 0x20,
		/*0x0990*/ 0x20, 0x42, 0x72, 0x6f, 0x77, 0x6e, 0x20, 0x20, 0x20, 0x43, 0x72, 0x6e, 0x61, 0x74, 0x6e, 0x20,
		/*0x09A0*/ 0x20, 0x4d, 0x61, 0x67, 0x6e, 0x74, 0x61, 0x20, 0x20, 0x48, 0x6f, 0x74, 0x50, 0x6e, 0x6b, 0x20,
		/*0x09B0*/ 0x20, 0x42, 0x6f, 0x71, 0x75, 0x65, 0x74, 0x20, 0x20, 0x4f, 0x72, 0x63, 0x68, 0x69, 0x64, 0x20,
		/*0x09C0*/ 0x20, 0x47, 0x72, 0x65, 0x65, 0x6e, 0x20, 0x20, 0x20, 0x4D, 0x6f, 0x73, 0x47, 0x72, 0x6e, 0x20,
		/*0x09D0*/ 0x20, 0x42, 0x72, 0x74, 0x47, 0x72, 0x6e, 0x20, 0x20, 0x4c, 0x74, 0x47, 0x72, 0x65, 0x6e, 0x20,
		/*0x09E0*/ 0x20, 0x41, 0x71, 0x75, 0x61, 0x20, 0x20, 0x20, 0x20, 0x53, 0x6b, 0x79, 0x42, 0x6c, 0x75, 0x20,
		/*0x09F0*/ 0x20, 0x43, 0x61, 0x72, 0x69, 0x62, 0x6e, 0x20, 0x20, 0x43, 0x79, 0x61, 0x6e, 0x20, 0x20, 0x20,
		/*0x0A00*/ 0x20, 0x4f, 0x6c, 0x69, 0x76, 0x65, 0x20, 0x20, 0x20, 0x50, 0x65, 0x61, 0x63, 0x68, 0x20, 0x20,
		/*0x0A10*/ 0x20, 0x59, 0x65, 0x6c, 0x47, 0x72, 0x6e, 0x20, 0x20, 0x59, 0x65, 0x6c, 0x6c, 0x6f, 0x77, 0x20,
		/*0x0A20*/ 0x20, 0x4c, 0x74, 0x47, 0x72, 0x61, 0x79, 0x20, 0x20, 0x4c, 0x69, 0x6c, 0x61, 0x63, 0x20, 0x20,
		/*0x0A30*/ 0x20, 0x4d, 0x6e, 0x74, 0x47, 0x72, 0x6e, 0x20, 0x20, 0x57, 0x68, 0x69, 0x74, 0x65, 0x20, 0x20,
		// Attributes (bit 0)
		/*0x0A40*/ 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF,
		/*0x0A50*/ 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF,
		/*0x0A60*/ 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF,
		/*0x0A70*/ 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF,
		/*0x0A80*/ 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF,
		/*0x0A90*/ 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF,
		/*0x0AA0*/ 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF,
		/*0x0AB0*/ 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0x8D, 0xCF, 0xCF, 0xCF, 0xCF,
		/*0x0AC0*/ 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF,
		/*0x0AD0*/ 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF,
		/*0x0AE0*/ 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF,
		/*0x0AF0*/ 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF,
		/*0x0B00*/ 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF,
		/*0x0B10*/ 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
		/*0x0B20*/ 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF, 0xCF,
		/*0x0B30*/ 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
		/*0x0B40*/ 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0xC3, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
		/*0x0B50*/ 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
		// Attributes (bit 1)
		/*0x0B60*/ 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		/*0x0B70*/ 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		/*0x0B80*/ 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		/*0x0B90*/ 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		/*0x0BA0*/ 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		/*0x0BB0*/ 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		/*0x0BC0*/ 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		/*0x0BD0*/ 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xA8, 0xEA, 0xCC, 0xCC, 0xCC, 0xCC,
		/*0x0BE0*/ 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		/*0x0BF0*/ 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		/*0x0C00*/ 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		/*0x0C10*/ 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		/*0x0C20*/ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		/*0x0C30*/ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
		/*0x0C40*/ 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		/*0x0C50*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x0C60*/ 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
		/*0x0C70*/ 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
		// Attributes (bit 2)
		/*0x0C80*/ 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		/*0x0C90*/ 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		/*0x0CA0*/ 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		/*0x0CB0*/ 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		/*0x0CC0*/ 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		/*0x0CD0*/ 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		/*0x0CE0*/ 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		/*0x0CF0*/ 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x8A, 0xEE, 0xCC, 0xCC, 0xCC, 0xCC,
		/*0x0D00*/ 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		/*0x0D10*/ 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		/*0x0D20*/ 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		/*0x0D30*/ 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		/*0x0D40*/ 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		/*0x0D50*/ 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x0D60*/ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		/*0x0D70*/ 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
		/*0x0D80*/ 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0xF3, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
		/*0x0D90*/ 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
		// Attributes (bit 3)
		/*0x0DA0*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x0DB0*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x0DC0*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x0DD0*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x0DE0*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x0DF0*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x0A, 0x0A, 0x0A, 0x00, 0x00, 0x00,
		/*0x0E00*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x0E10*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAA, 0xEE, 0xC8, 0xAA, 0x00, 0x00, 0x00,
		/*0x0E20*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x0E30*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0xA0, 0xA0, 0xA0, 0x00, 0x00, 0x00,
		/*0x0E40*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
		/*0x0E50*/ 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		/*0x0E60*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
		/*0x0E70*/ 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
		/*0x0E80*/ 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		/*0x0E90*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
		/*0x0EA0*/ 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
		/*0x0EB0*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
		// Attributes (bit 4)
		/*0x0EC0*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x0ED0*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x0EE0*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x0EF0*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x0F00*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x0F10*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x0A, 0x0A, 0x0A, 0x00, 0x00, 0x00,
		/*0x0F20*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x0F30*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xAA, 0x88, 0xAE, 0xAA, 0x00, 0x00, 0x00,
		/*0x0F40*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x0F50*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA0, 0xA0, 0xA0, 0xA0, 0x00, 0x00, 0x00,
		/*0x0F60*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x0F70*/ 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		/*0x0F80*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
		/*0x0F90*/ 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
		/*0x0FA0*/ 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
		/*0x0FB0*/ 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
		/*0x0FC0*/ 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x0FD0*/ 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33,
		// Palette
		/*0x0FE0*/ 0x00, 0x81, 0x84, 0x0D, 0x02, 0x83, 0x86, 0x0F, 0xD0, 0x59, 0x5C, 0xDD, 0xD2, 0x5B, 0x5E, 0xDF,
		/*0x0FF0*/ 0x20, 0xA1, 0xA4, 0x2D, 0x22, 0xA3, 0xA6, 0x2F, 0xF0, 0x79, 0x7C, 0xFD, 0xF2, 0x7B, 0x7E, 0xFF,
		// Font
		/*0x1000*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1010*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1020*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1030*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1040*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1050*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1060*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1070*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1080*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1090*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x10A0*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x10B0*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x10C0*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x10D0*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x10E0*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x10F0*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1100*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1110*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1120*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1130*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1140*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1150*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1160*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1170*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1180*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1190*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x11A0*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x11B0*/ 0x30, 0x30, 0xCC, 0xCC, 0x3F, 0xF0, 0x0C, 0xC0, 0x3F, 0xF0, 0xCC, 0xCC, 0x30, 0x30, 0x00, 0x00,
		/*0x11C0*/ 0x00, 0x00, 0x00, 0x0C, 0x00, 0x3C, 0xC0, 0xF0, 0xF3, 0xC0, 0x3F, 0x00, 0x0C, 0x00, 0x00, 0x00,
		/*0x11D0*/ 0x03, 0x00, 0x0F, 0xC0, 0x3F, 0xF0, 0xFF, 0xFC, 0x3F, 0xF0, 0x0F, 0xC0, 0x03, 0x00, 0x00, 0x00,
		/*0x11E0*/ 0x03, 0xC0, 0x03, 0x00, 0x3C, 0xFC, 0xFF, 0xFF, 0xFF, 0xF0, 0xFF, 0xFF, 0x3F, 0xFC, 0x0F, 0x30,
		/*0x11F0*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1200*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1210*/ 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x00, 0x00, 0x03, 0xC0, 0x03, 0xC0, 0x00, 0x00,
		/*0x1220*/ 0x03, 0x30, 0x03, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1230*/ 0x00, 0x00, 0x03, 0x0C, 0x3F, 0xFF, 0x0C, 0x30, 0x0C, 0x30, 0xFF, 0xFC, 0x30, 0xC0, 0x00, 0x00,
		/*0x1240*/ 0x00, 0xC0, 0x03, 0xFC, 0x0C, 0xC0, 0x0F, 0xF0, 0x03, 0xFC, 0x00, 0xCC, 0x0F, 0xF0, 0x00, 0xC0,
		/*0x1250*/ 0x33, 0xFC, 0xCC, 0x30, 0x30, 0xC0, 0x03, 0x00, 0x0C, 0x30, 0x30, 0xCC, 0xC0, 0x30, 0x00, 0x00,
		/*0x1260*/ 0x3F, 0xC0, 0xF0, 0xF3, 0x3C, 0x03, 0xF0, 0xFC, 0xF0, 0xF0, 0xF0, 0xF0, 0x3F, 0xC0, 0x00, 0x00,
		/*0x1270*/ 0x00, 0xC0, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1280*/ 0x00, 0x30, 0x00, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x00, 0xC0, 0x00, 0x30,
		/*0x1290*/ 0x0C, 0x00, 0x03, 0x00, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0x00, 0x0C, 0x00,
		/*0x12A0*/ 0x00, 0x00, 0x00, 0xC0, 0x0C, 0xCC, 0x03, 0xF0, 0x0C, 0xCC, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00,
		/*0x12B0*/ 0x00, 0x00, 0x00, 0xC0, 0x00, 0xC0, 0x0F, 0xFC, 0x00, 0xC0, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00,
		/*0x12C0*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xC0, 0x00, 0xC0, 0x03, 0x00,
		/*0x12D0*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x12E0*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xC0, 0x03, 0xC0, 0x00, 0x00,
		/*0x12F0*/ 0x00, 0x00, 0x00, 0x0C, 0x00, 0x30, 0x00, 0xC0, 0x03, 0x00, 0x0C, 0x00, 0x30, 0x00, 0x00, 0x00,
		/*0x1300*/ 0x0F, 0xF0, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x0F, 0xF0, 0x00, 0x00,
		/*0x1310*/ 0x03, 0xC0, 0x0F, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x00, 0x00,
		/*0x1320*/ 0x0F, 0xF0, 0x30, 0x3C, 0x00, 0x3C, 0x03, 0xF0, 0x0F, 0x00, 0x3C, 0x00, 0x3F, 0xFC, 0x00, 0x00,
		/*0x1330*/ 0x3F, 0xFC, 0x00, 0xF0, 0x03, 0xC0, 0x0F, 0xF0, 0x00, 0x3C, 0x30, 0x3C, 0x0F, 0xF0, 0x00, 0x00,
		/*0x1340*/ 0x00, 0xFC, 0x03, 0x3C, 0x0C, 0x3C, 0x30, 0x3C, 0x3F, 0xFF, 0x00, 0x3C, 0x00, 0x3C, 0x00, 0x00,
		/*0x1350*/ 0x3F, 0xFC, 0x3C, 0x00, 0x3F, 0xF0, 0x00, 0x3C, 0x00, 0x3C, 0x30, 0x3C, 0x0F, 0xF0, 0x00, 0x00,
		/*0x1360*/ 0x03, 0xF0, 0x0F, 0x00, 0x3F, 0xF0, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x0F, 0xF0, 0x00, 0x00,
		/*0x1370*/ 0x3F, 0xFC, 0x00, 0x3C, 0x00, 0x3C, 0x00, 0xF0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x00, 0x00,
		/*0x1380*/ 0x0F, 0xF0, 0x3C, 0x3C, 0x3C, 0x3C, 0x0F, 0xF0, 0x3C, 0x3C, 0x3C, 0x3C, 0x0F, 0xF0, 0x00, 0x00,
		/*0x1390*/ 0x0F, 0xF0, 0x3C, 0x3C, 0x3C, 0x3C, 0x0F, 0xFC, 0x00, 0x3C, 0x00, 0xF0, 0x0F, 0xC0, 0x00, 0x00,
		/*0x13A0*/ 0x00, 0x00, 0x00, 0x00, 0x03, 0xC0, 0x03, 0xC0, 0x00, 0x00, 0x03, 0xC0, 0x03, 0xC0, 0x00, 0x00,
		/*0x13B0*/ 0x00, 0x00, 0x00, 0x00, 0x03, 0xC0, 0x03, 0xC0, 0x00, 0x00, 0x03, 0xC0, 0x00, 0xC0, 0x03, 0x00,
		/*0x13C0*/ 0x00, 0x3C, 0x00, 0xF0, 0x03, 0xC0, 0x0F, 0x00, 0x0F, 0x00, 0x03, 0xC0, 0x00, 0xF0, 0x00, 0x3C,
		/*0x13D0*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xFC, 0x00, 0x00, 0x3F, 0xFC, 0x00, 0x00, 0x00, 0x00,
		/*0x13E0*/ 0x3C, 0x00, 0x0F, 0x00, 0x03, 0xC0, 0x00, 0xF0, 0x00, 0xF0, 0x03, 0xC0, 0x0F, 0x00, 0x3C, 0x00,
		/*0x13F0*/ 0x0F, 0xF0, 0x30, 0x3C, 0x00, 0x3C, 0x00, 0xF0, 0x03, 0xC0, 0x00, 0x00, 0x03, 0xC0, 0x00, 0x00,
		/*0x1400*/ 0x0F, 0xF0, 0x30, 0x0C, 0xC3, 0xC3, 0xCC, 0xC3, 0xCC, 0xC3, 0xC3, 0x3C, 0x30, 0x00, 0x0F, 0xF0,
		/*0x1410*/ 0x3F, 0xF0, 0xF0, 0x3C, 0xF0, 0x3C, 0xFF, 0xFC, 0xF0, 0x3C, 0xF0, 0x3C, 0xF0, 0x3C, 0x00, 0x00,
		/*0x1420*/ 0xFF, 0xF0, 0xF0, 0x3C, 0xF0, 0x3C, 0xFF, 0xF0, 0xF0, 0x3C, 0xF0, 0x3C, 0xFF, 0xF0, 0x00, 0x00,
		/*0x1430*/ 0x3F, 0xF0, 0xF0, 0x0C, 0xF0, 0x00, 0xF0, 0x00, 0xF0, 0x00, 0xF0, 0x0C, 0x3F, 0xF0, 0x00, 0x00,
		/*0x1440*/ 0xFF, 0xF0, 0xF0, 0x3C, 0xF0, 0x3C, 0xF0, 0x3C, 0xF0, 0x3C, 0xF0, 0x3C, 0xFF, 0xF0, 0x00, 0x00,
		/*0x1450*/ 0x3F, 0xFC, 0x3C, 0x00, 0x3C, 0x00, 0x3F, 0xF0, 0x3C, 0x00, 0x3C, 0x00, 0x3F, 0xFC, 0x00, 0x00,
		/*0x1460*/ 0x3F, 0xFC, 0x3C, 0x00, 0x3C, 0x00, 0x3F, 0xF0, 0x3C, 0x00, 0x3C, 0x00, 0x3C, 0x00, 0x00, 0x00,
		/*0x1470*/ 0x3F, 0xF0, 0xF0, 0x0C, 0xF0, 0x00, 0xF0, 0xFC, 0xF0, 0x3C, 0xF0, 0x3C, 0x3F, 0xF0, 0x00, 0x00,
		/*0x1480*/ 0xF0, 0x3C, 0xF0, 0x3C, 0xF0, 0x3C, 0xFF, 0xFC, 0xF0, 0x3C, 0xF0, 0x3C, 0xF0, 0x3C, 0x00, 0x00,
		/*0x1490*/ 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x00, 0x00,
		/*0x14A0*/ 0x00, 0x3C, 0x00, 0x3C, 0x00, 0x3C, 0x00, 0x3C, 0xF0, 0x3C, 0xF0, 0x3C, 0x3F, 0xF0, 0x00, 0x00,
		/*0x14B0*/ 0xF0, 0x3C, 0xF0, 0xF0, 0xF3, 0xC0, 0xFF, 0x00, 0xF3, 0xC0, 0xF0, 0xF0, 0xF0, 0x3C, 0x00, 0x00,
		/*0x14C0*/ 0x3C, 0x00, 0x3C, 0x00, 0x3C, 0x00, 0x3C, 0x00, 0x3C, 0x00, 0x3C, 0x00, 0x3F, 0xFC, 0x00, 0x00,
		/*0x14D0*/ 0xC0, 0x03, 0xF0, 0x0F, 0xFC, 0x3F, 0xFF, 0xFF, 0xCF, 0xCF, 0xC3, 0x0F, 0xC0, 0x0F, 0x00, 0x00,
		/*0x14E0*/ 0xF0, 0x0C, 0xFC, 0x0C, 0xFF, 0x0C, 0xCF, 0xCC, 0xC3, 0xFC, 0xC0, 0xFC, 0xC0, 0x3C, 0x00, 0x00,
		/*0x14F0*/ 0x3F, 0xF0, 0xF0, 0x3C, 0xF0, 0x3C, 0xF0, 0x3C, 0xF0, 0x3C, 0xF0, 0x3C, 0x3F, 0xF0, 0x00, 0x00,
		/*0x1500*/ 0xFF, 0xF0, 0xF0, 0x3C, 0xF0, 0x3C, 0xFF, 0xF0, 0xF0, 0x00, 0xF0, 0x00, 0xF0, 0x00, 0x00, 0x00,
		/*0x1510*/ 0x3F, 0xF0, 0xF0, 0x3C, 0xF0, 0x3C, 0xF0, 0x3C, 0xF0, 0x3C, 0xF0, 0x3C, 0x3F, 0xF0, 0x00, 0x3C,
		/*0x1520*/ 0xFF, 0xF0, 0xF0, 0x3C, 0xF0, 0x3C, 0xFF, 0xF0, 0xF0, 0x3C, 0xF0, 0x3C, 0xF0, 0x3C, 0x00, 0x00,
		/*0x1530*/ 0x0F, 0xF0, 0x3C, 0x0C, 0x3F, 0xC0, 0x0F, 0xF0, 0x00, 0xFC, 0x30, 0x3C, 0x0F, 0xF0, 0x00, 0x00,
		/*0x1540*/ 0x3F, 0xFC, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x00, 0x00,
		/*0x1550*/ 0xF0, 0x3C, 0xF0, 0x3C, 0xF0, 0x3C, 0xF0, 0x3C, 0xF0, 0x3C, 0xF0, 0x3C, 0x3F, 0xF0, 0x00, 0x00,
		/*0x1560*/ 0xF0, 0x3C, 0xF0, 0x3C, 0xF0, 0x3C, 0xF0, 0x3C, 0xF0, 0x30, 0xF0, 0xC0, 0xFF, 0x00, 0x00, 0x00,
		/*0x1570*/ 0xF3, 0xCF, 0xF3, 0xCF, 0xF3, 0xCF, 0xF3, 0xCF, 0xF3, 0xCF, 0xF3, 0xCC, 0xFF, 0xF0, 0x00, 0x00,
		/*0x1580*/ 0xF0, 0x3C, 0xF0, 0x3C, 0x3C, 0xF0, 0x0F, 0xC0, 0x3C, 0xF0, 0xF0, 0x3C, 0xF0, 0x3C, 0x00, 0x00,
		/*0x1590*/ 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x0F, 0xF0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x00, 0x00,
		/*0x15A0*/ 0x3F, 0xFC, 0x00, 0x3C, 0x00, 0xF0, 0x03, 0xC0, 0x0F, 0x00, 0x3C, 0x00, 0x3F, 0xFC, 0x00, 0x00,
		/*0x15B0*/ 0x03, 0xF0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xF0,
		/*0x15C0*/ 0xC0, 0x00, 0x30, 0x00, 0x0C, 0x00, 0x03, 0x00, 0x00, 0xC0, 0x00, 0x30, 0x00, 0x0C, 0x00, 0x00,
		/*0x15D0*/ 0x0F, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x0F, 0xC0,
		/*0x15E0*/ 0x00, 0xC0, 0x03, 0x30, 0x0C, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x15F0*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF,
		/*0x1600*/ 0x0C, 0x00, 0x03, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1610*/ 0x00, 0x00, 0x00, 0x00, 0x0F, 0xF0, 0x00, 0x3C, 0x0F, 0xFC, 0x3C, 0x3C, 0x0F, 0xFC, 0x00, 0x00,
		/*0x1620*/ 0x3C, 0x00, 0x3C, 0x00, 0x3F, 0xF0, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3F, 0xF0, 0x00, 0x00,
		/*0x1630*/ 0x00, 0x00, 0x00, 0x00, 0x03, 0xF0, 0x0F, 0x0C, 0x0F, 0x00, 0x0F, 0x0C, 0x03, 0xF0, 0x00, 0x00,
		/*0x1640*/ 0x00, 0x3C, 0x00, 0x3C, 0x0F, 0xFC, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x0F, 0xFC, 0x00, 0x00,
		/*0x1650*/ 0x00, 0x00, 0x00, 0x00, 0x0F, 0xF0, 0x3C, 0x3C, 0x3F, 0xFC, 0x3C, 0x00, 0x0F, 0xF0, 0x00, 0x00,
		/*0x1660*/ 0x00, 0xFC, 0x03, 0xC0, 0x0F, 0xF0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x00, 0x00,
		/*0x1670*/ 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFC, 0x3C, 0x3C, 0x3C, 0x3C, 0x0F, 0xFC, 0x00, 0x3C, 0x0F, 0xF0,
		/*0x1680*/ 0x3C, 0x00, 0x3C, 0x00, 0x3F, 0xF0, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x00, 0x00,
		/*0x1690*/ 0x03, 0xC0, 0x00, 0x00, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x00, 0x00,
		/*0x16A0*/ 0x03, 0xC0, 0x00, 0x00, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0xC3, 0xC0, 0x3F, 0x00,
		/*0x16B0*/ 0x3C, 0x00, 0x3C, 0x00, 0x3C, 0x3C, 0x3C, 0xF0, 0x3F, 0xC0, 0x3C, 0xF0, 0x3C, 0x3C, 0x00, 0x00,
		/*0x16C0*/ 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x00, 0x00,
		/*0x16D0*/ 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFC, 0xF3, 0xCF, 0xF3, 0xCF, 0xF3, 0xCF, 0xF3, 0xCF, 0x00, 0x00,
		/*0x16E0*/ 0x00, 0x00, 0x00, 0x00, 0x3F, 0xF0, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x00, 0x00,
		/*0x16F0*/ 0x00, 0x00, 0x00, 0x00, 0x0F, 0xF0, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x0F, 0xF0, 0x00, 0x00,
		/*0x1700*/ 0x00, 0x00, 0x00, 0x00, 0x3F, 0xF0, 0x3C, 0x3C, 0x3C, 0x3C, 0x3F, 0xF0, 0x3C, 0x00, 0x3C, 0x00,
		/*0x1710*/ 0x00, 0x00, 0x00, 0x00, 0x0F, 0xFC, 0x3C, 0x3C, 0x3C, 0x3C, 0x0F, 0xFC, 0x00, 0x3C, 0x00, 0x3C,
		/*0x1720*/ 0x00, 0x00, 0x00, 0x00, 0x0F, 0x3C, 0x0F, 0xC0, 0x0F, 0x00, 0x0F, 0x00, 0x0F, 0x00, 0x00, 0x00,
		/*0x1730*/ 0x00, 0x00, 0x00, 0x00, 0x03, 0xF0, 0x0F, 0x00, 0x03, 0xF0, 0x00, 0x3C, 0x0F, 0xF0, 0x00, 0x00,
		/*0x1740*/ 0x03, 0xC0, 0x03, 0xC0, 0x0F, 0xF0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x00, 0xF0, 0x00, 0x00,
		/*0x1750*/ 0x00, 0x00, 0x00, 0x00, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x0F, 0xFC, 0x00, 0x00,
		/*0x1760*/ 0x00, 0x00, 0x00, 0x00, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x30, 0x3F, 0xC0, 0x00, 0x00,
		/*0x1770*/ 0x00, 0x00, 0x00, 0x00, 0xF3, 0xCF, 0xF3, 0xCF, 0xF3, 0xCF, 0xF3, 0xCC, 0xFF, 0xF0, 0x00, 0x00,
		/*0x1780*/ 0x00, 0x00, 0x00, 0x00, 0x3C, 0x3C, 0x3C, 0x3C, 0x0F, 0xF0, 0x3C, 0x3C, 0x3C, 0x3C, 0x00, 0x00,
		/*0x1790*/ 0x00, 0x00, 0x00, 0x00, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x0F, 0xFC, 0x00, 0x3C, 0x0F, 0xF0,
		/*0x17A0*/ 0x00, 0x00, 0x00, 0x00, 0x3F, 0xFC, 0x00, 0x30, 0x03, 0xC0, 0x0C, 0x00, 0x3F, 0xFC, 0x00, 0x00,
		/*0x17B0*/ 0x00, 0x30, 0x00, 0xC0, 0x00, 0xC0, 0x00, 0xC0, 0x0F, 0x00, 0x00, 0xC0, 0x00, 0xC0, 0x00, 0x30,
		/*0x17C0*/ 0x00, 0xC0, 0x00, 0xC0, 0x00, 0xC0, 0x00, 0xC0, 0x00, 0xC0, 0x00, 0xC0, 0x00, 0xC0, 0x00, 0xC0,
		/*0x17D0*/ 0x03, 0x00, 0x00, 0xC0, 0x00, 0xC0, 0x00, 0xC0, 0x00, 0x3C, 0x00, 0xC0, 0x00, 0xC0, 0x03, 0x00,
		/*0x17E0*/ 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0C, 0x30, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x17F0*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1800*/ 0x30, 0x30, 0x00, 0x00, 0x3F, 0xF0, 0xF0, 0x3C, 0xF0, 0x3C, 0xFF, 0xFC, 0xF0, 0x3C, 0xF0, 0x3C,
		/*0x1810*/ 0x0F, 0xC0, 0x30, 0x30, 0x3F, 0xF0, 0xF0, 0x3C, 0xF0, 0x3C, 0xFF, 0xFC, 0xF0, 0x3C, 0xF0, 0x3C,
		/*0x1820*/ 0x3F, 0xF0, 0xF0, 0x0C, 0xF0, 0x00, 0xF0, 0x00, 0xF0, 0x0C, 0x3F, 0xF0, 0x03, 0x00, 0x0C, 0x00,
		/*0x1830*/ 0x00, 0xC0, 0x03, 0x00, 0x00, 0x00, 0x3F, 0xFC, 0x3C, 0x00, 0x3F, 0xF0, 0x3C, 0x00, 0x3F, 0xFC,
		/*0x1840*/ 0x3C, 0x30, 0xC3, 0xC0, 0x00, 0x00, 0xFC, 0x0C, 0xFF, 0x0C, 0xCF, 0xCC, 0xC3, 0xFC, 0xC0, 0xFC,
		/*0x1850*/ 0x30, 0x30, 0x00, 0x00, 0x3F, 0xF0, 0xF0, 0x3C, 0xF0, 0x3C, 0xF0, 0x3C, 0xF0, 0x3C, 0x3F, 0xF0,
		/*0x1860*/ 0x30, 0x30, 0x00, 0x00, 0xF0, 0x3C, 0xF0, 0x3C, 0xF0, 0x3C, 0xF0, 0x3C, 0xF0, 0x3C, 0x3F, 0xF0,
		/*0x1870*/ 0x00, 0xC0, 0x03, 0x00, 0x00, 0x00, 0x0F, 0xFC, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x0F, 0xFC,
		/*0x1880*/ 0x03, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x0F, 0xFC, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x0F, 0xFC,
		/*0x1890*/ 0x03, 0xC0, 0x0C, 0x30, 0x00, 0x00, 0x0F, 0xFC, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x0F, 0xFC,
		/*0x18A0*/ 0x00, 0x00, 0x0C, 0x30, 0x00, 0x00, 0x0F, 0xFC, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x0F, 0xFC,
		/*0x18B0*/ 0x0F, 0x0C, 0x30, 0xF0, 0x00, 0x00, 0x0F, 0xFC, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x0F, 0xFC,
		/*0x18C0*/ 0x03, 0xC0, 0x0C, 0x30, 0x03, 0xC0, 0x00, 0x00, 0x0F, 0xFC, 0x3C, 0x3C, 0x3C, 0x3C, 0x0F, 0xFC,
		/*0x18D0*/ 0x00, 0x00, 0x0F, 0xF0, 0x3C, 0x0C, 0x3C, 0x00, 0x3C, 0x0C, 0x0F, 0xF0, 0x00, 0xC0, 0x03, 0x00,
		/*0x18E0*/ 0x00, 0xC0, 0x03, 0x00, 0x00, 0x00, 0x0F, 0xF0, 0x3C, 0x3C, 0x3F, 0xFC, 0x3C, 0x00, 0x0F, 0xF0,
		/*0x18F0*/ 0x03, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x0F, 0xF0, 0x3C, 0x3C, 0x3F, 0xFC, 0x3C, 0x00, 0x0F, 0xF0,
		/*0x1900*/ 0x03, 0xC0, 0x0C, 0x30, 0x00, 0x00, 0x0F, 0xF0, 0x3C, 0x3C, 0x3F, 0xFC, 0x3C, 0x00, 0x0F, 0xF0,
		/*0x1910*/ 0x00, 0x00, 0x0C, 0x30, 0x00, 0x00, 0x0F, 0xF0, 0x3C, 0x3C, 0x3F, 0xFC, 0x3C, 0x00, 0x0F, 0xF0,
		/*0x1920*/ 0x00, 0xC0, 0x03, 0x00, 0x00, 0x00, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0,
		/*0x1930*/ 0x03, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0,
		/*0x1940*/ 0x03, 0xC0, 0x0C, 0x30, 0x00, 0x00, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0,
		/*0x1950*/ 0x00, 0x00, 0x0C, 0x30, 0x00, 0x00, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0,
		/*0x1960*/ 0x0F, 0x0C, 0x30, 0xF0, 0x00, 0x00, 0x3F, 0xF0, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C,
		/*0x1970*/ 0x00, 0xC0, 0x03, 0x00, 0x00, 0x00, 0x0F, 0xF0, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x0F, 0xF0,
		/*0x1980*/ 0x03, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x0F, 0xF0, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x0F, 0xF0,
		/*0x1990*/ 0x03, 0xC0, 0x0C, 0x30, 0x00, 0x00, 0x0F, 0xF0, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x0F, 0xF0,
		/*0x19A0*/ 0x00, 0x00, 0x0C, 0x30, 0x00, 0x00, 0x0F, 0xF0, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x0F, 0xF0,
		/*0x19B0*/ 0x0F, 0x0C, 0x30, 0xF0, 0x00, 0x00, 0x0F, 0xF0, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x0F, 0xF0,
		/*0x19C0*/ 0x00, 0xC0, 0x03, 0x00, 0x00, 0x00, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x0F, 0xFC,
		/*0x19D0*/ 0x03, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x0F, 0xFC,
		/*0x19E0*/ 0x03, 0xC0, 0x0C, 0x30, 0x00, 0x00, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x0F, 0xFC,
		/*0x19F0*/ 0x00, 0x00, 0x0C, 0x30, 0x00, 0x00, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x0F, 0xFC,
		/*0x1A00*/ 0x00, 0xC0, 0x03, 0xF0, 0x00, 0xC0, 0x00, 0xC0, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1A10*/ 0x03, 0xC0, 0x0C, 0x30, 0x0C, 0x30, 0x03, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1A20*/ 0x00, 0xC0, 0x03, 0xF0, 0x0C, 0xCC, 0x0C, 0xC0, 0x0C, 0xCC, 0x03, 0xF0, 0x00, 0xC0, 0x00, 0x00,
		/*0x1A30*/ 0x03, 0xF0, 0x0F, 0x0C, 0x0F, 0x00, 0x3F, 0xC0, 0x0F, 0x00, 0x0F, 0x03, 0x3F, 0xFC, 0x00, 0x00,
		/*0x1A40*/ 0x0F, 0xC0, 0x3C, 0x00, 0x0F, 0xC0, 0x30, 0xF0, 0x3C, 0x30, 0x0F, 0xC0, 0x00, 0xF0, 0x3F, 0xC0,
		/*0x1A50*/ 0x00, 0x00, 0x0F, 0xC0, 0x3F, 0xF0, 0x3F, 0xF0, 0x3F, 0xF0, 0x0F, 0xC0, 0x00, 0x00, 0x00, 0x00,
		/*0x1A60*/ 0x3F, 0xFC, 0xF0, 0xCC, 0xF0, 0xCC, 0xF0, 0xCC, 0x3F, 0xCC, 0x00, 0xCC, 0x00, 0xCC, 0x00, 0xCF,
		/*0x1A70*/ 0x0F, 0xF0, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0xF0, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0xF0, 0x00, 0x00,
		/*0x1A80*/ 0x0F, 0xF0, 0x30, 0x0C, 0xCF, 0xC3, 0xCC, 0x33, 0xCF, 0xC3, 0xCC, 0x33, 0x30, 0x0C, 0x0F, 0xF0,
		/*0x1A90*/ 0x0F, 0xF0, 0x30, 0x0C, 0xC3, 0xC3, 0xCC, 0x03, 0xCC, 0x03, 0xC3, 0xC3, 0x30, 0x0C, 0x0F, 0xF0,
		/*0x1AA0*/ 0xFF, 0x03, 0x33, 0xCF, 0x33, 0x33, 0x33, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1AB0*/ 0x00, 0x30, 0x00, 0xC0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1AC0*/ 0x0C, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1AD0*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x3F, 0xFF, 0x00, 0xC0, 0x3F, 0xFF, 0x03, 0x00, 0x00, 0x00,
		/*0x1AE0*/ 0x3F, 0xFF, 0xF0, 0xF0, 0xF0, 0xF0, 0xFF, 0xFC, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xFF, 0x00, 0x00,
		/*0x1AF0*/ 0x0F, 0xF3, 0x3C, 0x3C, 0x3C, 0xFC, 0x3F, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0xCF, 0xF0, 0x00, 0x00,
		/*0x1B00*/ 0x00, 0x00, 0x3C, 0x3C, 0xC3, 0xF3, 0xC3, 0xC3, 0xCF, 0xC3, 0x3C, 0x3C, 0x00, 0x00, 0x00, 0x00,
		/*0x1B10*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0xC0, 0x0F, 0xFC, 0x00, 0xC0, 0x00, 0xC0, 0x0F, 0xFC,
		/*0x1B20*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x03, 0xC0, 0x0C, 0x00, 0x03, 0xC0, 0x00, 0x30, 0x0F, 0xF0,
		/*0x1B30*/ 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x03, 0xC0, 0x00, 0x30, 0x03, 0xC0, 0x0C, 0x00, 0x0F, 0xF0,
		/*0x1B40*/ 0xF0, 0x0F, 0x3C, 0x3C, 0xFF, 0xFF, 0x03, 0xC0, 0xFF, 0xFF, 0x03, 0xC0, 0x03, 0xC0, 0x00, 0x00,
		/*0x1B50*/ 0x00, 0x00, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3F, 0xF3, 0x30, 0x00, 0xC0, 0x00,
		/*0x1B60*/ 0x0F, 0xC0, 0x00, 0xF0, 0x03, 0xFC, 0x0F, 0x3C, 0x3C, 0x3C, 0x3C, 0x30, 0x0F, 0xC0, 0x00, 0x00,
		/*0x1B70*/ 0xFF, 0xFC, 0x3C, 0x0C, 0x0F, 0x00, 0x03, 0xC0, 0x0F, 0x00, 0x3C, 0x0C, 0xFF, 0xFC, 0x00, 0x00,
		/*0x1B80*/ 0xFF, 0xFF, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x00, 0x00,
		/*0x1B90*/ 0x00, 0x00, 0x00, 0x03, 0x3F, 0xFC, 0xCF, 0x3C, 0x0F, 0x3C, 0x0F, 0x3C, 0x0C, 0x30, 0x00, 0x00,
		/*0x1BA0*/ 0x00, 0xF0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x0F, 0x00,
		/*0x1BB0*/ 0x0F, 0xF0, 0x3C, 0xF0, 0x3C, 0xF0, 0x0F, 0xF0, 0x00, 0x00, 0x3F, 0xF0, 0x00, 0x00, 0x00, 0x00,
		/*0x1BC0*/ 0x0F, 0xC0, 0x3C, 0xF0, 0x3C, 0xF0, 0x0F, 0xC0, 0x00, 0x00, 0x3F, 0xF0, 0x00, 0x00, 0x00, 0x00,
		/*0x1BD0*/ 0x0F, 0xF0, 0x3C, 0x3C, 0xF0, 0x0F, 0xF0, 0x0F, 0x30, 0x0C, 0x0C, 0x30, 0x3C, 0x3C, 0x00, 0x00,
		/*0x1BE0*/ 0x00, 0x00, 0x00, 0x00, 0x3F, 0xFC, 0x03, 0xCF, 0x3F, 0xFF, 0xF3, 0xC0, 0x3F, 0xFC, 0x00, 0x00,
		/*0x1BF0*/ 0x00, 0x00, 0x00, 0x00, 0x0F, 0xF3, 0x3C, 0x3C, 0x3F, 0xFC, 0x3C, 0x3C, 0xCF, 0xF0, 0x00, 0x00,
		/*0x1C00*/ 0x00, 0x00, 0x03, 0xC0, 0x00, 0x00, 0x03, 0xC0, 0x0F, 0x00, 0x3C, 0x00, 0x3C, 0x0C, 0x0F, 0xF0,
		/*0x1C10*/ 0x00, 0x00, 0x03, 0xC0, 0x03, 0xC0, 0x00, 0x00, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0,
		/*0x1C20*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xF0, 0x00, 0x30, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00,
		/*0x1C30*/ 0x00, 0x0F, 0x00, 0x0C, 0x00, 0x30, 0x30, 0x30, 0xFC, 0xC0, 0x0C, 0xC0, 0x0F, 0x00, 0x03, 0x00,
		/*0x1C40*/ 0x00, 0xF0, 0x03, 0xC0, 0x03, 0xC0, 0x0F, 0xF0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x0F, 0x00,
		/*0x1C50*/ 0x00, 0x00, 0x00, 0x0C, 0x0F, 0xF0, 0x30, 0x0C, 0x0F, 0xF0, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1C60*/ 0x00, 0xC0, 0x03, 0x30, 0x03, 0x30, 0x0C, 0x0C, 0x0C, 0x0C, 0x30, 0x03, 0x3F, 0xFF, 0x00, 0x00,
		/*0x1C70*/ 0x00, 0x00, 0x00, 0xC3, 0x03, 0x0C, 0x0C, 0x30, 0x30, 0xC0, 0x0C, 0x30, 0x03, 0x0C, 0x00, 0xC3,
		/*0x1C80*/ 0x00, 0x00, 0xC3, 0x00, 0x30, 0xC0, 0x0C, 0x30, 0x03, 0x0C, 0x0C, 0x30, 0x30, 0xC0, 0xC3, 0x00,
		/*0x1C90*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF3, 0xCF, 0xF3, 0xCF, 0x00, 0x00,
		/*0x1CA0*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1CB0*/ 0x0C, 0x00, 0x03, 0x00, 0x00, 0x00, 0x3F, 0xF0, 0xF0, 0x3C, 0xFF, 0xFC, 0xF0, 0x3C, 0xF0, 0x3C,
		/*0x1CC0*/ 0x0F, 0x0C, 0x30, 0xF0, 0x00, 0x00, 0x3F, 0xF0, 0xF0, 0x3C, 0xFF, 0xFC, 0xF0, 0x3C, 0xF0, 0x3C,
		/*0x1CD0*/ 0x0F, 0x0C, 0x30, 0xF0, 0x00, 0x00, 0x3F, 0xF0, 0xF0, 0x3C, 0xF0, 0x3C, 0xF0, 0x3C, 0x3F, 0xF0,
		/*0x1CE0*/ 0x3F, 0xFF, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xFC, 0xF0, 0xF0, 0xF0, 0xF0, 0x3F, 0xFF, 0x00, 0x00,
		/*0x1CF0*/ 0x00, 0x00, 0x00, 0x00, 0x3F, 0xFC, 0xF3, 0xCF, 0xF3, 0xFF, 0xF3, 0xC0, 0x3F, 0xFC, 0x00, 0x00,
		/*0x1D00*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1D10*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1D20*/ 0x03, 0x0C, 0x0C, 0x30, 0x0F, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1D30*/ 0x3C, 0xF0, 0x0C, 0x30, 0x30, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1D40*/ 0x00, 0xC0, 0x03, 0x00, 0x03, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1D50*/ 0x03, 0xC0, 0x00, 0xC0, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1D60*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00, 0x0F, 0xFC, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x00,
		/*0x1D70*/ 0x03, 0x00, 0x0C, 0xC0, 0x30, 0x30, 0xC0, 0x0C, 0x30, 0x30, 0x0C, 0xC0, 0x03, 0x00, 0x00, 0x00,
		/*0x1D80*/ 0x0C, 0x30, 0x00, 0x00, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x0F, 0xFC, 0x00, 0x3C, 0x0F, 0xF0,
		/*0x1D90*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1DA0*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1DB0*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1DC0*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1DD0*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1DE0*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1DF0*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1E00*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xA4, 0x01, 0xFE, 0x00, 0x2F,
		/*0x1E10*/ 0x00, 0x00, 0x00, 0x00, 0x0B, 0xE0, 0x0F, 0xE0, 0x0F, 0xE0, 0x0F, 0xE0, 0x4F, 0xE0, 0xEF, 0xEB,
		/*0x1E20*/ 0x00, 0x00, 0x00, 0x00, 0x03, 0xD0, 0x03, 0xE0, 0x03, 0xE0, 0x03, 0xE0, 0x03, 0xE6, 0xE3, 0xFF,
		/*0x1E30*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x6E, 0x00, 0xFF, 0x80, 0xFE, 0x00,
		/*0x1E40*/ 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0xA4, 0x03, 0xFE, 0x43, 0xFF, 0xE7, 0x6F, 0xFF, 0x06, 0xFF,
		/*0x1E50*/ 0xFF, 0xFF, 0x0F, 0xFF, 0x3F, 0xFD, 0xFF, 0xD5, 0xFD, 0x55, 0xF9, 0x55, 0xFA, 0x95, 0xFA, 0xA9,
		/*0x1E60*/ 0xFF, 0xFF, 0xFF, 0xFC, 0xBF, 0xFC, 0xAB, 0xFF, 0xAA, 0xBF, 0xAA, 0x9F, 0xA9, 0x5F, 0x95, 0x5F,
		/*0x1E70*/ 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x06, 0xC0, 0x6F, 0xC6, 0xFE, 0xEF, 0xE4, 0xFE, 0x40,
		/*0x1E80*/ 0x01, 0xBF, 0x1B, 0xFB, 0xBF, 0x93, 0xF9, 0x03, 0x90, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B,
		/*0x1E90*/ 0xFA, 0xA9, 0xFA, 0x95, 0xF9, 0x55, 0xFD, 0x55, 0xFF, 0xD5, 0x3F, 0xFD, 0x3F, 0xFF, 0xFF, 0xFF,
		/*0x1EA0*/ 0x95, 0x5F, 0xA9, 0x5F, 0xAA, 0x9F, 0xAA, 0xBF, 0xAB, 0xFF, 0xBF, 0xFC, 0xFF, 0xF0, 0xFF, 0xFF,
		/*0x1EB0*/ 0xFF, 0x90, 0xFF, 0xF9, 0xDB, 0xFF, 0xC1, 0xBF, 0xC0, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00,
		/*0x1EC0*/ 0x00, 0xBF, 0x02, 0xFF, 0x00, 0xB9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1ED0*/ 0xFF, 0xCB, 0x9B, 0xC0, 0x0B, 0xC0, 0x0B, 0xC0, 0x0B, 0xC0, 0x07, 0xC0, 0x00, 0x00, 0x00, 0x00,
		/*0x1EE0*/ 0xEB, 0xFB, 0x0B, 0xF1, 0x0B, 0xF0, 0x0B, 0xF0, 0x0B, 0xF0, 0x0B, 0xE0, 0x00, 0x00, 0x00, 0x00,
		/*0x1EF0*/ 0xF8, 0x00, 0xBF, 0x40, 0x1A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1F00*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1F10*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1F20*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1F30*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1F40*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1F50*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1F60*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1F70*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1F80*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1F90*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1FA0*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1FB0*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1FC0*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1FD0*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1FE0*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		/*0x1FF0*/ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, };
	unsigned char* src = (unsigned char*)videodata;
	unsigned char* dst = sysram + 0x0800;
	for (int b = 0x1800; b > 0; b--)
		*(dst++) = *(src++);
}

void InstallROM()
{
	const char* infilename[4] = {
		"bankc.rom",
		"bankd.rom",
		"banke.rom",
		"bankf.rom"
	};
	for (int i = 0; i < 4; ++i)
	{
		for (int p = 0; p < 16; ++p)
			syspflags[0xc0 | (i << 4) | p] = PF_TROM;
		std::ifstream infile(infilename[i], std::ios::binary);
		if (infile.is_open())
		{
			std::streamsize readsize = 0x1000;
			char* romptr = (char*)sysram + 0xC000 + 0x1000 * i;
			while (readsize && infile.good())
			{
				infile.read(romptr, readsize);
				readsize -= infile.gcount();
				romptr += infile.gcount();
			}
			infile.close();
			cartridgeinserted = true;
		}
	}
}

bool LoadCartridge(const char* infilename)
{
	std::ifstream infile(infilename, std::ios::binary);
	if (!infile.is_open())
	{
		infile.close();
		return false;
	}
	char readbuf[0x100];
	std::streamsize readsize = 0x8;
	char* readptr = readbuf;
	// read 8-byte signature
	while (readsize && infile.good())
	{
		infile.read(readptr, readsize);
		readsize -= infile.gcount();
		readptr += infile.gcount();
	}
	if (infile.eof() || !infile.good())
	{
		infile.close();
		return false;
	}
	if ( !((readbuf[0] == (char)0x47) // magic signature for R6k cartridge format 1986c
		&& (readbuf[1] == (char)0xa9)
		&& (readbuf[2] == (char)0x02)
		&& (readbuf[3] == (char)0x6a)
		&& (readbuf[4] == (char)0xbb)
		&& (readbuf[5] == (char)0x47)
		&& (readbuf[6] == (char)0xf3)
		&& (readbuf[7] == (char)0xa7)))
	{
		infile.close();
		return false;
	}
	// read offsets to (base address space) page flags start,
	// (base address space) ROM/NonVol data start (4-byte LE)
	readsize = 0x8;
	readptr = readbuf;
	while (readsize && infile.good())
	{
		infile.read(readptr, readsize);
		readsize -= infile.gcount();
		readptr += infile.gcount();
	}
	int pfstart = (unsigned char)readbuf[0] | (unsigned char)readbuf[1] << 8 | (unsigned char)readbuf[2] << 16 | (unsigned char)readbuf[3] << 24;
	int datastart = (unsigned char)readbuf[4] | (unsigned char)readbuf[5] << 8 | (unsigned char)readbuf[6] << 16 | (unsigned char)readbuf[7] << 24;
	// TODO: read extension data
	// read BAS page flags
	infile.seekg(pfstart);
	readsize = 0xa0;
	readptr = (char*)syspflags + 0x20;
	while (readsize && infile.good())
	{
		infile.read(readptr, readsize);
		readsize -= infile.gcount();
		readptr += infile.gcount();
	}
	// read BAS ROM & factory-state non-volatile memory
	infile.seekg(datastart);
	for (int p = 0x20; p < 0xc0; ++p)
	{
		if (syspflags[p] & PF_TROM)
		{
			readsize = 0x100;
			readptr = (char*)sysram + (p << 8);
			while (readsize && infile.good())
			{
				infile.read(readptr, readsize);
				readsize -= infile.gcount();
				readptr += infile.gcount();
			}
		}
	}
	infile.close();
	return true;
}

void LogFVMC(uint16_t dest, uint16_t src, uint8_t value)
{
	dlogentry* newentry = ExtendLog(dlogentry::dletype::LT_FVMC);
	newentry->fvmcentry.dest = dest;
	newentry->fvmcentry.src = src;
	newentry->fvmcentry.value = value;
	newentry->fvmcentry.memtype = syspflags[src >> 8];
}

void LogRead(uint16_t address, uint8_t value)
{
	if (!partialinst)
		goto logmementry;
	if (debuglogexpectargs == -1)
	{
		const char nargsbyopcode[256] = {
			/*      0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
			/* 0 */ 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 2, 2, 2, 2, /* 0 */
			/* 1 */ 1, 1, 0, 1, 1, 1, 1, 1, 0, 2, 0, 2, 2, 2, 2, 2, /* 1 */
			/* 2 */ 2, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 2, 2, 2, 2, /* 2 */
			/* 3 */ 1, 1, 0, 1, 1, 1, 1, 1, 0, 2, 0, 2, 2, 2, 2, 2, /* 3 */
			/* 4 */ 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 2, 2, 2, 2, /* 4 */
			/* 5 */ 1, 1, 0, 1, 1, 1, 1, 1, 0, 2, 0, 2, 2, 2, 2, 2, /* 5 */
			/* 6 */ 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 2, 2, 2, 2, /* 6 */
			/* 7 */ 1, 1, 0, 1, 1, 1, 1, 1, 0, 2, 0, 2, 2, 2, 2, 2, /* 7 */
			/* 8 */ 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 2, 2, 2, 2, /* 8 */
			/* 9 */ 1, 1, 0, 1, 1, 1, 1, 1, 0, 2, 0, 2, 2, 2, 2, 2, /* 9 */
			/* A */ 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 2, 2, 2, 2, /* A */
			/* B */ 1, 1, 0, 1, 1, 1, 1, 1, 0, 2, 0, 2, 2, 2, 2, 2, /* B */
			/* C */ 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 2, 2, 2, 2, /* C */
			/* D */ 1, 1, 0, 1, 1, 1, 1, 1, 0, 2, 0, 2, 2, 2, 2, 2, /* D */
			/* E */ 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 2, 2, 2, 2, /* E */
			/* F */ 1, 1, 0, 1, 1, 1, 1, 1, 0, 2, 0, 2, 2, 2, 2, 2  /* F */
		};
		if (partialinst->entrytype != dlogentry::dletype::LT_PARTIALINST)
			goto logmementry;
		partialinst->instentry.opc = value;
		debuglogexpectargs = nargsbyopcode[value];
		partialinst->instentry.nargs = 0;
	}
	else if (debuglogexpectargs)
	{
		if (partialinst->entrytype != dlogentry::dletype::LT_PARTIALINST)
			goto logmementry;
		partialinst->instentry.arg[partialinst->instentry.nargs] = value;
		++(partialinst->instentry.nargs);
		--debuglogexpectargs;
		if (!debuglogexpectargs)
		{
			partialinst->entrytype = dlogentry::dletype::LT_INST;
			partialinst = nullptr;
		}
	}
	else
	{
	logmementry:
		dlogentry* newentry = ExtendLog(dlogentry::dletype::LT_READ);
		newentry->mementry.address = address;
		newentry->mementry.value = value;
		newentry->mementry.memtype = syspflags[address >> 8] & PF_TMASK;
	}
}

void LogReset()
{
	ExtendLog(dlogentry::dletype::LT_RESET);
}

void LogScanline(int scanline)
{
	ExtendLog(dlogentry::dletype::LT_SCANLINE)->scanline = scanline;
}

void LogStack(unsigned char sp)
{
	dlogentry* newentry = ExtendLog(dlogentry::dletype::LT_STACK);
	for (unsigned i = 0, j = (sp + 1) | 0x100; i < 7 && j < 0x0200; ++i, ++j)
	{
		newentry->stackentry.stack[i] = sysram[j];
	}
	newentry->stackentry.nstack = 0xfd - sp;
	//DoDebugger();
}

extern "C" void LogStep()
{
	extern uint32_t clockticks6502;
	extern uint16_t pc;
	extern uint8_t sp, a, x, y, status;
	static dlogentry* laststateentry = nullptr, * lastinstentry = nullptr;
	if (partialinst && partialinst->entrytype == dlogentry::dletype::LT_PARTIALINST)
		partialinst->entrytype = dlogentry::dletype::LT_INST;
	dlogentry* newentry = ExtendLog(dlogentry::dletype::LT_STATE);
	newentry->stateentry.ticks = clockticks6502;
	newentry->stateentry.pc = pc;
	newentry->stateentry.sp = sp;
	newentry->stateentry.a = a;
	newentry->stateentry.x = x;
	newentry->stateentry.y = y;
	newentry->stateentry.status = status;
	if (laststateentry && lastinstentry)
		lastinstentry->instentry.cycles = newentry->stateentry.ticks - laststateentry->stateentry.ticks;
	if (laststateentry && laststateentry->stateentry.sp != newentry->stateentry.sp)
		LogStack(sp);
	laststateentry = newentry;
	lastinstentry = partialinst = ExtendLog(dlogentry::dletype::LT_PARTIALINST);
	debuglogexpectargs = -1;
}

void LogWrite(uint16_t address, uint8_t value)
{
	dlogentry* last = debuglog + ((debuglogend - 1) & dlogidxmask);
	if (last->entrytype == dlogentry::dletype::LT_PARTIALINST)
		last->entrytype = dlogentry::dletype::LT_INST;
	dlogentry* newentry = ExtendLog(dlogentry::dletype::LT_WRITE);
	newentry->mementry.address = address;
	newentry->mementry.value = value;
	newentry->mementry.memtype = syspflags[address >> 8] & PF_TMASK;
}

void PaintCell(unsigned char col, unsigned char row, unsigned char glyph, unsigned char* att)
{
	unsigned char* faddr = sysram;
	faddr += 0x1000 | (glyph << 4);
	unsigned char* paddr = sysram;
	paddr += 0x0FE0;
	for (int gy = 0, cy = 0, sy = row << 5; gy < 8; ++gy)
	{
		unsigned char pix[8];
		pix[0] = paddr[att[(*faddr & 0xC0) >> 6]];
		pix[1] = paddr[att[(*faddr & 0x30) >> 4]];
		pix[2] = paddr[att[(*faddr & 0xC) >> 2]];
		pix[3] = paddr[att[(*faddr & 0x3)]];
		faddr++;
		pix[4] = paddr[att[(*faddr & 0xC0) >> 6]];
		pix[5] = paddr[att[(*faddr & 0x30) >> 4]];
		pix[6] = paddr[att[(*faddr & 0xC) >> 2]];
		pix[7] = paddr[att[(*faddr & 0x3)]];
		faddr++;
		for (int ry = 0; ry < pixheight; ++ry, ++cy)
		{
			unsigned char* dst = (unsigned char*)cellcanvas->pixels + cellcanvas->pitch * cy;
			for (int gx = 0, cx = 0; gx < 8; ++gx)
			{
				for (int rx = 0; rx < pixwidth; ++rx, ++dst)
				{
					*dst = pix[gx];
				}
			}
		}
		scanlinedirty[sy++] = true;
		scanlinedirty[sy++] = true;
		scanlinedirty[sy++] = true;
		scanlinedirty[sy++] = true;
	}
	SDL_Rect dstrect;
	dstrect.x = col * pixwidth * 8;
	dstrect.y = row * pixheight * 8;
	SDL_BlitSurface(cellcanvas, nullptr, framebuffer, &dstrect);
}

inline void PaintCell(unsigned char col, unsigned char row)
{
	unsigned char glyph = sysram[0x0800 | row << 5 | col];
	unsigned char att[4];
	unsigned char tatt[5];
	tatt[0] = sysram[0x0A40 + ((row & 0x1e) << 4) + col] >> (4 * (~row & 0x1));
	tatt[1] = sysram[0x0B60 + ((row & 0x1e) << 4) + col] >> (4 * (~row & 0x1));
	tatt[2] = sysram[0x0C80 + ((row & 0x1e) << 4) + col] >> (4 * (~row & 0x1));
	tatt[3] = sysram[0x0DA0 + ((row & 0x1e) << 4) + col] >> (4 * (~row & 0x1));
	tatt[4] = sysram[0x0EC0 + ((row & 0x1e) << 4) + col] >> (4 * (~row & 0x1));
	att[0] = (tatt[0] & 0x1) | (tatt[1] & 0x1) << 1 | (tatt[2] & 0x1) << 2 | (tatt[3] & 0x1) << 3 | (tatt[4] & 0x1) << 4;
	att[1] = (tatt[0] & 0x2) >> 1 | (tatt[1] & 0x2) | (tatt[2] & 0x2) << 1 | (tatt[3] & 0x2) << 2 | (tatt[4] & 0x2) << 3;
	att[2] = (tatt[0] & 0x4) >> 2 | (tatt[1] & 0x4) >> 1 | (tatt[2] & 0x4) | (tatt[3] & 0x4) << 1 | (tatt[4] & 0x4) << 2;
	att[3] = (tatt[0] & 0x8) >> 3 | (tatt[1] & 0x8) >> 2 | (tatt[2] & 0x8) >> 1 | (tatt[3] & 0x8) | (tatt[4] & 0x8) << 1;
	PaintCell(col, row, glyph, att);
}

void RandomBitFlip()
{
	static std::mt19937 gen(0);
	static std::uniform_int_distribution<> dis(0x0800, 0x1FFF);
	if (dis(gen) & 0xf)
		return;
	int addr = dis(gen);
	int bit = dis(gen) & 7;
	write6502(addr, sysram[addr] ^ (1 << bit));
}

void RenderScanline(int scanline, SDL_Surface* framebuffer, SDL_Surface* winsurface)
{
	if (!scanlinedirty[scanline])
		return;
	int y0 = scanline * winsurface->h / 576;
	int y1 = (scanline + 1) * winsurface->h / 576;
	unsigned char* src = (unsigned char*)(framebuffer->pixels) + framebuffer->pitch * y0;
	unsigned char* dst = (unsigned char*)(winsurface->pixels) + winsurface->pitch * y0;
	//pitch is assumed same for both surfaces
	unsigned char* stop = (unsigned char*)(framebuffer->pixels) + framebuffer->pitch * y1;
	while (src < stop)
	{
		*dst = *src;
		++src;
		++dst;
	}
	scanlinedirty[scanline] = false;
}

Uint32 SetBool(Uint32 interval, void* boolvar)
{
	*(bool*)boolvar = true;
	return interval;
}

inline uint8_t bare_read6502(uint16_t address)
{
	if ((address & 0xff00) == 0x0200)
	{
		switch (address & 0xff)
		{
			unsigned char t;
		case 0x44: // keyboard
			t = keypressregister;
			keypressregister = 0;
			return t;
		case 0xfc: // video flags
			return videostate;
		}
	}
	if ((syspflags[address >> 8] & PF_TMASK) == PF_TFLOATING)
	{
		static std::uniform_int_distribution<> dis(0x00, 0xFF);
		return dis(floatgen);
	}
	return sysram[address];
}

extern "C" uint8_t read6502(uint16_t address)
{
	uint8_t result = bare_read6502(address);
	LogRead(address, result);
	return result;
}

extern "C" void write6502(uint16_t address, uint8_t value)
{
	LogWrite(address, value);
	static unsigned short fvmcdest, fvmcsrc; // fast video memory copy address page registers (<<8 here)
	if ((address & 0xff00) == 0x0000 && fvmcdest && !videobusy)
	{
		// do fast video memory copy instead of writing value to literal address
		// note, hardware implementation does not guarantee memory at zp address won't be changed
		value = sysram[address & 0xff | fvmcsrc];
		address = address & 0xff | fvmcdest;
		LogFVMC(address, address & 0xff | fvmcsrc, value);
	}
	if (videobusy && address >= 0x0800 && address < 0x2000)
	{
		return; // writing to video ram blocked
	}
	if (!(syspflags[address >> 8] & PF_TRAM))
	{
		return; // this page is not writeable
	}
	sysram[address] = value;
	if (address >= 0x0800 && address < 0x2000)
	{
		if (address >= 0x1000) // change to font memory, repaint affected cells
		{
			unsigned char c = (address & 0xff0) >> 4;
			unsigned char* checkptr = sysram + 0x0800;
			for (int y = 0; y < 18; ++y)
				for (int x = 0; x < 32; ++x)
					if (*checkptr++ == c)
						PaintCell(x, y);
		}
		else if (address < 0x0A40) // change a character on screen, repaint affected cell
		{
			int x = address & 0x1f;
			int y = (address & 0x3e0) >> 5;
			PaintCell(x, y);
		}
		else if (address > 0x0FE0) // change a palette entry, repaint affected cells
		{
			unsigned char a = address - 0x0FE0;
			unsigned char* checkptr[5] = {
				sysram + 0xA40,
				sysram + 0xB60,
				sysram + 0xC80,
				sysram + 0xDA0,
				sysram + 0xEC0 };
			for (int i = 0; i < 0x120; ++i)
			{
				int x = i & 0x1f;
				int y = (i & 0x1e0) >> 4;
				unsigned char att[4];
				att[0] = (*checkptr[0] & 0x10) >> 4 | (*checkptr[1] & 0x10) >> 3 | (*checkptr[2] & 0x10) >> 2 | (*checkptr[3] & 0x10) >> 1 | (*checkptr[4] & 0x10);
				att[1] = (*checkptr[0] & 0x20) >> 5 | (*checkptr[1] & 0x20) >> 4 | (*checkptr[2] & 0x20) >> 3 | (*checkptr[3] & 0x20) >> 2 | (*checkptr[4] & 0x20) >> 1;
				att[2] = (*checkptr[0] & 0x40) >> 6 | (*checkptr[1] & 0x40) >> 5 | (*checkptr[2] & 0x40) >> 4 | (*checkptr[3] & 0x40) >> 3 | (*checkptr[4] & 0x40) >> 2;
				att[3] = (*checkptr[0] & 0x80) >> 7 | (*checkptr[1] & 0x80) >> 6 | (*checkptr[2] & 0x80) >> 5 | (*checkptr[3] & 0x80) >> 4 | (*checkptr[4] & 0x80) >> 3;
				if (att[0] == a || att[1] == a || att[2] == a || att[3] == a)
					PaintCell(x, y);
				att[0] = (*checkptr[0] & 0x1) | (*checkptr[1] & 0x1) << 1 | (*checkptr[2] & 0x1) << 2 | (*checkptr[3] & 0x1) << 3 | (*checkptr[4] & 0x1) << 4;
				att[1] = (*checkptr[0] & 0x2) >> 1 | (*checkptr[1] & 0x2) | (*checkptr[2] & 0x2) << 1 | (*checkptr[3] & 0x2) << 2 | (*checkptr[4] & 0x2) << 3;
				att[2] = (*checkptr[0] & 0x4) >> 2 | (*checkptr[1] & 0x4) >> 1 | (*checkptr[2] & 0x4) | (*checkptr[3] & 0x4) << 1 | (*checkptr[4] & 0x4) << 2;
				att[3] = (*checkptr[0] & 0x8) >> 3 | (*checkptr[1] & 0x8) >> 2 | (*checkptr[2] & 0x8) >> 1 | (*checkptr[3] & 0x8) | (*checkptr[4] & 0x8) << 1;
				if (att[0] == a || att[1] == a || att[2] == a || att[3] == a)
					PaintCell(x, y | 0x1);
				++checkptr[0];
				++checkptr[1];
				++checkptr[2];
				++checkptr[3];
				++checkptr[4];
			}
		}
		else { // change a pair of cells' attributes, repaint affected cells
			int x = address & 0x1f;
			int y = ((address - 0x0A40 - ((address - 0x0A40) / 0x120) * 0x120) & 0x3e0) >> 4;
			PaintCell(x, y);
			PaintCell(x, y | 0x1);
		}
	}
	if ((address & 0xff00) == 0x0300)
	{
		switch (address & 0xff)
		{
		case 0xf8:
			fvmcdest = value << 8;
			break;
		case 0xf9:
			fvmcsrc = value << 8;
			break;
		case 0xfc:
			// TODO: set video flags
			break;
		}
	}
}

int main(int argc, char** argv)
{
	if (int rv = InitPaths())
		return rv;
	if (int rv = InitMainWindow())
		return rv;
	if (int rv = InitMemory())
		return rv;
	DoPickFile(FT_CART);
	if (int rv = InitEmulator())
		return rv;
	if (int rv = InitSound())
		return rv;
	int resetcounter = 0;
	int scanline = 0;
	bool nextframe = false;
	SDL_TimerID frame_timer_id = SDL_AddTimer(16, SetBool, &nextframe);
	SDL_Surface* mwsurface = SDL_GetWindowSurface(mainwindow);
	while (true)
	{
		sysram[0x02fe] = scanline;
		sysram[0x02ff] = scanline >> 8;
		SDL_Event event;
		while (SDL_PollEvent(&event))
		{
			unsigned char inkey;
			switch (event.type)
			{
			case SDL_KEYDOWN:
				if (inkey = keytrans[(event.key.keysym.sym | (event.key.keysym.sym >> 22)) & 0x1ff])
				{
					keypressregister = inkey;
					if (event.key.keysym.mod & KMOD_SHIFT)
						keypressregister ^= 0x20;
					if (event.key.keysym.mod & KMOD_CTRL)
						keypressregister ^= 0x60;
					if (event.key.keysym.mod & KMOD_ALT)
						keypressregister ^= 0x80;
					break;
				}
				switch (event.key.keysym.sym)
				{
				case SDLK_KP_ENTER:
				case SDLK_KP_0:
					DoMenu(0);
					break;
				case SDLK_KP_1:
					DoMenu(1);
					break;
				case SDLK_KP_2:
					DoMenu(2);
					break;
				case SDLK_KP_3:
					DoMenu(3);
					break;
				case SDLK_KP_4:
					DoMenu(4);
					break;
				case SDLK_KP_5:
					DoMenu(5);
					break;
				case SDLK_KP_6:
					DoMenu(6);
					break;
				case SDLK_KP_7:
					DoMenu(7);
					break;
				case SDLK_KP_8:
					DoMenu(8);
					break;
				case SDLK_KP_9:
					DoMenu(9);
					break;
				}
				break;
			case SDL_QUIT:
				goto cleanup;
			default:
				if (event.type == UE_RESETCPU)
				{
					LogReset();
					reset6502();
					resetcounter = 8955;
					LogStep();
				}
			}
		}
		// 6502 clocked at 4MHz, pixel clock at 34.96MHz)
		if (scanline < 576)
		{
			if (!resetcounter)
			{
				LogScanline(scanline);
				videobusy = true;
				videostate = 0x00;
				// run 6502 for 21.967963386728 microseconds (768 pixel ticks, 88 cpu cycles)
				exec6502(88);
				RenderScanline(scanline, framebuffer, mwsurface);
				videobusy = false;
				videostate = 0x02;
				// run 6502 for 5.949656750572 microseconds (208 pixel ticks, 24 cpu cycles)
				exec6502(12);
				videostate = 0x03;
				exec6502(12);
			}
			else
				--resetcounter;
			++scanline;
		}
		else if (scanline < 597)
		{
			// TODO: issue IRQ if video interrupt condition is met
			if (!resetcounter)
			{
				// run 6502 for 27.9176201373 microseconds (976 pixel ticks, 112 cpu cycles)
				LogScanline(scanline);
				if (scanline == 576)
				{
					videostate = 0x20;
					exec6502(32);
					videostate = 0x30;
					exec6502(56);
					videostate = 0x32;
					exec6502(12);
					videostate = 0x33;
					exec6502(12);
				}
				else {
					videostate = 0x30;
					exec6502(88);
					videostate = 0x32;
					exec6502(12);
					videostate = 0x33;
					exec6502(12);
				}
			}
			else
				--resetcounter;
			++scanline;
		}
		else if (nextframe)
		{
			scanline = 0;
			nextframe = false;
			SDL_UpdateWindowSurface(mainwindow);
			//RandomBitFlip();
		}
		else
		{
			SDL_Delay(1);
		}
	}
	SDL_RemoveTimer(frame_timer_id);
cleanup:
	SDL_CloseAudioDevice(sounddev);
	SDL_DestroyWindow(mainwindow);
	SDL_FreeSurface(cellcanvas);
	SDL_Quit();
	delete[] sysram;
	return 0;
}


